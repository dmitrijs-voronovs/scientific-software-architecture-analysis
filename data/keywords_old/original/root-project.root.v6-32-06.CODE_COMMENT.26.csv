id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Safety,detect,detect,29,// Mark us visited so we can detect a cycle,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Safety,avoid,avoid,34,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:14,Usability,simpl,simplify,14,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Safety,avoid,avoid,17,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Usability,simpl,simplifying,34,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:18,Usability,simpl,simplify,18,"// If we couldn't simplify, we may have to create a phi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:33,Modifiability,variab,variable,33,// Set ourselves up for the next variable by resetting visited state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Security,access,access,29,"// This starts at the memory access, and goes backwards in the block to find the; // previous definition. If a definition is not found the block of the access,; // it continues globally, creating phi nodes to ensure we have a single; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:152,Security,access,access,152,"// This starts at the memory access, and goes backwards in the block to find the; // previous definition. If a definition is not found the block of the access,; // it continues globally, creating phi nodes to ensure we have a single; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Security,access,access,29,"// This starts at the memory access, and goes backwards in the block to the find; // the previous definition. If the definition is not found in the block of the; // access, it returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:165,Security,access,access,165,"// This starts at the memory access, and goes backwards in the block to the find; // the previous definition. If the definition is not found in the block of the; // access, it returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:35,Security,access,access,35,"// Otherwise, have to walk the all access iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Safety,Detect,Detect,3,// Detect equal or self arguments,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:421,Performance,optimiz,optimized,421,"// In cases without unreachable blocks, because uses do not create new; // may-defs, there are only two cases:; // 1. There was a def already below us, and therefore, we should not have; // created a phi node because it was already needed for the def.; //; // 2. There is no def below us, and therefore, there is no extra renaming work; // to do.; // In cases with unreachable blocks, where the unnecessary Phis were; // optimized out, adding the Use may re-insert those Phis. Hence, when; // inserting Uses outside of the MSSA creation process, and new Phis were; // added, rename all uses if we are asked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:75,Security,access,access,75,// Replace any operand with us an incoming block with the new defining; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:150,Deployability,update,update,150,"// A brief description of the algorithm:; // First, we compute what should define the new def, using the SSA; // construction algorithm.; // Then, we update the defs below us (and any new phi nodes) in the graph to; // point to the correct new defs, to ensure we only have one variable, and no; // disconnected stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:277,Modifiability,variab,variable,277,"// A brief description of the algorithm:; // First, we compute what should define the new def, using the SSA; // construction algorithm.; // Then, we update the defs below us (and any new phi nodes) in the graph to; // point to the correct new defs, to ensure we only have one variable, and no; // disconnected stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:71,Safety,avoid,avoid,71,// Leave the MemoryUses alone.; // Also make sure we skip ourselves to avoid self references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:36,Security,access,access,36,// and that def is now our defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:240,Deployability,update,update,240,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:303,Deployability,update,update,303,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:221,Performance,perform,performed,221,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:791,Usability,simpl,simplifications,791,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:245,Performance,optimiz,optimized,245,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:162,Security,access,access,162,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:201,Security,access,access,201,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:234,Security,access,access,234,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:261,Security,access,access,261,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:79,Performance,optimiz,optimized,79,"// Add the phis created into the IDF blocks to NonOptPhis, so they are not; // optimized out as trivial by the call to getPreviousDefFromEnd below.; // Once they are complete, all these Phis are added to the FixupList, and; // removed from NonOptPhis inside fixupDefs(). Existing Phis in IDF may; // need fixing as well, and potentially be trivial before this insertion,; // hence add all IDF Phis. See PR43044.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Performance,Optimiz,Optimize,3,// Optimize potentially non-minimal phis added in this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:78,Performance,optimiz,optimized,78,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:123,Performance,Optimiz,Optimized,123,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:52,Security,access,access,52,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:58,Performance,optimiz,optimize,58,"// The temporary Phi is being fixed, unmark it for not to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:32,Availability,down,down,32,"// Otherwise, we need to search down through the CFG.; // For each of our successors, handle it directly if their is a phi, or; // place on the fixup worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Security,access,access,34,"// We are now this def's defining access, make sure we actually dominate; // it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:119,Integrability,depend,depending,119,"// This may insert new phi nodes, because we are not guaranteed the; // block we are processing has a single pred, and depending where the; // store was inserted, it may require phi nodes below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Usability,simpl,simplified,17,"// The clone was simplified, it's no longer a MemoryDef, look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:458,Deployability,update,updateForClonedBlockIntoPred,458,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:225,Usability,simpl,simplified,225,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:355,Usability,simpl,simplified,355,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update incoming edges into MPhi. Remove all but the incoming edge from; // Preheader. Add an edge from NewMPhi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update Uses and Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:475,Security,access,access,475,"// All defs/phis from outside BB that are used in BB, are valid uses in P1.; // Since those defs/phis must have dominated BB, and also dominate P1.; // Defs from BB being used in BB will be replaced with the cloned defs from; // VM. The uses of BB's Phi (if it exists) in BB will be replaced by the; // incoming def into the Phi from P1.; // Instructions cloned into the predecessor are in practice sometimes; // simplified, so disable the use of the template, and create an access from; // scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:413,Usability,simpl,simplified,413,"// All defs/phis from outside BB that are used in BB, are valid uses in P1.; // Since those defs/phis must have dominated BB, and also dominate P1.; // Defs from BB being used in BB will be replaced with the cloned defs from; // VM. The uses of BB's Phi (if it exists) in BB will be replaced by the; // incoming def into the Phi from P1.; // Instructions cloned into the predecessor are in practice sometimes; // simplified, so disable the use of the template, and create an access from; // scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update/insert phis in all successors of exit blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:13,Deployability,update,updates,13,"// Apply all updates, with the RevDeleteUpdates as PostCFGView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:18,Deployability,update,update,18,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:143,Deployability,update,updates,143,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:215,Deployability,update,updates,215,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:253,Deployability,update,update,253,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:93,Deployability,update,update,93,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:72,Performance,perform,perform,72,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update for deleted edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:57,Deployability,update,updated,57,"// Get recursive last Def, assuming well formed MSSA and updated DT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:4,Usability,Simpl,SimpleLoopUnswitch,4,"// [SimpleLoopUnswitch] If BB is a dead block, about to be deleted, its; // DT is invalidated. Return LoE as its last def. This will be added to; // MemoryPhi node, and later deleted when the block is deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:65,Performance,optimiz,optimized,65,// Get nearest IDom given a set of blocks.; // TODO: this can be optimized by starting the search at the node with the; // lowest level (highest in the tree).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:184,Deployability,Update,Updates,184,"// Map a BB to its predecessors: added + previously existing. To get a; // deterministic order, store predecessors as SetVectors. The order in each; // will be defined by the order in Updates (fixed) and the order given by; // children<> (also fixed). Since we further iterate over these ordered sets,; // we lose the information of multiple edges possibly existing between two; // blocks, so we'll keep and EdgeCount map for that.; // An alternate implementation could keep unordered set for the predecessors,; // traverse either Updates or children<> each time to get the deterministic; // order, and drop the usage of EdgeCount. This alternate approach would still; // require querying the maps for each predecessor, and children<> call has; // additional computation inside for creating the snapshot-graph predecessors.; // As such, we favor using a little additional storage and less compute time.; // This decision can be revisited if we find the alternative more favorable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:531,Deployability,Update,Updates,531,"// Map a BB to its predecessors: added + previously existing. To get a; // deterministic order, store predecessors as SetVectors. The order in each; // will be defined by the order in Updates (fixed) and the order given by; // children<> (also fixed). Since we further iterate over these ordered sets,; // we lose the information of multiple edges possibly existing between two; // blocks, so we'll keep and EdgeCount map for that.; // An alternate implementation could keep unordered set for the predecessors,; // traverse either Updates or children<> each time to get the deterministic; // order, and drop the usage of EdgeCount. This alternate approach would still; // require querying the maps for each predecessor, and children<> call has; // additional computation inside for creating the snapshot-graph predecessors.; // As such, we favor using a little additional storage and less compute time.; // This decision can be revisited if we find the alternative more favorable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:95,Deployability,Update,Updates,95,"// First create MemoryPhis in all blocks that don't have one. Create in the; // order found in Updates, not in PredMap, to get deterministic numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:292,Deployability,update,updated,292,"// TODO: if this becomes a bottleneck, we can save on GetLastDef calls by; // keeping this map before the loop. We can reuse already populated entries; // if an edge is added from the same predecessor to two different blocks,; // and this does happen in rotate. Note that the map needs to be updated; // when deleting non-necessary phis below, if the phi is in the map by; // replacing the value with DefP1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:27,Performance,bottleneck,bottleneck,27,"// TODO: if this becomes a bottleneck, we can save on GetLastDef calls by; // keeping this map before the loop. We can reuse already populated entries; // if an edge is added from the same predecessor to two different blocks,; // and this does happen in rotate. Note that the map needs to be updated; // when deleting non-necessary phis below, if the phi is in the map by; // replacing the value with DefP1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,"// Update Phi with new values for new predecessors and old value for all; // other predecessors. Since AddedBlockSet and PrevBlockSet are ordered; // sets, the order of entries in NewPhi is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:8,Deployability,update,update,8,// Then update or insert their correct incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:55,Availability,redundant,redundant,55,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:40,Deployability,update,updates,40,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:73,Performance,optimiz,optimize,73,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:55,Safety,redund,redundant,55,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:161,Deployability,update,update,161,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:168,Performance,optimiz,optimized,168,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:178,Security,access,accesses,178,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Performance,optimiz,optimized,42,// Mark MemoryPhi users of What not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:43,Security,access,access,43,// Replace all our users with our defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Usability,Clear,Clear,3,"// Clear dangling pointers. We added all MemoryPhi users, but not all; // of them are removed by fixupDefs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:58,Deployability,update,update,58,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:7,Security,access,accesses,7,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:65,Security,access,access,65,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:10,Security,access,accesses,10,"// If all accesses were moved and only a trivial Phi remains, we try to remove; // that Phi. This is needed when From is going to be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:298,Testability,assert,assert,298,"// Note that it is sufficient to know that all edges of the phi node have; // the same argument. If they do, by the definition of dominance frontiers; // (which we used to place this phi), that argument must dominate this phi,; // and thus, must dominate the phi's uses, and so we will not hit the assert; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:37,Security,access,access,37,// Re-point the uses at our defining access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:9,Performance,optimiz,optimized,9,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:236,Performance,optimiz,optimized,236,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:134,Safety,avoid,avoid,134,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:14,Performance,optimiz,optimize,14,// Optionally optimize Phi uses. This will recursively remove trivial phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:30,Security,access,accesses,30,// Drop all references of all accesses in BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:27,Security,access,accesses,27,"// Next, delete all memory accesses in each block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Security,access,accesses,17,// Remove memory accesses in BB for I and all following instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:95,Security,access,access,95,"// FIXME: If this becomes too expensive, iterate until the first instruction; // with a memory access, then iterate over MemoryAccesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update phis in BB's successors to remove BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Performance,Optimiz,Optimize,3,// Optimize trivial phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:536,Deployability,release,release,536,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:408,Integrability,interface,interface,408,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:564,Performance,load,loaded,564,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:37,Usability,learn,learned,37,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:444,Usability,learn,learned,444,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:196,Deployability,pipeline,pipeline,196,"// Function passes executed between InlinerPass runs may have changed the; // module-wide features.; // The cgscc pass manager rules are such that:; // - if a pass leads to merging SCCs, then the pipeline is restarted on the; // merged SCC; // - if a pass leads to splitting the SCC, then we continue with one of the; // splits; // This means that the NodesInLastSCC is a superset (not strict) of the nodes; // that subsequent passes would have processed; // - in addition, if new Nodes were created by a pass (e.g. CoroSplit),; // they'd be adjacent to Nodes in the last SCC. So we just need to check the; // boundary of Nodes in NodesInLastSCC for Nodes we haven't seen. We don't; // care about the nature of the Edge (call or ref). `FunctionLevels`-wise, we; // record them at the same level as the original node (this is a choice, may; // need revisiting).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:16,Integrability,wrap,wrapped,16,// The Function wrapped by N could have been deleted since we last saw it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:79,Deployability,update,update,79,"// Keep track of the nodes and edges we last saw. Then, in onPassEntry,; // we update the node count and edge count from the subset of these nodes that; // survived.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:3,Deployability,Update,Update,3,"// Update the internal state of the advisor, and force invalidate feature; // analysis. Currently, we maintain minimal (and very simple) global state - the; // number of functions and the number of static calls. We also keep track of the; // total IR size in this module, to stop misbehaving policies at a certain bloat; // factor (SizeIncreaseThreshold)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:129,Usability,simpl,simple,129,"// Update the internal state of the advisor, and force invalidate feature; // analysis. Currently, we maintain minimal (and very simple) global state - the; // number of functions and the number of static calls. We also keep track of the; // total IR size in this module, to stop misbehaving policies at a certain bloat; // factor (SizeIncreaseThreshold)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:16,Deployability,update,update,16,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:166,Deployability,update,update,166,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:156,Usability,simpl,simple,156,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:369,Modifiability,variab,variable,369,"// Walk through the operands of a given User via worklist iteration and populate; // the set of GlobalValue references encountered. Invoked either on an; // Instruction or a GlobalVariable (which walks its initializer).; // Return true if any of the operands contains blockaddress. This is important; // to know when computing summary for global var, because if global variable; // references basic block address we can't import it separately from function; // containing that basic block. For simplicity we currently don't import such; // global vars at all. When importing function we aren't interested if any; // instruction in it takes an address of any basic block, because instruction; // can only take an address of basic block located in the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:494,Usability,simpl,simplicity,494,"// Walk through the operands of a given User via worklist iteration and populate; // the set of GlobalValue references encountered. Invoked either on an; // Instruction or a GlobalVariable (which walks its initializer).; // Return true if any of the operands contains blockaddress. This is important; // to know when computing summary for global var, because if global variable; // references basic block address we can't import it separately from function; // containing that basic block. For simplicity we currently don't import such; // global vars at all. When importing function we aren't interested if any; // instruction in it takes an address of any basic block, because instruction; // can only take an address of basic block located in the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:31,Testability,test,test,31,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:71,Testability,test,test,71,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:242,Testability,test,test,242,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:56,Performance,load,load,56,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:86,Performance,optimiz,optimizing,86,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:116,Testability,test,test,116,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:142,Modifiability,variab,variable,142,"// We don't allow inlining of function with indirect branch to blockaddress.; // If the blockaddress escapes the function, e.g., via a global variable,; // inlining may lead to an invalid cross-function reference. So we shouldn't; // import such function either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:151,Modifiability,variab,variable,151,"// Regular LTO module doesn't participate in ThinLTO import,; // so no reference from it can be read/writeonly, since this; // would require importing variable as local copy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:39,Performance,load,load,39,// Postpone processing of non-volatile load instructions; // See comments below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:362,Performance,load,load,362,// All references from second operand of store (destination address); // can be considered write-only if they're not referenced by any; // non-store instruction. References from first operand of store; // (stored value) can't be treated either as read- or as write-only; // so we add them to RefEdges as we do with all other instructions; // except non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:297,Availability,error,errors,297,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:370,Usability,simpl,simple,370,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:34,Usability,simpl,simply,34,"// If this is a direct recursion, simply skip the duplicate; // entries. If this is mutual recursion, handling is left to; // the LTO link analysis client.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:79,Performance,load,loads,79,"// By now we processed all instructions in a function, except; // non-volatile loads and non-volatile value stores. Let's find; // ref edges for both of instruction sets",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:61,Performance,load,load,61,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:282,Performance,load,load,282,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:371,Performance,load,loads,371,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:57,Modifiability,variab,variable,57,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:11,Performance,load,load,11,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:90,Performance,optimiz,optimize,90,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:131,Performance,optimiz,optimized,131,"// Explicit add hot edges to enforce importing for designated GUIDs for; // sample PGO, to enable the same inlines as the profiled optimized binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:62,Usability,GUID,GUIDs,62,"// Explicit add hot edges to enforce importing for designated GUIDs for; // sample PGO, to enable the same inlines as the profiled optimized binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:10,Modifiability,refactor,refactor,10,// FIXME: refactor this to use the same code that inliner is using.; // Don't try to import functions with noinline attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:3,Security,Validat,Validate,3,// Validate that the VTableFuncs list is ordered by offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:14,Modifiability,variab,variables,14,// Don't mark variables we won't be able to internalize as read/write-only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:29,Modifiability,variab,variables,29,"// Compute summaries for all variables defined in module, and save in the; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:51,Availability,alive,alive,51,"// Iterate through ifuncs, set their resolvers all alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,Safety,safe,safety,35,// Iterate over header and compute safety info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:46,Safety,safe,safety,46,// Iterate over loop instructions and compute safety info.; // Skip header as it has been computed and stored in HeaderMayThrow.; // The first block in loopinfo.Blocks is guaranteed to be the header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:94,Integrability,rout,routine,94,// Compute funclet colors if we might sink/hoist in a function with a funclet; // personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:34,Energy Efficiency,power,powerful,34,"// todo: this would be a lot more powerful if we used scev, but all the; // plumbing is currently missing to pass a pointer in from the pass; // Check for cmp (phi [x, preheader] ...), y where (pred x, y is known",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:227,Testability,test,test,227,"// TODO: If BB lies in an inner loop of CurLoop, this will traverse over all; // blocks of this inner loop, even those that are always executed AFTER the; // BB. It may make our analysis more conservative than it could be, see test; // @nested and @nested_no_throw in test/Analysis/MustExecute/loop-header.ll.; // We can ignore backedge of all loops containing BB to get a sligtly more; // optimistic result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:268,Testability,test,test,268,"// TODO: If BB lies in an inner loop of CurLoop, this will traverse over all; // blocks of this inner loop, even those that are always executed AFTER the; // BB. It may make our analysis more conservative than it could be, see test; // @nested and @nested_no_throw in test/Analysis/MustExecute/loop-header.ll.; // We can ignore backedge of all loops containing BB to get a sligtly more; // optimistic result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:183,Energy Efficiency,power,power,183,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:25,Integrability,rout,routines,25,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:98,Performance,cache,cache,98,"// TODO: Actually try to prove it is not.; // TODO: If maybeEndlessLoop is going to be expensive, cache it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:110,Performance,perform,perform,110,"// Try to determine a join block through the help of the post-dominance; // tree. If no tree was provided, we perform simple pattern matching for one; // block conditionals and one block loops only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:118,Usability,simpl,simple,118,"// Try to determine a join block through the help of the post-dominance; // tree. If no tree was provided, we perform simple pattern matching for one; // block conditionals and one block loops only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:105,Performance,perform,perform,105,"// Try to determine a join block through the help of the dominance tree. If no; // tree was provided, we perform simple pattern matching for one block; // conditionals only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:113,Usability,simpl,simple,113,"// Try to determine a join block through the help of the dominance tree. If no; // tree was provided, we perform simple pattern matching for one block; // conditionals only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:211,Availability,avail,available,211,"// Multiple successors mean we need to find the join point where control flow; // converges again. We use the findForwardJoinPoint helper function with; // information about the function and helper analyses, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,Usability,simpl,simply,35,// We did not enter a callee so we simply return the previous instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:233,Availability,avail,available,233,"// Finally, we have to handle the case where the program point is the first in; // a block but not in the function. We use the findBackwardJoinPoint helper; // function with information about the function and helper analyses, if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp:458,Testability,log,logs,458,"//===- NoInferenceModelRunner.cpp - noop ML model runner ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pseudo model runner. We use it to store feature values when collecting; // logs for the default policy, in 'development' mode, but never ask it to; // 'run'.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:978,Integrability,depend,dependencies,978,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:489,Modifiability,enhance,enhance,489,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:1335,Modifiability,refactor,refactor,1335,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:43,Performance,Optimiz,Optimization,43,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:503,Performance,optimiz,optimization,503,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:411,Usability,simpl,simple,411,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:132,Deployability,update,updates,132,"// These functions don't access any memory visible to the compiler.; // Note that this doesn't include objc_retainBlock, because it updates; // pointers when it copies block data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:25,Security,access,access,25,"// These functions don't access any memory visible to the compiler.; // Note that this doesn't include objc_retainBlock, because it updates; // pointers when it copies block data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp:45,Performance,Optimiz,Optimizations,45,/// A handy option to enable/disable all ARC Optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:34,Performance,Optimiz,Optimization,34,"//===- ARCInstKind.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines several utility functions used by various ARC; /// optimizations which are IMHO too big to be in a header file.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:460,Performance,optimiz,optimizations,460,"//===- ARCInstKind.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines several utility functions used by various ARC; /// optimizations which are IMHO too big to be in a header file.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:62,Performance,optimiz,optimizer,62,// Ignore annotation calls. This is important to stop the; // optimizer from treating annotations as uses which would; // make the state of the pointers they are attempting to; // elucidate to be incorrect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:117,Safety,safe,safety,117,"// We are conservative and even though intrinsics are unlikely to touch; // reference counts, we white list them for safety.; //; // TODO: Expand this into a covered switch. There is a lot more here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:354,Deployability,release,release,354,"// Any instruction other than bitcast and gep with a pointer operand have a; // use of an objc pointer. Bitcasts, GEPs, Selects, PHIs transfer a pointer; // to a subsequent use, rather than using it themselves, in this sense.; // As a short cut, several other opcodes are known to have no pointer; // operands of interest. And ret is never followed by a release, so it's; // not interesting to examine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is a kind of user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is objc_retain or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is objc_autorelease or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which return their; /// argument verbatim.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:93,Modifiability,variab,variable,93,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:69,Safety,safe,safe,69,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:68,Safety,safe,safe,68,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:16,Safety,safe,safe,16,/// It is never safe to tail call objc_autorelease since by tail calling; /// objc_autorelease: fast autoreleasing causing our object to be potentially; /// reclaimed from the autorelease pool which violates the semantics of; /// __autoreleasing types in ARC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:69,Safety,safe,safe,69,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:159,Performance,optimiz,optimization,159,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.; ///; /// This means that it *could* interrupt the RV optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.; ///; /// This means that it *could* interrupt the RV optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:124,Deployability,release,releases,124,// The cases below are conservative.; // RetainBlock can result in user defined copy constructors being called; // implying releases may occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:407,Integrability,interface,interfaces,407,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:501,Integrability,depend,dependent,501,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:586,Integrability,message,message,586,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:7,Performance,Optimiz,OptimizationRemarkEmitter,7,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:39,Performance,Optimiz,Optimization,39,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:383,Performance,Optimiz,Optimization,383,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp:399,Integrability,rout,routines,399,"//==-- OverflowInstAnalysis.cpp - Utils to fold overflow insts ----*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse overflow instructions; // and fold them into constants or other overflow instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:89,Security,Validat,Validate,89,// If it isn't in the InstInputs list it is a subexpr incorporated into the; // address. Validate that it is phi translatable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Security,Validat,Validate,3,// Validate the operands of the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:135,Availability,error,errors,135,"/// verify - Check internal consistency of this data structure. If the; /// structure is valid, it returns true. If invalid, it prints errors and; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:157,Safety,avoid,avoid,157,"/// isPotentiallyPHITranslatable - If this needs PHI translation, return true; /// if we have some hope of doing it. This should be used as a filter to; /// avoid calling PHITranslateValue in hopeless situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:11,Availability,avail,available,11,// Find an available version of this cast.; // Try to simplify cast first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:54,Usability,simpl,simplify,54,// Find an available version of this cast.; // Try to simplify cast first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:79,Availability,avail,available,79,"// Otherwise we have to see if a casted version of the incoming pointer; // is available. If so, we can use it, otherwise we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the GEP to handle 'gep x, 0' -> x etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:35,Availability,avail,available,35,// Scan to see if we have this GEP available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:18,Usability,simpl,simplifies,18,// See if the add simplifies away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:9,Usability,simpl,simplified,9,"// If we simplified the operands, the LHS is no longer an input, but Res; // is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:38,Availability,avail,available,38,"// Otherwise, see if we have this add available somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:263,Availability,failure,failure,263,"/// PHITranslateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:248,Availability,failure,failure,248,/// insertTranslatedSubExpr - Insert a computation of the PHI translated; /// version of 'V' for the edge PredBB->CurBB into the end of the PredBB; /// block. All newly created instructions are added to the NewInsts list.; /// This returns null on failure.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:50,Availability,avail,available,50,"// See if we have a version of this value already available and dominating; // PredBB. If so, there is no need to insert a new instance of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:133,Availability,avail,available,133,"// FIXME: This code works, but it is unclear that we actually want to insert; // a big chain of computation in order to make a value available in a block.; // This needs to be evaluated carefully to consider its cost trade offs.; // PHI translate the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:24,Deployability,update,update,24,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:35,Performance,cache,cached,35,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:90,Usability,simpl,simpler,90,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:614,Energy Efficiency,reduce,reduce,614,"// The goal here is to find all of the non-phi values reachable from this phi,; // and to do the same for all of the phis reachable from this phi, as doing so; // is necessary anyway in order to get the values for this phi. We do this using; // Tarjan's algorithm with Nuutila's improvements to find the strongly connected; // components of the phi graph rooted in this phi:; // * All phis in a strongly connected component will have the same reachable; // non-phi values. The SCC may not be the maximal subgraph for that set of; // reachable values, but finding out that isn't really necessary (it would; // only reduce the amount of memory needed to store the values).; // * Tarjan's algorithm completes components in a bottom-up manner, i.e. it; // never completes a component before the components reachable from it have; // been completed. This means that when we complete a component we have; // everything we need to collect the values reachable from that component.; // * We collect both the non-phi values reachable from each SCC, as that's what; // we're ultimately interested in, and all of the reachable values, i.e.; // including phis, as that makes invalidateValue easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:108,Safety,predict,predictable,108,// Iterate through the phi nodes of the function rather than iterating through; // DepthMap in order to get predictable ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:423,Security,access,access,423,"//===- ProfileSummaryInfo.cpp - Global profile summary information --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that provides access to the global profile summary; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:239,Availability,avail,available,239,"// The profile summary metadata may be attached either by the frontend or by; // any backend passes (IR level instrumentation, for example). This method; // checks if the Summary is null and if so checks if the summary metadata is now; // available in the module and parses it to get the Summary object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:190,Availability,avail,available,190,"/// Returns true if the function's entry is a cold. If it returns false, it; /// either means it is not cold or it is unknown whether it is cold or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:36,Safety,detect,detection,36,"//===- RegionInfo.cpp - SESE region detection analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:379,Safety,Detect,Detects,379,"//===- RegionInfo.cpp - SESE region detection analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:445,Performance,optimiz,optimization,445,"//===- RegionPass.cpp - Region Pass and Region Pass Manager ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements RegionPass and RGPassManager. All region optimization; // and transformation passes are derived from RegionPass. RGPassManager is; // responsible for managing RegionPasses.; // Most of this code has been COPIED from LoopPass.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the function, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:11,Modifiability,inherit,inherited,11,// Collect inherited analysis from Module level pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:23,Performance,queue,queue,23,// Pop the region from queue after running all passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:196,Availability,avail,available,196,"//end anonymous namespace; //===----------------------------------------------------------------------===//; // RegionPass; // Check if this pass is suitable for the current RGPassManager, if; // available. This pass P is not suitable for a RGPassManager if P; // is not preserving higher level analysis info used by other; // RGPassManager passes. In such case, pop RGPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp:119,Usability,simpl,simple,119,//===----------------------------------------------------------------------===//; /// onlySimpleRegion - Show only the simple regions in the RegionViewer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp:68,Safety,safe,safely,68,"// The viewer and analysis passes do not modify anything, so we can safely; // remove the const qualifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:496,Performance,optimiz,optimization,496,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:516,Testability,log,log,516,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:567,Testability,test,testing,567,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2382,Energy Efficiency,Efficient,Efficient,2382,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1804,Integrability,rout,routines,1804,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1856,Integrability,depend,dependence,1856,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2518,Integrability,depend,dependence,2518,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:537,Modifiability,variab,variables,537,"//===- ScalarEvolution.cpp - Scalar Evolution Analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the scalar evolution analysis; // engine, which is used primarily to analyze expressions involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good referen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1518,Modifiability,rewrite,rewrite,1518," involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2555,Modifiability,variab,variable,2555,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2335,Performance,Optimiz,Optimization,2335,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2414,Performance,Optimiz,Optimizing,2414,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2529,Testability,test,testing,2529,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1535,Usability,simpl,simplify,1535," involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear this SCEVUnknown from various maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Release,Release,3,// Release the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear this SCEVUnknown from various maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:483,Integrability,rout,routine,483,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:783,Integrability,rout,routine,783,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,Performance,cache,cache,888,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:515,Safety,avoid,avoid,515,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Energy Efficiency,efficient,efficient,172,"// Return negative, zero, or positive, if LHS is less than, equal to, or greater; // than RHS, respectively. A three-way result allows recursive comparisons to be; // more efficient.; // If the max analysis depth was reached, return std::nullopt, assuming we do; // not know if they are equivalent for sure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Safety,safe,safely,89,"// There is always a dominance between two recs that are used by one SCEV,; // so we can safely sort recs by loop header dominance. We require such; // order in getAddExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:141,Integrability,rout,routine,141,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:389,Integrability,rout,routine,389,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:456,Integrability,depend,depend,456,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simple,63,"// This is the common case, which also happens to be trivially simple.; // Special case it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:244,Integrability,depend,depend,244,"// Now that we are sorted by complexity, group elements of the same; // complexity. Note that this is, at worst, N^2, but the vector is likely to; // be extremely short in practice. Note that we take this approach because we; // do not want to depend on the addresses of the objects we are grouping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:85,Usability,Simpl,Simple,85,"//===----------------------------------------------------------------------===//; // Simple SCEV method implementations; //===----------------------------------------------------------------------===//; /// Compute BC(It, K). The result has width W. Assume, K > 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Energy Efficiency,efficient,efficiently,28,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,simpl,simplest,14,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:827,Energy Efficiency,efficient,efficiently,827,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1619,Energy Efficiency,efficient,efficient,1619,"ation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Prote",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2219,Energy Efficiency,efficient,efficient,2219,"/ This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Protection from insane SCEVs; this bound is conservative,; // but it probably doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2084,Modifiability,variab,variable,2084,"/ This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Protection from insane SCEVs; this bound is conservative,; // but it probably doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1336,Performance,perform,perform,1336," However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,Safety,safe,safe,345,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:920,Safety,safe,safe,920,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1128,Safety,safe,safely,1128,"pose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certai",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:113,Safety,avoid,avoid,113,// Calculate K! / 2^T and T; we divide out the factors of two before; // multiplying for calculating K! / 2^T to avoid overflow.; // Other overflow doesn't matter because we only care about the bottom; // W bits of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Performance,perform,perform,89,// Calculate the multiplicative inverse of K! / 2^T;; // this multiplication factor will perform the exact division by; // K! / 2^T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Performance,perform,performed,94,// The computation is correct in the face of overflow provided that the; // multiplication is performed _after_ the evaluation of the binomial; // coefficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Modifiability,rewrite,rewrites,65,"// We could be called with an integer-typed operands during SCEV rewrites.; // Since the operand is an integer already, just perform zext/trunc/self cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:125,Performance,perform,perform,125,"// We could be called with an integer-typed operands during SCEV rewrites.; // Since the operand is an integer already, just perform zext/trunc/self cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Performance,optimiz,optimizations,22,// It isn't legal for optimizations to construct new ptrtoint expressions; // for non-integral pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Energy Efficiency,reduce,reduce,49,"// If not, is this expression something we can't reduce any further?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Perform,Perform,3,"// Perform some basic constant folding. If the operand of the ptr2int cast; // is a null pointer, don't create a ptr2int SCEV expression (that will be; // left as-is), but produce a zero constant.; // NOTE: We could handle a more general case, but lack motivational cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:309,Availability,down,down,309,"// Otherwise, we've got some expression that is more complex than just a; // single SCEVUnknown. But we don't want to have a SCEVPtrToIntExpr of an; // arbitrary expression, we want to have SCEVPtrToIntExpr of an SCEVUnknown; // only, and the expressions must otherwise be integer-typed.; // So sink the cast down to the SCEVUnknown's.; /// The SCEVPtrToIntSinkingRewriter takes a scalar evolution expression,; /// which computes a pointer-typed value, and rewrites the whole expression; /// tree so that *all* the computations are done on integers, and the only; /// pointer-typed operands in the expression are SCEVUnknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:457,Modifiability,rewrite,rewrites,457,"// Otherwise, we've got some expression that is more complex than just a; // single SCEVUnknown. But we don't want to have a SCEVPtrToIntExpr of an; // arbitrary expression, we want to have SCEVPtrToIntExpr of an SCEVUnknown; // only, and the expressions must otherwise be integer-typed.; // So sink the cast down to the SCEVUnknown's.; /// The SCEVPtrToIntSinkingRewriter takes a scalar evolution expression,; /// which computes a pointer-typed value, and rewrites the whole expression; /// tree so that *all* the computations are done on integers, and the only; /// pointer-typed operands in the expression are SCEVUnknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Availability,down,down,35,"// Else, recursively sink the cast down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Performance,perform,perform,16,// And actually perform the cast sinking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Performance,cache,cache,62,"// Although we checked in the beginning that ID is not in the cache, it is; // possible that during recursion and different modification ID was inserted; // into the cache. So if we find it, just return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:166,Performance,cache,cache,166,"// Although we checked in the beginning that ID is not in the cache, it is; // possible that during recursion and different modification ID was inserted; // into the cache. So if we find it, just return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Integrability,Wrap,WrapType,59,"// Members present:; //; // static const SCEV::NoWrapFlags WrapType;; //; // static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;; //; // static const SCEV *getOverflowLimitForStep(const SCEV *Step,; // ICmpInst::Predicate *Pred,; // ScalarEvolution *SE);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:90,Modifiability,Extend,ExtendOpTraitsBase,90,"// Members present:; //; // static const SCEV::NoWrapFlags WrapType;; //; // static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;; //; // static const SCEV *getOverflowLimitForStep(const SCEV *Step,; // ICmpInst::Predicate *Pred,; // ScalarEvolution *SE);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,Integrability,wrap,wrap,91,"// end anonymous namespace; // The recurrence AR has been shown to have no signed/unsigned wrap or something; // close to it. Typically, if we can prove NSW/NUW for AR, then we can just as; // easily prove NSW/NUW for its preincrement or postincrement sibling. This; // allows normalizing a sign/zero extended AddRec as such: {sext/zext(Step +; // Start),+,Step} => {(Step + sext/zext(Start),+,Step} As a result, the; // expression ""Step + sext/zext(PreIncAR)"" is congruent with; // ""sext/zext(PostIncAR)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:301,Modifiability,extend,extended,301,"// end anonymous namespace; // The recurrence AR has been shown to have no signed/unsigned wrap or something; // close to it. Typically, if we can prove NSW/NUW for AR, then we can just as; // easily prove NSW/NUW for its preincrement or postincrement sibling. This; // allows normalizing a sign/zero extended AddRec as such: {sext/zext(Step +; // Start),+,Step} => {(Step + sext/zext(Start),+,Step} As a result, the; // expression ""Step + sext/zext(PreIncAR)"" is congruent with; // ""sext/zext(PostIncAR)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Usability,simpl,simple,15,// Check for a simple looking step prior to loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:118,Performance,perform,perform,118,"// Create an AddExpr for ""PreStart"" after subtracting Step. Full SCEV; // subtraction is expensive. For this purpose, perform a quick and dirty; // difference, by checking for Step in the operand list. Note, that; // SA might have repeated ops, like %a + %a + ..., so only remove one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:17,Integrability,Wrap,WrapType,17,// Try to prove `WrapType` (SCEV::FlagNSW or SCEV::FlagNUW) on `PreStart` +; // `Step`:; // 1. NSW/NUW flags on the step increment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:55,Integrability,Wrap,WrapType,55,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:123,Integrability,Wrap,WrapType,123,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:189,Integrability,Wrap,WrapType,189,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:200,Performance,Cache,Cache,200,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Modifiability,extend,extended,35,// Get the normalized zero or sign extended expression for this AddRec's Start.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Integrability,wrap,wrap,172,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1086,Modifiability,Extend,ExtendOpTy,1086,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,Usability,simpl,simply,888,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,wrap,wrap,136,"// Finds an integer D for an expression (C + x + y + ...) such that the top; // level addition in (D + (C - D + x + y + ...)) would not wrap (signed or; // unsigned) and the number of trailing zeros of (C - D + x + y + ...) is; // maximized, where C is the \p ConstantTerm, x, y, ... are arbitrary SCEVs, and; // the (C + x + y + ...) expression is \p WholeAddExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Integrability,wrap,wrap,145,// Set D to be as many least significant bits of C as possible while still; // guaranteeing that adding D to (C - D + x + y + ...) won't cause a wrap:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Integrability,wrap,wrap,128,"// Finds an integer D for an affine AddRec expression {C,+,x} such that the top; // level addition in (D + {C-D,+,x}) would not wrap (signed or unsigned) and the; // number of trailing zeros of (C - D + x * n) is maximized, where C is the \p; // ConstantStart, x is an arbitrary \p Step, and n is the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Usability,simpl,simplify,104,"// It's possible the bits taken off by the truncate were all zero bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Modifiability,extend,extend,129,"// If the input value is a chrec scev, and we can prove that the value; // did not overflow the old, smaller, value, we can zero extend all of the; // operands (often constants). This allows analysis of something like; // this: for (unsigned char X = 0; X < 100; ++X) { int Y = X; }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NUW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:101,Availability,down,down,101,"// Similar to above, only this time treat the step value as signed.; // This covers loops that count down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:99,Integrability,wrap,wrap,99,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Integrability,wrap,wrap,129,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Safety,avoid,avoid,47,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,Usability,clear,clear,88,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:31,Modifiability,extend,extend,31,"// For a negative step, we can extend the operands iff doing so only; // traverses values in the range zext([0,UINT_MAX]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:99,Integrability,wrap,wrap,99,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:133,Integrability,wrap,wrap,133,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:127,Integrability,wrap,wrap,127,"// zext({C,+,Step}) --> (zext(D) + zext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:134,Integrability,wrap,wrap,134,"// zext(C + x + y + ...) --> (zext(D) + zext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // Often address arithmetics contain expressions like; // (zext (add (shl X, C1), C2)), for instance, (zext (5 + (4 * X))).; // This transformation is useful while proving that such expressions are; // equal or differ by a small constant amount, see LoadStoreVectorizer pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:470,Performance,Load,LoadStoreVectorizer,470,"// zext(C + x + y + ...) --> (zext(D) + zext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // Often address arithmetics contain expressions like; // (zext (add (shl X, C1), C2)), for instance, (zext (5 + (4 * X))).; // This transformation is useful while proving that such expressions are; // equal or differ by a small constant amount, see LoadStoreVectorizer pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Usability,simpl,simplify,104,"// It's possible the bits taken off by the truncate were all sign bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:132,Integrability,wrap,wrap,132,"// sext(C + x + y + ...) --> (sext(D) + sext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // For instance, this will bring two seemingly different expressions:; // 1 + sext(5 + 20 * %x + 24 * %y) and; // sext(6 + 20 * %x + 24 * %y); // to the same form:; // 2 + sext(4 + 20 * %x + 24 * %y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Modifiability,extend,extend,129,"// If the input value is a chrec scev, and we can prove that the value; // did not overflow the old, smaller, value, we can sign extend all of the; // operands (often constants). This allows analysis of something like; // this: for (signed char X = 0; X < 100; ++X) { int Y = X; }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NSW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Integrability,wrap,wraps,9,// If AR wraps around then; //; // abs(Step) * MaxBECount > unsigned-max(AR->getType()); // => SAdd != OperandExtendedAdd; //; // Thus (AR is not NW => SAdd != OperandExtendedAdd) <=>; // (SAdd == OperandExtendedAdd => AR is NW),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Safety,avoid,avoid,47,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,Usability,clear,clear,88,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:125,Integrability,wrap,wrap,125,"// sext({C,+,Step}) --> (sext(D) + sext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:60,Usability,simpl,simplify,60,// If the input value is provably positive and we could not simplify; // away the sext build a zext instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Modifiability,extend,extended,59,/// getAnyExtendExpr - Return a SCEV for the given operand extended with; /// unspecified bits out to the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Modifiability,extend,extend,8,// Sign-extend negative constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:100,Deployability,update,update,100,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:394,Deployability,update,update,394,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1031,Safety,avoid,avoid,1031,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:691,Security,expose,exposes,691,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:864,Security,expose,exposed,864,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Deployability,Update,Update,57,// A multiplication of a constant with some other value. Update; // the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Deployability,Update,Update,24,// An ordinary operand. Update the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Availability,down,down,21,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,"// To avoid overflow up, we need to make sure that LHS <= MAX - Magnitude.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Integrability,wrap,wrap,102,// We're trying to construct a SCEV of type `Type' with `Ops' as operands and; // `OldFlags' as can't-wrap behavior. Infer a more aggressive set of; // can't-overflow flags for the operation if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Usability,simpl,simpler,49,"/// Get a canonical add expression, or something simpler if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:289,Usability,simpl,simple,289,"// Check for truncates. If all the operands are truncated from the same; // type, see if factoring out the truncate would permit the result to be; // folded. eg., n*trunc(x) + m*trunc(y) --> trunc(trunc(m)*x + trunc(n)*y); // if the contents of the resulting outer trunc fold to something simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Usability,simpl,simple,28,"// If it folds to something simple, use it. Otherwise, don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Integrability,wrap,wrapping,128,"// Check if we have an expression of the form ((X + C1) - C2), where C1 and; // C2 can be folded in a way that allows retaining wrapping flags of (X +; // C1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:176,Integrability,depend,depend,176,"// If the original flags and all inlined SCEVAddExprs are NUW, use the; // common NUW flag for expression after inlining. Other flags cannot be; // preserved, because they may depend on the original order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:153,Safety,avoid,avoid,153,"// Some interesting folding opportunity is present, so its worthwhile to; // re-generate the operands list. Group the operands by constant scale,; // to avoid multiplying by the same constant scale multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Safety,safe,safe,24,"// It is not in general safe to propagate flags valid on an add within; // the addrec scope to one outside it. We must prove that the inner; // scope is guaranteed to execute if the outer one does to be able to; // safely propagate. We know the program is undefined if poison is; // produced on the inner scoped addrec. We also know that *for this use*; // the outer scoped add can't overflow (because of the flags we just; // computed for the inner scoped add) without the program being undefined.; // Proving that entry to the outer scope neccesitates entry to the inner; // scope, thus proves the program undefined if the flags would be violated; // in the outer scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Safety,safe,safely,215,"// It is not in general safe to propagate flags valid on an add within; // the addrec scope to one outside it. We must prove that the inner; // scope is guaranteed to execute if the outer one does to be able to; // safely propagate. We know the program is undefined if poison is; // produced on the inner scoped addrec. We also know that *for this use*; // the outer scoped add can't overflow (because of the flags we just; // computed for the inner scoped add) without the program being undefined.; // Proving that entry to the outer scope neccesitates entry to the inner; // scope, thus proves the program undefined if the flags would be violated; // in the outer scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Modifiability,variab,variable,137,"// Okay, if there weren't any loop invariants to be folded, check to see if; // there are multiple AddRec's with the same loop induction variable being; // added together. If so, we can fold them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Integrability,wrap,wraparound,57,"// Step size has changed, so we cannot guarantee no self-wraparound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:187,Usability,clear,cleared,187,"/// Compute the result of ""n choose k"", the binomial coefficient. If an; /// intermediate computation overflows, Overflow will be set and the return will; /// be garbage. Overflow is not cleared on absence of overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:269,Energy Efficiency,reduce,reduce,269,"// We use the multiplicative formula:; // n(n-1)(n-2)...(n-(k-1)) / k(k-1)(k-2)...1 .; // At each iteration, we take the n-th term of the numeral and divide by the; // (k-n)th term of the denominator. This division will always produce an; // integral result, and helps reduce the chance of overflow in the; // intermediate computations. However, we can still overflow even when the; // final result would fit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:54,Usability,simpl,simpler,54,"/// Get a canonical multiply expression, or something simpler if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:279,Availability,down,down,279,"// If any of Add's ops are Adds or Muls with a constant, apply this; // transformation as well.; //; // TODO: There are some cases where this transformation is not; // profitable; for example, Add = (C0 + X) * Y + Z. Maybe the scope of; // this transformation should be narrowed down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:45,Integrability,wrap,wrap,45,// Negation preserves a recurrence's no self-wrap property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Modifiability,variab,variable,137,"// Okay, if there weren't any loop invariants to be folded, check to see; // if there are multiple AddRec's with the same loop induction variable; // being multiplied together. If so, we can fold them.; // {A1,+,A2,+,...,+,An}<L> * {B1,+,B2,+,...,+,Bn}<L>; // = {x=1 in [ sum y=x..2x [ sum z=max(y-x, y-n)..min(x,n) [; // choose(x, 2x)*choose(2x-y, x-z)*A_{y-z}*B_z; // ]]],+,...up to x=2n}.; // Note that the arguments to choose() are always integers with values; // known at compile time, never SCEV objects.; //; // The implementation avoids pointless extra computations when the two; // addrec's are of different length (mathematically, it's equivalent to; // an infinite stream of zeros on the right).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:538,Safety,avoid,avoids,538,"// Okay, if there weren't any loop invariants to be folded, check to see; // if there are multiple AddRec's with the same loop induction variable; // being multiplied together. If so, we can fold them.; // {A1,+,A2,+,...,+,An}<L> * {B1,+,B2,+,...,+,Bn}<L>; // = {x=1 in [ sum y=x..2x [ sum z=max(y-x, y-n)..min(x,n) [; // choose(x, 2x)*choose(2x-y, x-z)*A_{y-z}*B_z; // ]]],+,...up to x=2n}.; // Note that the arguments to choose() are always integers with values; // known at compile time, never SCEV objects.; //; // The implementation avoids pointless extra computations when the two; // addrec's are of different length (mathematically, it's equivalent to; // an infinite stream of zeros on the right).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:36,Safety,avoid,avoid,36,// Limit max number of arguments to avoid creation of unreasonably big; // SCEVAddRecs with very complex operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:39,Energy Efficiency,power,power,39,"// X urem 1 --> 0; // If constant is a power of two, fold into a zext(trunc(LHS)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simpler,63,"/// Get a canonical unsigned division expression, or something simpler if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Energy Efficiency,power,power-of-two,11,"// For non-power-of-two values, effectively round the value up to the; // nearest power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:82,Energy Efficiency,power,power,82,"// For non-power-of-two values, effectively round the value up to the; // nearest power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:32,Safety,safe,safe,32,"// {X,+,N}/C --> {X/C,+,N/C} if safe and N/C can be folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:92,Safety,Safe,Safe,92,"/// Get a canonical UDivExpr for a recurrence.; /// {X,+,N}/C => {Y,+,N}/C where Y=X-(X%N). Safe when C%N=0.; // We can currently only fold X%N if X is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:71,Performance,cache,cached,71,"// Reset the ID to include the new LHS, and check if it is; // already cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safe,26,// (A*B)/C --> A*(B/C) if safe and B/C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safely,26,// Find an operand that's safely divisible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Deployability,A/B,A/B,4,// (A/B)/C --> A/(B*C) if safe and B*C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safe,26,// (A/B)/C --> A/(B*C) if safe and B*C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:30,Safety,safe,safe,30,// (A+B)/C --> (A/C + B/C) if safe and A/C and B/C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simpler,63,"/// Get a canonical unsigned division expression, or something simpler if; /// possible. There is no representation for an exact udiv in SCEV IR, but we; /// can attempt to remove factors from the LHS and RHS. We can't do this when; /// it's not exact because the udiv may be clearing bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:276,Usability,clear,clearing,276,"/// Get a canonical unsigned division expression, or something simpler if; /// possible. There is no representation for an exact udiv in SCEV IR, but we; /// can attempt to remove factors from the LHS and RHS. We can't do this when; /// it's not exact because the udiv may be clearing bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Usability,Simpl,Simplify,61,/// Get an add recurrence expression for the specified loop. Simplify the; /// expression as much as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Usability,Simpl,Simplify,61,/// Get an add recurrence expression for the specified loop. Simplify the; /// expression as much as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:333,Performance,cache,cached,333,"// It's tempting to want to call getConstantMaxBackedgeTakenCount count here and; // use that information to infer NUW and NSW flags. However, computing a; // BE count requires calling getAddRecExpr, so we may not yet have a; // meaningful BE count at this point (and if we don't, we'd be stuck; // with a SCEVCouldNotCompute as the cached BE count).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,Performance,perform,perform,91,// AddRecs require their operands be loop-invariant with respect to their; // loops. Don't perform this transformation if it would break this; // requirement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update CurTy to the type of the field at Index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update CurTy to its element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Usability,simpl,simplify,129,"// Check to see if one of the operands is of the same kind. If so, expand its; // operands onto our operand list, and recurse to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Safety,safe,safe,52,"// If the instruction cannot be poison, it's always safe to reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking large instruction graphs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:27,Usability,simpl,simplifications,27,// FIXME: there are *some* simplifications that we can do here.; // Keep only the first instance of an operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Usability,simpl,simplify,129,"// Check to see if one of the operands is of the same kind. If so, expand its; // operands onto our operand list, and recurse to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:148,Performance,optimiz,optimization,148,// We can bypass creating a target-independent constant expression and then; // folding it back into a ConstantInt. This is just a compile-time; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:346,Security,access,access,346,"//===----------------------------------------------------------------------===//; // Basic SCEV Analysis and PHI Idiom Recognition Code; //; /// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Testability,Test,Test,145,"//===----------------------------------------------------------------------===//; // Basic SCEV Analysis and PHI Idiom Recognition Code; //; /// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:105,Testability,assert,assertion,105,"// If we subtract two pointers with different pointer bases, bail.; // Eventually, we're going to add an assertion to getMulExpr that we; // can't multiply by a pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:77,Integrability,wrap,wraps,77,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:182,Integrability,wrap,wraps,182,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:388,Integrability,wrap,wrap,388,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:442,Integrability,wrap,wrap,442,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Modifiability,Extend,Extend,3,// Extend all ops to max type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:205,Modifiability,rewrite,rewrite,205,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its start; /// expression in case its Loop is L. If it is not L then; /// if IgnoreOtherLoops is true then use AddRec itself; /// otherwise rewrite cannot be done.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:278,Modifiability,rewrite,rewrite,278,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its start; /// expression in case its Loop is L. If it is not L then; /// if IgnoreOtherLoops is true then use AddRec itself; /// otherwise rewrite cannot be done.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:216,Modifiability,rewrite,rewrite,216,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its post; /// increment expression in case its Loop is L. If it is not L then; /// use AddRec itself.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Safety,safe,safe,87,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:251,Safety,safe,safe,251,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Safety,safe,safe,87,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:251,Safety,safe,safe,251,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:95,Availability,failure,failure,95,"// end anonymous namespace; /// Try to map \p V into a BinaryOp, and return \c std::nullopt on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Safety,avoid,avoid,137,"// Implementation detail: all the cleverness here should happen without; // creating new SCEV expressions -- our caller knowns tricks to avoid creating; // SCEV expressions when possible, and we should not break that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Testability,log,logical,8,// Turn logical shift right of a constant into a unsigned divide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:135,Deployability,update,updated,135,"/// Helper function to createAddRecFromPHIWithCasts. We have a phi; /// node whose symbolic (unknown) SCEV is \p SymbolicPHI, which is updated via; /// the loop backedge by a SCEVAddExpr, possibly also with a few casts on the; /// way. This function checks if \p Op, an operand of this SCEVAddExpr,; /// follows one of the following patterns:; /// Op == (SExt ix (Trunc iy (%SymbolicPHI) to ix) to iy); /// Op == (ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy); /// If the SCEV expression of \p Op conforms with one of the expected patterns; /// we return the type of the truncation operation, and indicate whether the; /// truncated type should be treated as signed/unsigned by setting; /// \p Signed to true/false, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Testability,log,logic,137,"// The case where Op == SymbolicPHI (that is, with no type conversions on; // the way) is handled by the regular add recurrence creating logic and; // would have already been triggered in createAddRecForPHI. Reaching it here; // means that createAddRecFromPHI had failed for this PHI before (e.g.,; // because one of the other operands of the SCEVAddExpr updating this PHI is; // not invariant).; //; // Here we look for the case where Op = (ext(trunc(SymbolicPHI))), and in; // this case predicates that allow us to prove that Op == SymbolicPHI will; // be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2095,Availability,redundant,redundant,2095,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:98,Deployability,update,updates,98,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:277,Deployability,update,update,277,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2367,Deployability,update,update,2367,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2547,Deployability,update,update,2547,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2699,Deployability,update,update,2699,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1159,Integrability,Wrap,WrapPred,1159,"lowing pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:506,Modifiability,Rewrite,Rewriter,506,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1503,Modifiability,rewrite,rewrite,1503,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1641,Modifiability,Extend,Extend,1641,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:423,Performance,cache,cache,423,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1519,Performance,cache,cached,1519,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2034,Safety,avoid,avoid,2034,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2095,Safety,redund,redundant,2095,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2772,Safety,avoid,avoid,2772,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:211,Modifiability,variab,variable,211,"// If the value coming around the backedge is an add with the symbolic; // value we just inserted, possibly with casts that we can ignore under; // an appropriate runtime guard, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Usability,simpl,simple,194,"// If the value coming around the backedge is an add with the symbolic; // value we just inserted, possibly with casts that we can ignore under; // an appropriate runtime guard, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Integrability,Wrap,Wrap,192,"// *** Part2: Create the predicates; // Analysis was successful: we have a phi-with-cast pattern for which we; // can return an AddRec expression under the following predicates:; //; // P1: A Wrap predicate that guarantees that Trunc(Start) + i*Trunc(Accum); // fits within the truncated type (does not overflow) for i = 0 to n-1.; // P2: An Equal predicate that guarantees that; // Start = (Ext ix (Trunc iy (Start) to ix) to iy); // P3: An Equal predicate that guarantees that; // Accum = (Ext ix (Trunc iy (Accum) to ix) to iy); //; // As we next prove, the above predicates guarantee that:; // Start + i*Accum = (Ext ix (Trunc iy ( Start + i*Accum ) to ix) to iy); //; //; // More formally, we want to prove that:; // Expr(i+1) = Start + (i+1) * Accum; // = (Ext ix (Trunc iy (Expr(i)) to ix) to iy) + Accum; //; // Given that:; // 1) Expr(0) = Start; // 2) Expr(1) = Start + Accum; // = (Ext ix (Trunc iy (Start) to ix) to iy) + Accum :: from P2; // 3) Induction hypothesis (step i):; // Expr(i) = (Ext ix (Trunc iy (Expr(i-1)) to ix) to iy) + Accum; //; // Proof:; // Expr(i+1) =; // = Start + (i+1)*Accum; // = (Start + i*Accum) + Accum; // = Expr(i) + Accum; // = (Ext ix (Trunc iy (Expr(i-1)) to ix) to iy) + Accum + Accum; // :: from step i; //; // = (Ext ix (Trunc iy (Start + (i-1)*Accum) to ix) to iy) + Accum + Accum; //; // = (Ext ix (Trunc iy (Start + (i-1)*Accum) to ix) to iy); // + (Ext ix (Trunc iy (Accum) to ix) to iy); // + Accum :: from P3; //; // = (Ext ix (Trunc iy ((Start + (i-1)*Accum) + Accum) to ix) to iy); // + Accum :: from P1: Ext(x)+Ext(y)=>Ext(x+y); //; // = (Ext ix (Trunc iy (Start + i*Accum) to ix) to iy) + Accum; // = (Ext ix (Trunc iy (Expr(i)) to ix) to iy) + Accum; //; // By induction, the same applies to all iterations 1<=i<n:; //; // Create a truncated addrec for which we will add a no overflow check (P1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:282,Modifiability,extend,extended,282,"// Create the Equal Predicates P2,P3:; // It is possible that the predicates P2 and/or P3 are computable at; // compile time due to StartVal and/or Accum being constants.; // If either one is, then we can check that now and escape if either P2; // or P3 is false.; // Construct the extended SCEV: (Ext ix (Trunc iy (Expr) to ix) to iy); // for each of StartVal and Accum",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Modifiability,Extend,ExtendedExpr,14,// Given:; // ExtendedExpr = (Ext ix (Trunc iy (Expr) to ix) to iy; // = getExtendedExpr(Expr); // Determine whether the predicate P: Expr == ExtendedExpr; // is known to be false at compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Modifiability,Extend,ExtendedExpr,142,// Given:; // ExtendedExpr = (Ext ix (Trunc iy (Expr) to ix) to iy; // = getExtendedExpr(Expr); // Determine whether the predicate P: Expr == ExtendedExpr; // is known to be false at compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:135,Modifiability,rewrite,rewrite,135,// *** Part3: Predicates are ready. Now go ahead and create the new addrec in; // which the casts had been folded away. The caller can rewrite SymbolicPHI; // into NewAR if it will also add the runtime overflow checks specified in; // Predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:17,Performance,cache,cache,17,// Record in the cache that the analysis failed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Modifiability,Rewrite,Rewriter,57,"// FIXME: This utility is currently required because the Rewriter currently; // does not rewrite this expression:; // {0, +, (sext ix (trunc iy to ix) to iy)}; // into {0, +, %step},; // even when the following Equal predicate exists:; // ""%step == (sext ix (trunc iy to ix) to iy)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Modifiability,rewrite,rewrite,89,"// FIXME: This utility is currently required because the Rewriter currently; // does not rewrite this expression:; // {0, +, (sext ix (trunc iy to ix) to iy)}; // into {0, +, %step},; // even when the following Equal predicate exists:; // ""%step == (sext ix (trunc iy to ix) to iy)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:56,Usability,simpl,simple,56,"/// A helper function for createAddRecFromPHI to handle simple cases.; ///; /// This function tries to find an AddRec expression for the simplest (yet most; /// common) cases: PN = PHI(Start, OP(Self, LoopInvariant)).; /// If it fails, createAddRecFromPHI will use a more general, but slow,; /// technique for finding the AddRec expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Usability,simpl,simplest,137,"/// A helper function for createAddRecFromPHI to handle simple cases.; ///; /// This function tries to find an AddRec expression for the simplest (yet most; /// common) cases: PN = PHI(Start, OP(Self, LoopInvariant)).; /// If it fails, createAddRecFromPHI will use a more general, but slow,; /// technique for finding the AddRec expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:264,Modifiability,variab,variable,264,"// NOTE: If BEValue is loop invariant, we know that the PHI node just; // has a special value for the first iteration of the loop.; // If the value coming around the backedge is an add with the symbolic; // value we just inserted, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:247,Usability,simpl,simple,247,"// NOTE: If BEValue is loop invariant, we know that the PHI node just; // has a special value for the first iteration of the loop.; // If the value coming around the backedge is an add with the symbolic; // value we just inserted, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:85,Integrability,wrap,wrapped,85,"// If the increment is an inbounds GEP, then we know the address; // space cannot be wrapped around. We cannot make any guarantee; // about signed or unsigned overflow because pointers are; // unsigned but we may have a negative index from the base; // pointer. We can guarantee that no unsigned wrap occurs if the; // indices form a positive value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:296,Integrability,wrap,wrap,296,"// If the increment is an inbounds GEP, then we know the address; // space cannot be wrapped around. We cannot make any guarantee; // about signed or unsigned overflow because pointers are; // unsigned but we may have a negative index from the base; // pointer. We can guarantee that no unsigned wrap occurs if the; // indices form a positive value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Usability,simpl,simpler,194,// Remove the temporary PHI node SCEV that has been inserted while intending; // to create an AddRecExpr for this PHI node. We can not keep this temporary; // as it will prevent later (possibly simpler) SCEV expressions to be added; // to the ValueExprMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Usability,simpl,simple,21,// Try to match some simple smax or umax patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:341,Modifiability,variab,variable,341,"// i1 cond ? i1 x : i1 C --> C + (i1 cond ? (i1 x - i1 C) : i1 0); // --> C + (umin_seq cond, x - C); //; // i1 cond ? i1 C : i1 x --> C + (i1 cond ? i1 0 : (i1 x - i1 C)); // --> C + (i1 ~cond ? (i1 x - i1 C) : i1 0); // --> C + (umin_seq ~cond, x - C); // FIXME: while we can't legally model the case where both of the hands; // are fully variable, we only require that the *difference* is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:29,Energy Efficiency,power,power,29,// Only multiples that are a power of 2 will hold after truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,Integrability,wrap,wrap,19,"// If there are no wrap guarentees, find the trailing zeros, which is the; // sum of trailing zeros for all its operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:131,Availability,avail,available,131,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Usability,simpl,simple,11,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Availability,avail,available,108,"// Make sure that no Phi input comes from an unreachable block. Otherwise,; // even the values that are not available in these blocks may come from them,; // and this leads to false-positive recurrence test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:202,Testability,test,test,202,"// Make sure that no Phi input comes from an unreachable block. Otherwise,; // even the values that are not available in these blocks may come from them,; // and this leads to false-positive recurrence test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:93,Security,expose,exposes,93,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Testability,assert,assert,35,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:60,Testability,assert,asserting,60,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Modifiability,Extend,Extend,9,"// TODO: Extend to other opcodes such as mul, and div",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:20,Energy Efficiency,power,power,20,// TODO: Handle the power function forms some day.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Usability,simpl,simply,22,// Analogous to lshr (simply not yet canonicalized),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Integrability,wrap,wrap,26,"// If there's no unsigned wrap, the value will never be less than its; // initial value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Integrability,wrap,wrap,24,"// If there's no signed wrap, and all the operands except initial value have; // the same sign or zero, the value won't ever be:; // 1: smaller than initial value if operands are non negative,; // 2: bigger than initial value if operands are non positive.; // For both cases, value can not cross signed min/max boundary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Energy Efficiency,power,powerful,38,// Now try symbolic BE count and more powerful methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Integrability,wrap,wrap-around,192,// This is correct even for INT_SMIN. Let's look at i8 to illustrate this:; // abs(INT_SMIN) = abs(-128) = abs(0x80) = -0x80 = 0x80 = 128.; // This equations hold true due to the well-defined wrap-around behavior of; // APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:97,Integrability,wrap,wrap,97,"// It's possible that the new minimum/maximum value will fall into the initial; // range (due to wrap around). This means that the expression can take any; // value in this bitwidth, and we have to return full range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Safety,detect,detected,15,"// No overflow detected, return [StartLower, StartUpper + Offset + 1) range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Integrability,wrap,wrap,57,"// Let's make sure that we can prove that we do not self-wrap during; // MaxBECount iterations. We need this because MaxBECount is a maximum; // iteration count estimate, and we might infer nw from some exit for which we; // do not know max exit count (or any other side reasoning).; // TODO: Turn into assert at some point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:303,Testability,assert,assert,303,"// Let's make sure that we can prove that we do not self-wrap during; // MaxBECount iterations. We need this because MaxBECount is a maximum; // iteration count estimate, and we might infer nw from some exit for which we; // do not know max exit count (or any other side reasoning).; // TODO: Turn into assert at some point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,Integrability,wrap,wrap,33,"// We know that there is no self-wrap. Let's take Start and End values and; // look at all intermediate values V1, V2, ..., Vn that IndVar takes during; // the iteration. They either lie inside the range [Min(Start, End),; // Max(Start, End)] or outside it:; //; // Case 1: RangeMin ... Start V1 ... VN End ... RangeMax;; // Case 2: RangeMin Vk ... V1 Start ... End Vn ... Vk + 1 RangeMax;; //; // No self wrap flag guarantees that the intermediate values cannot be BOTH; // outside and inside the range [Min(Start, End), Max(Start, End)]. Using that; // knowledge, let's try to prove that we are dealing with Case 1. It is so if; // Start <= End and step is positive, or Start >= End and step is negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:406,Integrability,wrap,wrap,406,"// We know that there is no self-wrap. Let's take Start and End values and; // look at all intermediate values V1, V2, ..., Vn that IndVar takes during; // the iteration. They either lie inside the range [Min(Start, End),; // Max(Start, End)] or outside it:; //; // Case 1: RangeMin ... Start V1 ... VN End ... RangeMax;; // Case 2: RangeMin Vk ... V1 Start ... End Vn ... Vk + 1 RangeMax;; //; // No self wrap flag guarantees that the intermediate values cannot be BOTH; // outside and inside the range [Min(Start, End), Max(Start, End)]. Using that; // knowledge, let's try to prove that we are dealing with Case 1. It is so if; // Start <= End and step is positive, or Start >= End and step is negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Integrability,wrap,wrap,37,// Only deal with ranges that do not wrap (i.e. RangeMin < RangeMax).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:342,Availability,error,errors,342,"// NB! Calling ScalarEvolution::getConstant is fine, but we should not try to; // construct arbitrary general SCEV expressions here. This function is called; // from deep in the call stack, and calling getSCEV (on a sext instruction,; // say) can end up caching a suboptimal value.; // FIXME: without the explicit `this` receiver below, MSVC errors out with; // C2352 and C2512 (otherwise it isn't needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Integrability,wrap,wrap,65,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:204,Integrability,wrap,wrap,204,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:330,Integrability,wrap,wrapping,330,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Queue,Queue,3,"// Queue CurV for SCEV creation, followed by its's operands which need to; // be constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Integrability,depend,depends,215,"// Don't attempt to analyze instructions in blocks that aren't; // reachable. Such instructions don't matter, and they aren't required; // to obey basic rules for definitions dominating uses which this; // analysis depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:120,Energy Efficiency,reduce,reduce,120,"// For additions and multiplications, traverse add/mul chains for which we; // can potentially create a single SCEV, to reduce the number of; // get{Add,Mul}Expr calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Usability,simpl,simplified,38,// Check if U is a select that can be simplified to a SCEVUnknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Integrability,depend,depends,215,"// Don't attempt to analyze instructions in blocks that aren't; // reachable. Such instructions don't matter, and they aren't required; // to obey basic rules for definitions dominating uses which this; // analysis depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:7,Usability,simpl,simple,7,"// The simple thing to do would be to just call getSCEV on both operands; // and call getAddExpr with the result. However if we're looking at a; // bunch of things all added together, this can be quite inefficient,; // because it leads to N-1 getAddExpr calls for N ultimate operands.; // Instead, gather up all the operands and make a single getAddExpr call.; // LLVM IR canonical form means we need only traverse the left operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Availability,mask,masks,44,"// For an expression like x&255 that merely masks off the high bits,; // use zext(trunc(x)) as the SCEV expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:122,Availability,mask,mask,122,"// Instcombine's ShrinkDemandedConstant may strip bits out of; // constants, obscuring what would otherwise be a low-bits mask.; // Use computeKnownBits to compute what ShrinkDemandedConstant; // knew about to reconstruct a low-bits mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:233,Availability,mask,mask,233,"// Instcombine's ShrinkDemandedConstant may strip bits out of; // constants, obscuring what would otherwise be a low-bits mask.; // Use computeKnownBits to compute what ShrinkDemandedConstant; // knew about to reconstruct a low-bits mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:39,Usability,simpl,simplify,39,"// For an expression like (x * 8) & 8, simplify the multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Availability,mask,mask,61,"// Model xor(and(x, C), C) as and(~x, C), if C is a low-bits mask.; // This is a variant of the check for xor with -1, and it handles; // the case where instcombine has trimmed non-demanded bits out; // of an xor with -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Availability,mask,mask,22,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Availability,mask,mask,62,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,extend,extend,37,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:80,Modifiability,extend,extend,80,"// If C is a single bit, it may be in the sign-bit position; // before the zero-extend. In this case, represent the xor; // using an add, which is equivalent, and re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Safety,safe,safely,10,"// We can safely preserve the nuw flag in all cases. It's also safe to; // turn a nuw nsw shl into a nuw nsw mul. However, nsw in isolation; // requires special handling. It can be preserved as long as we're not; // left shifting by bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Safety,safe,safe,63,"// We can safely preserve the nuw flag in all cases. It's also safe to; // turn a nuw nsw shl into a nuw nsw mul. However, nsw in isolation; // requires special handling. It can be preserved as long as we're not; // left shifting by bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Usability,simpl,simpler,145,"// We can merge the two given cases into a single SCEV statement,; // incase n = m, the mul expression will be 2^0, so it gets resolved to; // a simpler case. The following code handles the two cases:; //; // 1) For a two-shift sext-inreg, i.e. n = m,; // use sext(trunc(x)) as the SCEV expression.; //; // 2) When n > m, use sext(mul(trunc(x), 2^(n-m)))) as the SCEV; // expression. We already checked that ShlAmt < BitWidth, so; // the multiplier, 1 << (ShlAmt - AShrAmt), fits into TruncTy as; // ShlAmt - AShrAmt < Amt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:265,Testability,log,logic,265,// The NSW flag of a subtract does not always survive the conversion to; // A + (-1)*B. By pushing sign extension onto its operands we are much; // more likely to preserve NSW and allow later AddRec optimisations.; //; // NOTE: This is effectively duplicating this logic from getSignExtend:; // sext((A + B + ...)<nsw>) --> (sext(A) + sext(B) + ...)<nsw>; // but by that point the NSW information has potentially been lost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Modifiability,extend,extend,22,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:97,Modifiability,extend,extending,97,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Safety,safe,safe,142,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:169,Usability,simpl,simplification,169,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Integrability,wrap,wrap,65,// Get the total trip count from the count by adding 1. This may wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Energy Efficiency,power,power,94,"// If a trip multiple is huge (>=2^32), the trip count is still divisible by; // the greatest power of 2 divisor less than 2^32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:423,Usability,simpl,simply,423,"/// Returns the largest constant divisor of the trip count of this loop as a; /// normal unsigned value, if possible. This means that the actual trip count is; /// always a multiple of the returned value (don't forget the trip count could; /// very well be zero as well!).; ///; /// Returns 1 if the trip count is unknown or not guaranteed to be the; /// multiple of a constant (which is also the case if the trip count is simply; /// constant, use getSmallConstantTripCount for that case), Will also return 1; /// if the trip count is very large (>= 2^32).; ///; /// As explained in the comments for getSmallConstantTripCount, this assumes; /// that control exits the loop via ExitingBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Deployability,update,update,142,"// Initially insert an invalid entry for this loop. If the insertion; // succeeds, proceed to actually compute a backedge-taken count and; // update the value. The temporary CouldNotCompute value tells SCEV; // code elsewhere that it shouldn't attempt to request a new; // backedge-taken count, which could result in infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,Energy Efficiency,allocate,allocate,33,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:170,Usability,clear,cleared,170,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Modifiability,evolve,evolved,23,// Invalidate constant-evolved loop header phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:214,Deployability,update,updated,214,// This method is intended to forget all info about loops. It should; // invalidate caches as if the following happened:; // - The trip counts of all loops have changed arbitrarily; // - Every llvm::Value has been updated in place to produce a different; // result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:84,Performance,cache,caches,84,// This method is intended to forget all info about loops. It should; // invalidate caches as if the following happened:; // - The trip counts of all loops have changed arbitrarily; // - Every llvm::Value has been updated in place to produce a different; // result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:42,Modifiability,rewrite,rewrites,42,// Drop information about predicated SCEV rewrites for this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Safety,avoid,avoid,38,"// Forget all contained loops too, to avoid dangling entries in the; // ValuesAtScopes map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Performance,perform,perform,8,// Also perform the normal invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:80,Performance,cache,caches,80,"// Unless a specific value is passed to invalidation, completely clear both; // caches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Usability,clear,clear,65,"// Unless a specific value is passed to invalidation, completely clear both; // caches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:46,Performance,cache,cached,46,"// Invalidate the block and loop dispositions cached for S. Dispositions of; // S's users may change if S's disposition changes (i.e. a user may change to; // loop-invariant, if S changes to loop invariant), so also invalidate; // dispositions of S's users recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:228,Testability,test,test,228,"/// Get the exact loop backedge taken count considering all loop exits. A; /// computable result can only be returned for loops with all exiting blocks; /// dominating the latch. howFarToZero assumes that the limit of each loop test; /// is never skipped. This is a valid assumption as long as the loop exits via; /// that test. For precise results, it is the caller's responsibility to specify; /// the relevant loop exiting block using getExact(ExitingBlock, SE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:323,Testability,test,test,323,"/// Get the exact loop backedge taken count considering all loop exits. A; /// computable result can only be returned for loops with all exiting blocks; /// dominating the latch. howFarToZero assumes that the limit of each loop test; /// is never skipped. This is a valid assumption as long as the loop exits via; /// that test. For precise results, it is the caller's responsibility to specify; /// the relevant loop exiting block using getExact(ExitingBlock, SE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Usability,simpl,simply,89,"// All exiting blocks we have gathered dominate loop's latch, so exact trip; // count is simply a minimum out of all these calculated exit counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate memory for BackedgeTakenInfo and copy the not-taken count of each; /// computable exit into a persistent ExitNotTakenInfo array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:74,Usability,Simpl,SimplifyCFG,74,"// Check for a constant condition. These are normally stripped out by; // SimplifyCFG, but ScalarEvolution may be used by a pass which wishes to; // preserve the CFG and is temporarily leaving constant conditions; // in place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Availability,robust,robust,6,"// Be robust against unsimplified IR for the form ""op i1 X, NeutralElement""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Integrability,depend,dependencies,23,// Try to evaluate any dependencies out of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands before analyzing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Integrability,wrap,wrap,172,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:231,Integrability,wrap,wrap,231,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:109,Testability,test,test,109,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:30,Performance,optimiz,optimization,30,"// The key rationale for this optimization is that for some kinds of shift; // recurrences, the value of the recurrence ""stabilizes"" to either 0 or -1; // within a finite number of iterations. If the condition guarding the; // backedge (in the sense that the backedge is taken if the condition is true); // is false for the value the shift recurrence stabilizes to, then we know; // that the backedge is taken only a finite number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Modifiability,evolve,evolve,52,/// Determine whether this instruction can constant evolve within this loop; /// assuming its operands can all constant evolve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:120,Modifiability,evolve,evolve,120,/// Determine whether this instruction can constant evolve within this loop; /// assuming its operands can all constant evolve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Availability,redundant,redundant,34,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Safety,redund,redundant,34,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Integrability,depend,depends,34,"// An instruction inside the loop depends on a value outside the loop that we; // weren't given a mapping for, or a value such as a call inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update all the PHI nodes for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:53,Integrability,interface,interface,53,"/// This builds up a Constant using the ConstantExpr interface. That way, we; /// will return Constants for objects which aren't represented by a; /// SCEVConstant, because SCEVConstant is restricted to ConstantInt.; /// Returns NULL if the SCEV isn't representable as a Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:54,Performance,perform,performing,54,"// First, attempt to evaluate each operand.; // Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:48,Safety,Avoid,Avoid,48,"// First, attempt to evaluate each operand.; // Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:82,Modifiability,variab,variable,82,"// The addrec may be folded to a nonrecurrence, for example, if the; // induction variable is multiplied by zero after constant folding. Go; // ahead and return the folded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Performance,perform,performing,9,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Modifiability,evolve,evolved,26,"// If this instruction is evolved from a constant-evolving PHI, compute the; // exit value from the loop without using SCEVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:107,Usability,simpl,simplified,107,// This trivial case can show up in some degenerate cases where; // the incoming IR has not yet been fully simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:92,Usability,simpl,simplify,92,"// 4. Compute the minimum unsigned root of the equation:; // I * (B / D) mod (N / D); // To simplify the computation, we factor out the divide by D:; // (I * B mod N) / D",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:369,Performance,optimiz,optimizations,369,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:645,Safety,avoid,avoid,645,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Testability,test,test,52,"// This is only used for loops with a ""x != y"" exit test. The exit condition; // is now expressed as a single expression, V = x-y. So the exit test is; // effectively V != 0. We know and take advantage of the fact that this; // expression only being used in a comparison by zero context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:143,Testability,test,test,143,"// This is only used for loops with a ""x != y"" exit test. The exit condition; // is now expressed as a single expression, V = x-y. So the exit test is; // effectively V != 0. We know and take advantage of the fact that this; // expression only being used in a comparison by zero context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:218,Availability,down,down,218,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:183,Integrability,wrap,wrap,183,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Availability,down,down,128,// For positive steps (counting up until unsigned overflow):; // N = -Start/Step (as unsigned); // For negative steps (counting down to zero):; // N = Start/-Step; // First compute the unsigned distance from zero in the direction of Step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Integrability,wrap,wraparound,38,"// Handle unitary steps, which cannot wraparound.; // 1*N = -Start; -1*N = Start (mod 2^BW), so:; // N = Distance (as unsigned)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:141,Safety,Detect,Detect,141,"// When a loop like ""for (int i = 0; i != n; ++i) { /* body */ }"" is rotated,; // we end up with a loop whose backedge-taken count is n - 1. Detect this; // case, and see if we can improve the bound.; //; // Explicitly handling this here is necessary because getUnsignedRange; // isn't context-sensitive; it doesn't know that we only care about the; // range inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:114,Integrability,wrap,wrap,114,"// If the condition controls loop exit (the loop exits only if the expression; // is true) and the addition is no-wrap we can use unsigned divide to; // compute the backedge count. In this case, the step may not divide the; // distance, but we don't care because if the condition is ""missed"" the loop; // will have undefined behavior due to wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:341,Integrability,wrap,wrapping,341,"// If the condition controls loop exit (the loop exits only if the expression; // is true) and the addition is no-wrap we can use unsigned divide to; // compute the backedge count. In this case, the step may not divide the; // distance, but we don't care because if the condition is ""missed"" the loop; // will have undefined behavior due to wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:58,Testability,test,testing,58,"/// SCEV structural equivalence is usually sufficient for testing whether two; /// expressions are equal, however for the purposes of looking for a condition; /// guarding a loop, it can be useful to be a little more general, since a; /// front-end may have replicated the controlling expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies ICMP to trivial true or false by turning it into '0 == 0' or; // '0 != 0'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:42,Integrability,message,messages,42,"// The ""Should have been caught earlier!"" messages refer to the fact; // that the ExactCR.isFullSet() or ExactCR.isEmptySet() check above; // should have fired on the corresponding cases, and canonicalized the; // check to trivial case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,simpl,simplifications,14,// TODO: More simplifications are possible here.; // Recursively simplify until we either hit a recursion limit or nothing; // changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Usability,simpl,simplify,65,// TODO: More simplifications are possible here.; // Recursively simplify until we either hit a recursion limit or nothing; // changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Availability,down,down,14,// Query push down for cases where the unsigned range is; // less than sufficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Availability,avail,available,104,"// It is possible that init SCEV contains an invariant load but it does; // not dominate MDL and is not available at MDL loop entry, so we should; // check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:55,Performance,load,load,55,"// It is possible that init SCEV contains an invariant load but it does; // not dominate MDL and is not available at MDL loop entry, so we should; // check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Usability,simpl,simple,44,// Otherwise see what can be done with some simple reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:117,Integrability,depend,depend,117,"// A zero step value for LHS means the induction variable is essentially a; // loop invariant value. We don't really depend on the predicate actually; // flipping from false to true (for increasing predicates, and the other way; // around for decreasing predicates), all we care about is that *if* the; // predicate changes then it only changes from false to true.; //; // A zero step value in itself is not very useful, but there may be places; // where SCEV can prove X >= 0 but not prove X > 0, so it is helpful to be; // as general as possible.; // Only handle LE/LT/GE/GT predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Modifiability,variab,variable,49,"// A zero step value for LHS means the induction variable is essentially a; // loop invariant value. We don't really depend on the predicate actually; // flipping from false to true (for increasing predicates, and the other way; // around for decreasing predicates), all we care about is that *if* the; // predicate changes then it only changes from false to true.; //; // A zero step value in itself is not very useful, but there may be places; // where SCEV can prove X >= 0 but not prove X > 0, so it is helpful to be; // as general as possible.; // Only handle LE/LT/GE/GT predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Integrability,wrap,wrap,26,// Check that AR does not wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,depend,dependent,136,"// If the predicate ""ArLHS `Pred` RHS"" monotonically increases from false to; // true as the loop iterates, and the backedge is control dependent on; // ""ArLHS `Pred` RHS"" == true then we can reason as follows:; //; // * if the predicate was false in the first iteration then the predicate; // is never evaluated again, since the loop exits without taking the; // backedge.; // * if the predicate was true in the first iteration then it will; // continue to be true for all future iterations since it is; // monotonically increasing.; //; // For both the above possibilities, we can replace the loop varying; // predicate with its value on the first iteration of the loop (which is; // loop invariant).; //; // A similar reasoning applies for a monotonically decreasing predicate, by; // replacing true with false and false with true in the above two bullets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,wrap,wrap,136,"// Type mismatch here means that MaxIter is potentially larger than max; // unsigned value in start type, which mean we cannot prove no wrap for the; // indvar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:168,Integrability,wrap,wrap,168,"// Because step is +/- 1 and MaxIter has same type as Start (i.e. it does; // not exceed max unsigned value of this type), this effectively proves; // that there is no wrap during the iteration. To prove that there is no; // signed/unsigned wrap, we need to check that; // Start <= Last for step = 1 or Start >= Last for step = -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:241,Integrability,wrap,wrap,241,"// Because step is +/- 1 and MaxIter has same type as Start (i.e. it does; // not exceed max unsigned value of this type), this effectively proves; // that there is no wrap during the iteration. To prove that there is no; // signed/unsigned wrap, we need to check that; // Start <= Last for step = 1 or Start >= Last for step = -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:180,Energy Efficiency,power,powerful,180,"// If L >= 0 then I `ult` L <=> I >= 0 && I `slt` L; //; // To prove L >= 0 we use isKnownNonNegative whereas to prove I >= 0 we use; // isKnownPredicate. isKnownPredicate is more powerful, but also more; // expensive; and using isKnownNonNegative(RHS) is sufficient for most of the; // interesting cases seen in practice. We can consider ""upgrading"" L >= 0 to; // use isKnownPredicate later if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Testability,Test,Test,34,/// isLoopBackedgeGuardedByCond - Test whether the backedge of the loop is; /// protected by a conditional between LHS and RHS. This is used to; /// to eliminate casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Availability,avail,available,28,// Both LHS and RHS must be available at loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:66,Safety,Avoid,Avoid,66,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,clear,clear,14,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:95,Integrability,wrap,wraps,95,"// Given (V >= Min && V != Min) we conclude V >= (Min + 1).; // This is true even if (Min + 1) wraps around -- in case of; // wraparound, (Min + 1) < Min, so (V >= Min => V >= (Min + 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:126,Integrability,wrap,wraparound,126,"// Given (V >= Min && V != Min) we conclude V >= (Min + 1).; // This is true even if (Min + 1) wraps around -- in case of; // wraparound, (Min + 1) < Min, so (V >= Min => V >= (Min + 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,// We avoid subtracting expressions here because this function is usually; // fairly deep in the call stack (i.e. is called many times).; // X - X = 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:46,Integrability,depend,dependencies,46,"// We'd like to let SCEV reason about control dependencies, so we constrain; // both the inequalities to be about add recurrences on the same loop. This; // way we can use isLoopEntryGuardedByCond later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Safety,detect,detect,9,"// If we detect a loop of Phi nodes being processed by this method, for; // example:; //; // %a = phi i32 [ %some1, %preheader ], [ %b, %latch ]; // %b = phi i32 [ %some2, %preheader ], [ %a, %latch ]; //; // we don't want to deal with a case that complex, so return conservative; // answer false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Availability,avail,available,21,// Check that RHS is available in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:111,Integrability,wrap,wrap,111,"// If both sides are affine addrecs for the same loop, with equal; // steps, and we know the recurrences don't wrap, then we only; // need to check the predicate on the starting values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Safety,avoid,avoid,14,// We want to avoid hurting the compile time with analysis of too big trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Energy Efficiency,reduce,reduce,24,"// For unsigned, try to reduce it to corresponding signed comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Safety,avoid,avoid,14,"// We want to avoid creation of any new non-constant SCEV. Since we are; // going to compare the operands to RHS, we should be certain that we don't; // need any size extensions for this. So let's decline all cases when the; // sizes of types of LHS and RHS do not match.; // TODO: Maybe try to get RHS from sext to catch more cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:43,Performance,perform,perform,43,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:313,Performance,cache,cache,313,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,Safety,avoid,avoid,345,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:378,Safety,avoid,avoid,378,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Modifiability,extend,extend,63,"// One of types is a pointer and another one is not. We cannot extend; // them properly to a wider type, so let us just reject this case.; // TODO: Usage of getEffectiveSCEVType for DTy, FRHSTy etc should help; // to avoid this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:217,Safety,avoid,avoid,217,"// One of types is a pointer and another one is not. We cannot extend; // them properly to a wider type, so let us just reject this case.; // TODO: Usage of getEffectiveSCEVType for DTy, FRHSTy etc should help; // to avoid this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Availability,down,down,65,"// If our expression contained SCEVUnknown Phis, and we split it down and now; // need to prove something for them, try to prove the predicate for every; // possible incoming values of those Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,Energy Efficiency,reduce,reduce,75,// The restriction on `FoundRHS` be lifted easily -- it exists only to; // reduce the compile time impact of this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:114,Performance,optimiz,optimization,114,// The restriction on `FoundRHS` be lifted easily -- it exists only to; // reduce the compile time impact of this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:7,Testability,log,logic,7,"// The logic in this function assumes we can represent a positive stride.; // If we can't, the backedge-taken count must be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Security,audit,audited,37,"// This code below only been closely audited for negative strides in the; // unsigned comparison case, it may be correct for signed comparison, but; // that needs to be established.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Safety,safe,safe,142,"// Although End can be a MAX expression we estimate MaxEnd considering only; // the case End = RHS of the loop termination condition. This is safe because; // in the other case (End - Start) is zero, leading to a zero maximum backedge; // taken count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:126,Integrability,wrap,wrap,126,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Integrability,wrap,wrap,194,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:770,Integrability,wrap,wrap,770,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:41,Integrability,wrap,wrap,41,// We can use the comparison to infer no-wrap flags only if it fully; // controls the loop exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Testability,log,logic,102,// We need the sequence defined by AR to strictly increase in the; // unsigned integer domain for the logic below to hold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid negative or zero stride values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:929,Energy Efficiency,reduce,reduces,929,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:566,Integrability,depend,depending,566,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Integrability,wrap,wrap,16,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:58,Integrability,wrap,wrap,58,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:127,Integrability,wrap,wrapped,127,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:153,Integrability,wrap,wrapped,153,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:220,Integrability,wrap,wrap,220,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Performance,optimiz,optimize,192,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:505,Energy Efficiency,reduce,reduces,505,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:884,Energy Efficiency,reduce,reduces,884,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:571,Usability,simpl,simplies,571,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Modifiability,variab,variable,108,"// At this point, we know:; //; // 1. If IsSigned, Start <=s End; otherwise, Start <=u End; // 2. The index variable doesn't overflow.; //; // Therefore, we know N exists such that; // (Start + Stride * N) >= End, and computing ""(Start + Stride * N)""; // doesn't overflow.; //; // Using this information, try to prove whether the addition in; // ""(Start - End) + (Stride - 1)"" has unsigned overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Energy Efficiency,power,power,23,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:664,Energy Efficiency,power,power,664,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1138,Modifiability,rewrite,rewrite,1138,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid negative or zero stride values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Performance,optimiz,optimize,192,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Safety,safe,safe,108,"// Although End can be a MIN expression we estimate MinEnd considering only; // the case End = RHS. This is safe because in the other case (Start - End); // is zero, leading to a zero maximum backedge taken count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Usability,simpl,simplify,59,"// If the start is a non-zero constant, shift the range to simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:124,Integrability,wrap,wrap,124,"// Evaluate at the exit value. If we really did fall out of the valid; // range, then we computed our trip count, otherwise wrap around or other; // things must have happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:226,Usability,simpl,simplification,226,"// There is a temptation to just call getAddExpr(this, getStepRecurrence(SE)),; // but in this case we cannot guarantee that the value returned will be an; // AddRec because SCEV does not have a fixed point where it stops; // simplification: it is legal to return ({rec1} + {rec2}). For example, it; // may happen if we reach arithmetic depth limit while simplifying. So we; // construct the returned value explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:355,Usability,simpl,simplifying,355,"// There is a temptation to just call getAddExpr(this, getStepRecurrence(SE)),; // but in this case we cannot guarantee that the value returned will be an; // AddRec because SCEV does not have a fixed point where it stops; // simplification: it is legal to return ({rec1} + {rec2}). For example, it; // may happen if we reach arithmetic depth limit while simplifying. So we; // construct the returned value explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:535,Energy Efficiency,efficient,efficient,535,"// To use guards for proving predicates, we need to scan every instruction in; // relevant basic blocks, and not just terminators. Doing this is a waste of; // time if the IR does not actually contain any calls to; // @llvm.experimental.guard, so do a quick check and remember this beforehand.; //; // This pessimizes the case where a pass that preserves ScalarEvolution wants; // to _add_ guards to the module when there weren't any before, and wants; // ScalarEvolution to optimize based on those guards. For now we prefer to be; // efficient in lieu of being smart in that rather obscure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:475,Performance,optimiz,optimize,475,"// To use guards for proving predicates, we need to scan every instruction in; // relevant basic blocks, and not just terminators. Doing this is a waste of; // time if the IR does not actually contain any calls to; // @llvm.experimental.guard, so do a quick check and remember this beforehand.; //; // This pessimizes the case where a pass that preserves ScalarEvolution wants; // to _add_ guards to the module when there weren't any before, and wants; // ScalarEvolution to optimize based on those guards. For now we prefer to be; // efficient in lieu of being smart in that rather obscure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Deployability,release,release,94,"// Iterate through all the SCEVUnknown instances and call their; // destructors, so that they release their references to their values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:78,Testability,test,test,78,"// This uses a ""dominates"" query instead of ""properly dominates"" query; // to test for proper dominance too, because the instruction which; // produces the addrec's value is a PHI, and a PHI effectively properly; // dominates its entire containing block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Performance,cache,cached,15,// Only verify cached BECounts. Computing new BECounts may change the; // results of subsequent SCEV uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:233,Testability,assert,assert,233,"// NB! This situation is legal, but is very suspicious -- whatever pass; // change the loop to make a trip count go from could not compute to; // computable or vice-versa *should have* invalidated SCEV. However, we; // choose not to assert here (for now) since we don't want false; // positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of SCEV users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,Integrability,depend,dependencies,19,// We do not store dependencies of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of ValuesAtScopes users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of BECountUsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:40,Performance,cache,cache,40,// Verify intergity of loop disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:45,Performance,cache,cache,45,// Verify integrity of the block disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of the block disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Performance,cache,caches,34,// Verify FoldCache/FoldCacheUser caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:285,Integrability,wrap,wrap,285,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:81,Performance,cache,cached,81,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:246,Performance,cache,cached,246,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Integrability,depend,dependencies,87,// Invalidate the ScalarEvolution object whenever it isn't preserved or one; // of its dependencies is invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:119,Testability,test,tests,119,// For compatibility with opt's -analyze feature under legacy pass manager; // which was not ported to NPM. This keeps tests using; // update_analyze_test_checks.py working.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Modifiability,Rewrite,Rewrites,4,"/// Rewrites \p S in the context of a loop L and the SCEV predication; /// infrastructure.; ///; /// If \p Pred is non-null, the SCEV expression is rewritten to respect the; /// equivalences present in \p Pred.; ///; /// If \p NewPreds is non-null, rewrite is free to add further predicates to; /// \p NewPreds such that the result will be an AddRecExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:249,Modifiability,rewrite,rewrite,249,"/// Rewrites \p S in the context of a loop L and the SCEV predication; /// infrastructure.; ///; /// If \p Pred is non-null, the SCEV expression is rewritten to respect the; /// equivalences present in \p Pred.; ///; /// If \p NewPreds is non-null, rewrite is free to add further predicates to; /// \p NewPreds such that the result will be an AddRecExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Integrability,Wrap,Wrap,3,// Wrap predicates from outer loops are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Safety,safe,safely,10,// We can safely transfer the NSW flag as NSSW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,Integrability,Wrap,WrapPredicate,75,"// If the increment is positive, the SCEV NUW flag will also imply the; // WrapPredicate NUSW flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:31,Performance,cache,cached,31,/// Union predicates don't get cached so create a dummy set ID for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:188,Integrability,depend,dependencies,188,"// We do not expect that forgetting cached data for SCEVConstants will ever; // open any prospects for sharpening or introduce any correctness issues,; // so we don't bother storing their dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:36,Performance,cache,cached,36,"// We do not expect that forgetting cached data for SCEVConstants will ever; // open any prospects for sharpening or introduce any correctness issues,; // so we don't bother storing their dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,Rewrite,Rewrite,37,// We found an entry but it's stale. Rewrite the stale entry; // according to the current predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Integrability,wrap,wrapped,28,// If the generation number wrapped recompute everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear the statically implied flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:179,Energy Efficiency,power,power-of-,179,"// Match the mathematical pattern A - (A / B) * B, where A and B can be; // arbitrary expressions. Also match zext (trunc A to iB) to iY, which is used; // for URem with constant power-of-2 second operands.; // It's not always easy, as A and B can be folded (imagine A is X / 2, and B is; // 4, A / B becomes X / 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Energy Efficiency,power,power-of-,87,"// Try to match 'zext (trunc A to iB) to iY', which is used; // for URem with constant power-of-2 second operands. Make sure the size of; // the operand A matches the size of the whole expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Modifiability,rewrite,rewriter,6,/// A rewriter to replace SCEV expressions in Map with the corresponding entry; /// in the map. It skips AddRecExpr because we cannot guarantee that the; /// replacement is loop invariant in the loop of the AddRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Integrability,wrap,wrap,49,"// WARNING: It is generally unsound to apply any wrap flags to the proposed; // replacement SCEV which isn't directly implied by the structure of that; // SCEV. In particular, using contextual facts to imply flags is *NOT*; // legal. See the scoping rules for flags in the header to understand why.; // If LHS is a constant, apply information to the other expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Integrability,wrap,wrapping,34,"// Bail out, unless we have a non-wrapping, monotonic range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:116,Availability,down,down,116,"// Apply divisibilty by \p Divisor on MinMaxExpr with constant values,; // recursively. This is done by aligning up/down the constant value to the; // Divisor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Modifiability,rewrite,rewrite,102,"// If we have LHS == 0, check if LHS is computing a property of some unknown; // SCEV %v which we can rewrite %v to express explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,rewrite,rewrite,37,"// If LHS is A % B, i.e. A % B == 0, rewrite A to (A /u B) * B to; // explicitly express that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Modifiability,rewrite,rewrite,8,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Modifiability,rewrite,rewrite,47,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:138,Modifiability,rewrite,rewrite,138,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Modifiability,rewrite,rewrite,89,// Checks whether \p S has already been rewritten. In that case returns the; // existing rewrite because we want to chain further rewrites onto the; // already rewritten value. Otherwise returns \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:130,Modifiability,rewrite,rewrites,130,// Checks whether \p S has already been rewritten. In that case returns the; // existing rewrite because we want to chain further rewrites onto the; // already rewritten value. Otherwise returns \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:475,Integrability,depend,depending,475,"// Collect rewrites for LHS and its transitive operands based on the; // condition.; // For min/max expressions, also apply the guard to its operands:; // 'min(a, b) >= c' -> '(a >= c) and (b >= c)',; // 'min(a, b) > c' -> '(a > c) and (b > c)',; // 'max(a, b) <= c' -> '(a <= c) and (b <= c)',; // 'max(a, b) < c' -> '(a < c) and (b < c)'.; // We cannot express strict predicates in SCEV, so instead we replace them; // with non-strict ones against plus or minus one of RHS depending on the; // predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Modifiability,rewrite,rewrites,11,"// Collect rewrites for LHS and its transitive operands based on the; // condition.; // For min/max expressions, also apply the guard to its operands:; // 'min(a, b) >= c' -> '(a >= c) and (b >= c)',; // 'min(a, b) > c' -> '(a > c) and (b > c)',; // 'max(a, b) <= c' -> '(a <= c) and (b <= c)',; // 'max(a, b) < c' -> '(a < c) and (b < c)'.; // We cannot express strict predicates in SCEV, so instead we replace them; // with non-strict ones against plus or minus one of RHS depending on the; // predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:266,Testability,log,logic,266,"// Third, collect conditions from dominating branches. Starting at the loop; // predecessor, climb up the predecessor chain, as long as there are; // predecessors that can be found that have unique successors leading to the; // original header.; // TODO: share this logic with isLoopEntryGuardedByCond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:213,Integrability,depend,dependency,213,"// Now apply the information from the collected conditions to RewriteMap.; // Conditions are processed in reverse order, so the earliest conditions is; // processed first. This ensures the SCEVs with the shortest dependency chains; // are constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Modifiability,Rewrite,RewriteMap,62,"// Now apply the information from the collected conditions to RewriteMap.; // Conditions are processed in reverse order, so the earliest conditions is; // processed first. This ensures the SCEVs with the shortest dependency chains; // are constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Modifiability,rewrite,rewrite,16,"// Now that all rewrite information is collect, rewrite the collected; // expressions with the information in the map. This applies information to; // sub-expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:48,Modifiability,rewrite,rewrite,48,"// Now that all rewrite information is collect, rewrite the collected; // expressions with the information in the map. This applies information to; // sub-expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:577,Integrability,depend,dependence,577,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:622,Integrability,depend,dependencies,622,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:688,Integrability,depend,dependencies,688,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:608,Testability,test,tests,608,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:463,Usability,simpl,simple,463,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:3,Testability,Test,Test,3,"// Test whether the difference is known to be great enough that memory of; // the given sizes don't overlap. This assumes that ASizeInt and BSizeInt; // are non-zero, which is special-cased above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:121,Testability,test,test,121,"// Folding the subtraction while preserving range information can be tricky; // (because of INT_MIN, etc.); if the prior test failed, swap AS and BS; // and try again to see if things fold better that way.; // Compute the difference between the two pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:3,Testability,Test,Test,3,"// Test whether the difference is known to be great enough that memory of; // the given sizes don't overlap. This assumes that ASizeInt and BSizeInt; // are non-zero, which is special-cased above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:99,Integrability,depend,depends,99,"// If ScalarEvolution can find an underlying object, form a new query.; // The correctness of this depends on ScalarEvolution not recognizing; // inttoptr and ptrtoint operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:118,Integrability,depend,depends,118,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:38,Safety,avoid,avoid,38,// Check for the trivial case here to avoid having to check for it in the; // rest of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:5,Usability,simpl,simple,5,// A simple case when N/1. The quotient is N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:30,Usability,simpl,simplify,30,// This SCEV does not seem to simplify: fail the division here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:124,Usability,simpl,simplify,124,"// We generally do not know how to divide Expr by Denominator. We initialize; // the division to a ""cannot divide"" state to simplify the rest of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp:18,Performance,Perform,Perform,18,/// Denormalize - Perform the inverse transform on the expression with the; /// given loop set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp:180,Usability,clear,clear,180,"// Denormalization / ""partial increment"" is essentially the same as \c; // SCEVAddRecExpr::getPostIncExpr. Here we use an explicit loop to make the; // symmetry with Normalization clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1016,Performance,Load,Loads,1016,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1146,Performance,load,load,1146,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1194,Performance,load,load,1194,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1504,Security,access,accesses,1504,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:113,Availability,alive,alive,113,"// LiveIn, LiveOut and BitsIn have a different meaning deppends on type.; // ::Maybe true bits represent ""may be alive"" allocas, ::Must true bits; // represent ""may be dead"". After the loop we will convert ::Must bits from; // ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:253,Availability,alive,alive,253,"// LiveIn, LiveOut and BitsIn have a different meaning deppends on type.; // ::Maybe true bits represent ""may be alive"" allocas, ::Must true bits; // represent ""may be dead"". After the loop we will convert ::Must bits from; // ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:3,Deployability,Update,Update,3,"// Update block LiveIn set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:11,Availability,alive,alive,11,"// ""may be alive"" is set by lifetime start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:3,Deployability,Update,Update,3,"// Update block LiveOut set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:42,Availability,alive,alive,42,"// Convert from ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:46,Safety,safe,safety,46,"//===- StackSafetyAnalysis.cpp - Stack memory safety analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:11,Integrability,wrap,wrapped,11,// Two non-wrapped sets can produce wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:36,Integrability,wrap,wrapped,36,// Two non-wrapped sets can produce wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:3,Security,Access,Access,3,// Access range if the address (alloca or parameters).; // It is allowed to be empty-set when there are no known accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:113,Security,access,accesses,113,// Access range if the address (alloca or parameters).; // It is allowed to be empty-set when there are no known accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:210,Security,access,access,210,"// List of calls which pass address as an argument.; // Value is offset range of address from base address (alloca or calling; // function argument). Range should never set to empty-set, that is an invalid; // access range that can cause empty-set to be propagated with; // ConstantRange::add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:34,Integrability,depend,depending,34,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:140,Security,access,access,140,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:13,Performance,load,loads,13,// Zero-size loads and stores do not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:37,Security,access,access,37,// Zero-size loads and stores do not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:36,Safety,safe,safe,36,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:49,Security,access,access,49,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:95,Security,access,access,95,/// The function analyzes all local uses of Ptr (alloca or argument) and; /// calculates local access range and all function calls where it was used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:56,Safety,unsafe,unsafe,56,// Stored the pointer - conservatively assume it may be unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:30,Safety,safe,safe,30,"// ""va-arg"" from a pointer is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:10,Usability,Simpl,Simplify,10,// FIXME: Simplify printing and remove copying here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:183,Energy Efficiency,reduce,reduce,183,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:13,Security,access,accessed,13,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:33,Availability,Alive,Alive,33,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:133,Security,access,accessed,133,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp:37,Security,Hash,Hash,37,"//===- StructuralHash.cpp - Function Hash Printing ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the StructuralHashPrinterPass which is used to show; // the structural hash of all functions in a module and the module itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp:472,Security,hash,hash,472,"//===- StructuralHash.cpp - Function Hash Printing ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the StructuralHashPrinterPass which is used to show; // the structural hash of all functions in a module and the module itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:30,Deployability,update,update,30,"// For nodes in the same SCC, update the counts in two steps:; // 1. Compute the additional count for each node by propagating the counts; // along all incoming edges to the node that originate from within the same; // SCC and summing them up.; // 2. Add the additional counts to the nodes in the SCC.; // This ensures that the order of; // traversal of nodes within the SCC doesn't affect the final result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:3,Deployability,Update,Update,3,// Update the counts for the nodes in the SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:7,Deployability,update,update,7,// Now update the counts for nodes outside the SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:247,Deployability,update,updates,247,"/// Propgate synthetic entry counts on a callgraph \p CG.; ///; /// This performs a reverse post-order traversal of the callgraph SCC. For each; /// SCC, it first propagates the entry counts to the nodes within the SCC; /// through call edges and updates them in one shot. Then the entry counts are; /// propagated to nodes outside the SCC. This requires \p GraphTraits; /// to have a specialization for \p CallGraphType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:73,Performance,perform,performs,73,"/// Propgate synthetic entry counts on a callgraph \p CG.; ///; /// This performs a reverse post-order traversal of the callgraph SCC. For each; /// SCC, it first propagates the entry counts to the nodes within the SCC; /// through call edges and updates them in one shot. Then the entry counts are; /// propagated to nodes outside the SCC. This requires \p GraphTraits; /// to have a specialization for \p CallGraphType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:48,Availability,down,down,48,"// The callgraph-scc needs to be visited in top-down order for propagation.; // The scc iterator returns the scc in bottom-up order, so reverse the SCCs; // and call propagateFromSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:85,Usability,simpl,simplify,85,"// The iOS ABI diverges from the standard in some cases, so for now don't; // try to simplify those calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,Availability,avail,available,26,/// Initialize the set of available library functions based on the specified; /// target triple. This should be carefully written so that a missing target; /// triple gets a sane set of defaults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:59,Availability,avail,available,59,// Set IO unlocked variants as unavailable; // Set them as available per system below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:34,Availability,avail,available,34,"// memset_pattern{4,8,16} is only available on iOS 3.0 and Mac OS X 10.5 and; // later. All versions of watchOS support it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,avail,available,3,// available IO unlocked variants on Mac OS X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:318,Integrability,depend,depends,318,"// x86-32 OSX has a scheme where fwrite and fputs (and some other functions; // we don't care about) have two versions; on recent OSX, the one we want; // has a $UNIX2003 suffix. The two implementations are identical except; // for the return value in some edge cases. However, we don't want to; // generate code that depends on the old symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:32,Availability,avail,available,32,"// iprintf and friends are only available on XCore, TCE, and Emscripten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:39,Availability,avail,available,39,// __small_printf and friends are only available on Emscripten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:35,Availability,avail,available,35,"// XXX: The earliest documentation available at the moment is for VS2015/VC19:; // https://docs.microsoft.com/en-us/cpp/c-runtime-library/floating-point-support?view=vs-2015; // XXX: In order to use an MSVCRT older than VC19,; // the specific library version must be explicit in the target triple,; // e.g., x86_64-pc-windows-msvc18.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:70,Availability,avail,available,70,"// Win32 does not support these functions, but; // they are generally available on POSIX-compliant systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,Availability,avail,available,26,// These functions aren't available in either MSVC or MinGW environments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:28,Availability,avail,available,28,// exp10 and exp10f are not available on OS X until 10.9 and iOS until 7.0; // and their names are __exp10 and __exp10f. exp10l is not available on; // OS X or iOS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:135,Availability,avail,available,135,// exp10 and exp10f are not available on OS X until 10.9 and iOS until 7.0; // and their names are __exp10 and __exp10f. exp10l is not available on; // OS X or iOS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:28,Availability,avail,available,28,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:218,Availability,reliab,reliably,218,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:141,Deployability,deploy,deployed,141,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:178,Safety,detect,detection,178,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:11,Availability,avail,available,11,"// ffsl is available on at least Darwin, Mac OS X, iOS, FreeBSD, and; // Linux (GLIBC):; // http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/ffsl.3.html; // http://svn.freebsd.org/base/head/lib/libc/string/ffsl.c; // http://www.gnu.org/software/gnulib/manual/html_node/ffsl.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:12,Availability,avail,available,12,// ffsll is available on at least FreeBSD and Linux (GLIBC):; // http://svn.freebsd.org/base/head/lib/libc/string/ffsll.c; // http://www.gnu.org/software/gnulib/manual/html_node/ffsll.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// The following functions are available on at least FreeBSD:; // http://svn.freebsd.org/base/head/lib/libc/string/fls.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsl.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsll.c,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:36,Availability,avail,available,36,"// The following functions are only available on GNU/Linux (using glibc).; // Linux variants without glibc (eg: bionic, musl) may have some subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,avail,available,3,// available IO unlocked variants on GNU/Linux and Android P or later,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:554,Performance,optimiz,optimizations,554,"// As currently implemented in clang, NVPTX code has no standard library to; // speak of. Headers provide a standard-ish library implementation, but many; // of the signatures are wrong -- for example, many libm functions are not; // extern ""C"".; //; // libdevice, an IR library provided by nvidia, is linked in by the front-end,; // but only used functions are provided to llvm. Moreover, most of the; // functions in libdevice don't map precisely to standard library functions.; //; // FIXME: Having no standard library prevents e.g. many fastmath; // optimizations, so this situation should be fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:107,Performance,perform,performance,107,// TODO: We could enable the following two according to [0] but we haven't; // done an evaluation wrt. the performance implications.; // [0]; // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations; //; // TLI.setAvailable(llvm::LibFunc_memcpy);; // TLI.setAvailable(llvm::LibFunc_memset);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:193,Usability,guid,guide,193,// TODO: We could enable the following two according to [0] but we haven't; // done an evaluation wrt. the performance implications.; // [0]; // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations; //; // TLI.setAvailable(llvm::LibFunc_memcpy);; // TLI.setAvailable(llvm::LibFunc_memset);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:43,Availability,avail,available,43,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:25,Integrability,rout,routines,25,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// Default to everything being available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// Default to everything being available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:194,Performance,optimiz,optimizations,194,"// NOTE: These prototypes are target specific and currently support; // ""complex"" passed as an array or discrete real & imaginary parameters.; // Add other calling conventions to enable libcall optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:156,Safety,avoid,avoid,156,"// Intrinsics don't overlap w/libcalls; if our module has a large number of; // intrinsics, this ends up being an interesting compile time win since we; // avoid string normalization and comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,MASK,MASK,3,/* MASK = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,MASK,MASK,3,/* MASK = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:145,Availability,avail,available,145,/// No-op implementation of the TTI interface using the utility base; /// classes.; ///; /// This is used when no target specific information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:36,Integrability,interface,interface,36,/// No-op implementation of the TTI interface using the utility base; /// classes.; ///; /// This is used when no target specific information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:18,Deployability,update,updated,18,"// If we pass the updated counter back through a phi, we need to know; // which latch the updated value will be coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:90,Deployability,update,updated,90,"// If we pass the updated counter back through a phi, we need to know; // which latch the updated value will be coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:117,Energy Efficiency,power,powers,117,// Check for a splat of a constant or for a non uniform vector of constants; // and check if the constant(s) are all powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:101,Integrability,interface,interface,101,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:10,Testability,Assert,Assert,10,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:167,Testability,assert,asserted,167,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:101,Integrability,interface,interface,101,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:10,Testability,Assert,Assert,10,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:167,Testability,assert,asserted,167,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:450,Performance,load,loading,450,"//===- TensorSpec.cpp - tensor type abstraction ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation file for the abstraction of a tensor type, and JSON loading; // utils.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:55,Availability,error,error,55,"// FIXME: accept a Path as a parameter, and use it for error reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:18,Integrability,message,messages,18,// INFO and DEBUG messages could be numerous and not particularly interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:15,Availability,Error,ErrorReporter,15,"// FIXME: make ErrorReporter a member (may also need subclassing; // StatefulErrorReporter) to easily get the latest error status, for; // debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:117,Availability,error,error,117,"// FIXME: make ErrorReporter a member (may also need subclassing; // StatefulErrorReporter) to easily get the latest error status, for; // debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:101,Energy Efficiency,allocate,allocates,101,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:366,Safety,avoid,avoid,366,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:70,Availability,error,error,70,"// we haven't passed all the required features to the model, throw an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:538,Performance,optimiz,optimizations,538,"//===- Trace.cpp - Implementation of Trace class --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:666,Performance,optimiz,optimizations,666,"//===- Trace.cpp - Implementation of Trace class --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:65,Availability,error,error,65,/// dump - Debugger convenience method; writes trace to standard error; /// output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp:48,Testability,log,logging,48,"//===- TrainingLogger.cpp - mlgo feature/reward logging -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements logging infrastructure for extracting features and; // rewards for mlgo policy training.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp:404,Testability,log,logging,404,"//===- TrainingLogger.cpp - mlgo feature/reward logging -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements logging infrastructure for extracting features and; // rewards for mlgo policy training.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:953,Deployability,upgrade,upgraded,953,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:1012,Deployability,upgrade,upgrade,1012,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3302,Performance,load,load,3302,"ction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4428,Performance,perform,perform,4428,"and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAlias; // otherwise.; // If we reach the Root node, perform the above starting from base type of tagY; // to see if we reach base type of tagX.; //; // If they have different roots, they're part of different potentially; // unrelated type systems, so we return Alias to be conservative.; // If neither node is an ancestor of the other and they have the same root,; // then we say NoAlias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:2548,Security,access,access,2548,"es are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (meaning pointsToConstantMemory; // should return true; see; // http://llvm.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:2788,Security,access,access,2788,"ted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (meaning pointsToConstantMemory; // should return true; see; // http://llvm.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // Th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3247,Security,access,access,3247,"m.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3366,Security,access,access,3366,"fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAli",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:935,Testability,test,testing,935,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:1135,Usability,simpl,simple,1135," under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (mean",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3446,Usability,Simpl,Simple,3446," field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAlias; // otherwise.; // If we reach the Root node, perform the above starting from base type of tagY; // to see if we reach base type of tagX.; //; // If they have different roots, they're part of different potentially; // unrelated ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:21,Integrability,wrap,wrapper,21,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:81,Integrability,interface,interface,81,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Usability,simpl,simple,14,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped type node is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4,Testability,Test,Test,4,/// Test if this TBAANode represents a type for objects which are; /// not modified (by any means) in the context where this; /// AliasAnalysis is relevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:29,Integrability,wrap,wrapper,29,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:89,Integrability,interface,interface,89,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:22,Usability,simpl,simple,22,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped access tag is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:46,Security,access,access,46,/// isNewFormat - Return true iff the wrapped access tag is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4,Testability,Test,Test,4,/// Test if this TBAAStructTagNode represents a type for objects; /// which are not modified (by any means) in the context where this; /// AliasAnalysis is relevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:29,Integrability,wrap,wrapper,29,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:89,Integrability,interface,interface,89,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:22,Usability,simpl,simple,22,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped type node is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:80,Deployability,Update,Update,80,/// Get this TBAAStructTypeNode's field in the type DAG with; /// given offset. Update the offset to be relative to the field type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:39,Security,access,access,39,"// If this is an ""immutable"" type, the access is not observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:42,Security,access,access,42,"// For struct-path aware TBAA, we use the access type of the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:18,Security,access,access,18,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:37,Security,access,access,37,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:101,Security,access,access,101,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Security,access,access,14,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:55,Security,access,access,55,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:108,Security,access,access,108,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:33,Security,access,accesses,33,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:54,Security,access,accessed,54,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:173,Security,access,accesses,173,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:317,Security,access,accessed,317,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:383,Security,access,accesses,383,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:463,Security,access,access,463,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:71,Security,access,access,71,"// If the base object is of the least common type, then this may be an access; // to its subobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:10,Security,access,access,10,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:104,Security,access,access,104,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:315,Security,access,access,315,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:40,Security,access,access,40,// With new-format nodes we stop at the access type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:102,Security,access,access,102,"// If the base object has a direct or indirect field of the subobject's type,; // then this may be an access to that field. We need this to check now that; // we support aggregates as access types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:184,Security,access,access,184,"// If the base object has a direct or indirect field of the subobject's type,; // then this may be an access to that field. We need this to check now that; // we support aggregates as access types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:51,Security,access,accesses,51,"/// matchTags - Return true if the given couple of accesses are allowed to; /// overlap. If \arg GenericTag is not null, then on return it points to the; /// most generic access descriptor for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:171,Security,access,access,171,"/// matchTags - Return true if the given couple of accesses are allowed to; /// overlap. If \arg GenericTag is not null, then on return it points to the; /// most generic access descriptor for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3,Security,Access,Accesses,3,// Accesses with no TBAA information may alias with any other accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:62,Security,access,accesses,62,// Accesses with no TBAA information may alias with any other accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:60,Deployability,upgrade,upgrade,60,// Verify that both input nodes are struct-path aware. Auto-upgrade should; // have taken care of this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:16,Security,access,access,16,"// If the final access types have different roots, they're part of different; // potentially unrelated type systems, so we must be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:17,Security,access,accessed,17,"// If one of the accessed objects may be a subobject of the other, then such; // accesses may alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:81,Security,access,accesses,81,"// If one of the accessed objects may be a subobject of the other, then such; // accesses may alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:31,Security,access,access,31,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:78,Security,access,access,78,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Testability,Test,Test,14,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:183,Availability,error,errors,183,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:241,Performance,load,load,241,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:322,Performance,load,load,322,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:252,Security,access,access,252,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp:33,Performance,load,load,33,// Search for virtual calls that load from VPtr and add them to DevirtCalls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp:50,Testability,test,test,50,// Find llvm.assume intrinsics for this llvm.type.test call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:432,Performance,perform,performing,432,"//===-- ValueLatticeUtils.cpp - Utils for solving lattices ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements common functions useful for performing data-flow; // analyses that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:35,Modifiability,variab,variable,35,"// Currently all users of a global variable have to be non-volatile loads; // or stores of the global type, and the global cannot be stored itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:68,Performance,load,loads,68,"// Currently all users of a global variable have to be non-volatile loads; // or stores of the global type, and the global cannot be stored itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:402,Integrability,rout,routines,402,"//===- ValueTracking.cpp - Walk computations to compute properties --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help analyze properties that chains of; // computations have.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:34,Performance,scalab,scalable,34,"// Since the number of lanes in a scalable vector is unknown at compile time,; // we track one bit which is implicitly broadcast to all lanes. This means; // that all lanes in a scalable vector are considered demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:178,Performance,scalab,scalable,178,"// Since the number of lanes in a scalable vector is unknown at compile time,; // we track one bit which is implicitly broadcast to all lanes. This means; // that all lanes in a scalable vector are considered demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Availability,mask,mask,24,// Look for an inverted mask: (X & ~M) op (Y & M).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:16,Modifiability,extend,extends,16,// Peek through extends to find a 'not' of the other side:; // (ext Y) op ext(~Y),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Integrability,wrap,wrap,23,"// Only make use of no-wrap flags if we failed to compute the sign bit; // directly. This matters if the multiplication always overflows, in; // which case we prefer to follow the result of the direct computation,; // though as the program is invoking undefined behaviour we can choose; // whatever we like here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:177,Testability,test,test,177,// The instruction defining an assumption's condition itself is always; // considered ephemeral to that assumption (even if it has other; // non-ephemeral users). See r246696's test case for an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:256,Safety,avoid,avoid,256,"// The context comes first, but they're both in the same block.; // Make sure there is nothing in between that might interrupt; // the control flow, not even CxtI itself.; // We limit the scan distance between the assume and its context instruction; // to avoid a compile-time explosion. This limit is chosen arbitrarily, so; // it can be adjusted if needed (could be turned into a cl::opt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Performance,perform,performance,48,// Warning: This loop can end up being somewhat performance sensitive.; // We're running this loop for once for each value queried resulting in a; // runtime of ~O(#assumes * #values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:99,Testability,log,logic,99,"// Handle comparison of pointer to null explicitly, as it will not be; // covered by the m_APInt() logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V & Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Availability,Mask,Mask,19,"// For one bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V | Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,Availability,Mask,Mask,20,"// For zero bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V ^ Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Availability,Mask,Mask,29,// Equivalent to assume(V == Mask ^ C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:36,Energy Efficiency,power,power,36,// assume (V & B != 0) where B is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:94,Deployability,update,updateAffectedValues,94,// Note that the patterns below need to be kept in sync with the code; // in AssumptionCache::updateAffectedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Performance,perform,performance,48,// Warning: This loop can end up being somewhat performance sensitive.; // We're running this loop for once for each value queried resulting in a; // runtime of ~O(#assumes * #values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:160,Energy Efficiency,allocate,allocated,160,"/// Compute known bits from a shift operator, including those with a; /// non-constant shift amount. Known is the output of this function. Known2 is a; /// pre-allocated temporary with the same bit width as Known and on return; /// contains the known bit of the shift value source. KF is an; /// operator-specific function that, given the known-bits and a shift amount,; /// compute the implied known-bits of the shift operator's result respectively; /// for that shift amount. The results from calling KF are conservatively; /// combined for all permitted shift amounts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:41,Usability,clear,clear,41,"// and(x, -x) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: instcombine often reassociates independent `and` which can hide; // this pattern. Try to match and(x, and(-x, y)) / and(and(x, y), -x).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:118,Usability,clear,clear,118,"// and(x, -x) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: instcombine often reassociates independent `and` which can hide; // this pattern. Try to match and(x, and(-x, y)) / and(and(x, y), -x).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:318,Modifiability,Extend,Extend,318,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Usability,clear,clear,42,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:119,Usability,clear,clear,119,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:53,Usability,clear,clears,53,"// and(x, add (x, -1)) is a common idiom that always clears the low bit;; // xor/or(x, add (x, -1)) is an idiom that will always set the low bit.; // here we handle the more general case of adding any odd number by; // matching the form and/xor/or(x, add(x, y)) where y is odd.; // TODO: This could be generalized to clearing any bit set in y where the; // following bit is known to be unset in y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:317,Usability,clear,clearing,317,"// and(x, add (x, -1)) is a common idiom that always clears the low bit;; // xor/or(x, add (x, -1)) is an idiom that will always set the low bit.; // here we handle the more general case of adding any odd number by; // matching the form and/xor/or(x, add(x, y)) where y is odd.; // TODO: This could be generalized to clearing any bit set in y where the; // following bit is known to be unset in y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:34,Usability,Simpl,SimplifyDemandedUseBits,34,// Public so this can be used in `SimplifyDemandedUseBits`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:668,Availability,mask,mask,668,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:760,Integrability,depend,dependent,760,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Usability,clear,clear,48,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:49,Modifiability,variab,variable,49,// Accumulate the constant indices in a separate variable; // to minimize the number of calls to computeForAddSub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:7,Performance,scalab,scalable,7,// For scalable types the only thing we know about sizeof is; // that this is a multiple of the minimum size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:115,Modifiability,extend,extend,115,"// If the offsets have a different width from the pointer, according; // to the language reference we need to sign-extend or truncate them; // to the width of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Usability,simpl,simple,24,"// Handle the case of a simple two-predecessor recurrence PHI.; // There's a lot more that could theoretically be done here, but; // this is sufficient to catch some interesting cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:157,Safety,avoid,avoid,157,"// We have matched a recurrence of the form:; // %iv = [R, %entry], [%iv.next, %backedge]; // %iv.next = shift_op %iv, L; // Recurse with the phi context to avoid concern about whether facts; // inferred hold at original context instruction. TODO: It may be; // correct to use the original context. IF warranted, explore and; // add sufficient tests to cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:344,Testability,test,tests,344,"// We have matched a recurrence of the form:; // %iv = [R, %entry], [%iv.next, %backedge]; // %iv.next = shift_op %iv, L; // Recurse with the phi context to avoid concern about whether facts; // inferred hold at original context instruction. TODO: It may be; // correct to use the original context. IF warranted, explore and; // add sufficient tests to cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:27,Modifiability,extend,extend,27,// An ashr recurrence will extend the initial sign bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,avoid,avoid,100,"// Otherwise take the unions of the known bit sets of the operands,; // taking conservative care to avoid excessive recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Modifiability,extend,extend,11,// TODO: 1-extend would be more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:54,Performance,scalab,scalable,54,// FIXME: there's probably *something* we can do with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:207,Performance,optimiz,optimize,207,"/// Determine which bits of V are known to be either zero or one and return; /// them in the Known bit set.; ///; /// NOTE: we cannot consider 'undef' to be ""IsZero"" here. The problem is that; /// we cannot optimize based on the assumption that it is zero without changing; /// it to be an explicit zero. If we don't change it to zero, other code could; /// optimized based on the contradictory assumption that it is non-zero.; /// Because instcombine aggressively folds operations with undef args anyway,; /// this won't lose us code quality.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the demanded elements in the vector specified by DemandedElts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:358,Performance,optimiz,optimized,358,"/// Determine which bits of V are known to be either zero or one and return; /// them in the Known bit set.; ///; /// NOTE: we cannot consider 'undef' to be ""IsZero"" here. The problem is that; /// we cannot optimize based on the assumption that it is zero without changing; /// it to be an explicit zero. If we don't change it to zero, other code could; /// optimized based on the contradictory assumption that it is non-zero.; /// Because instcombine aggressively folds operations with undef args anyway,; /// this won't lose us code quality.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the demanded elements in the vector specified by DemandedElts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:89,Energy Efficiency,power,power,89,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:63,Modifiability,variab,variable,63,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Safety,detect,detect,11,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:27,Energy Efficiency,power,power,27,// Initial value must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:33,Modifiability,variab,variable,33,"// Except for Mul, the induction variable must be on the left side of the; // increment expression, otherwise its value can be arbitrary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Energy Efficiency,Power,Power,3,// Power of two is closed under multiplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:79,Energy Efficiency,power,power,79,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simply,60,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Energy Efficiency,power,power,21,"// Divisor must be a power of two.; // If OrZero is false, cannot guarantee induction variable is non-zero after; // division, same for Shr, unless it is exact division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:86,Modifiability,variab,variable,86,"// Divisor must be a power of two.; // If OrZero is false, cannot guarantee induction variable is non-zero after; // division, same for Shr, unless it is exact division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:154,Energy Efficiency,power,power,154,/// Return true if the given value is known to have exactly one; /// bit set when defined. For vectors return true if every element is known to; /// be a power of two when defined. Supports values with integer or pointer; /// types and vectors of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Energy Efficiency,power,power,25,// i1 is by definition a power of 2 or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Energy Efficiency,power,power-of-two,42,// The vscale_range indicates vscale is a power-of-two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Energy Efficiency,power,power,23,// 1 << X is clearly a power of two if the one is not shifted off the end. If; // it is shifted off the end then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:13,Usability,clear,clearly,13,// 1 << X is clearly a power of two if the one is not shifted off the end. If; // it is shifted off the end then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:33,Energy Efficiency,power,power,33,// (signmask) >>l X is clearly a power of two if the one is not shifted off; // the bottom. If it is shifted off the bottom then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Usability,clear,clearly,23,// (signmask) >>l X is clearly a power of two if the one is not shifted off; // the bottom. If it is shifted off the bottom then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,Energy Efficiency,power,power,5,// A power of two and'd with anything is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:43,Energy Efficiency,power,power,43,// A power of two and'd with anything is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Energy Efficiency,power,power,24,// X & (-X) is always a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Energy Efficiency,power,power-of-two,12,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:45,Energy Efficiency,power,power-of-two,45,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:97,Energy Efficiency,power,power-of-two,97,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:120,Energy Efficiency,power,power-of-two,120,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:16,Energy Efficiency,power,power,16,// If i8 V is a power of two or zero:; // ZeroBits: 1 1 1 0 1 1 1 1; // ~ZeroBits: 0 0 0 1 0 0 0 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Energy Efficiency,power,power,17,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:57,Energy Efficiency,power,power,57,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:143,Energy Efficiency,power,power,143,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Modifiability,variab,variable,100,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:51,Energy Efficiency,power,power,51,// Check if it is an induction variable and always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:31,Modifiability,variab,variable,31,// Check if it is an induction variable and always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Energy Efficiency,power,power,12,// Value is power of 2 if it is coming from PHI node itself by induction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:187,Integrability,rout,routine,187,/// Test whether a GEP's result is known to be non-null.; ///; /// Uses properties inherent in a GEP to try to determine whether it is known; /// to be non-null.; ///; /// Currently this routine does not support vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:4,Testability,Test,Test,4,/// Test whether a GEP's result is known to be non-null.; ///; /// Uses properties inherent in a GEP to try to determine whether it is known; /// to be non-null.; ///; /// Currently this routine does not support vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:187,Integrability,contract,contract,187,"// Walk the GEP operands and see if any operand introduces a non-zero offset.; // If so, then the GEP cannot produce a null pointer, as doing so would; // inherently violate the inbounds contract within address space zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,Availability,down,down,113,// Fast path the constant operand case both for efficiency and so we don't; // increment Depth when just zipping down an all-constant GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Safety,Avoid,Avoid,3,// Avoid massive lists,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Performance,load,load,29,"// If the value is used as a load/store, then the pointer must be non null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:237,Testability,log,logic,237,"// If a user is an AND, add all its users to the work list. We only; // propagate ""pred != null"" condition through AND because it is only; // correct to assume that all conditions of AND are met in true branch.; // TODO: Support similar logic of OR and EQ predicate?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:137,Modifiability,variab,variables,137,/// Try to detect a recurrence that monotonically increases/decreases from a; /// non-zero starting value. These are common as induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Safety,detect,detect,11,/// Try to detect a recurrence that monotonically increases/decreases from a; /// non-zero starting value. These are common as induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:64,Integrability,wrap,wrap,64,// Starting from non-zero and stepping away from zero can never wrap back; // to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Energy Efficiency,power,power,42,// The sum of a non-negative number and a power of two is not zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:223,Safety,Unsafe,Unsafe,223,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:494,Safety,Unsafe,Unsafe,494,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:855,Safety,Safe,Safe,855,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:927,Safety,safe,safe,927,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:45,Safety,avoid,avoid,45,"// Note that we have to take special care to avoid looking through; // truncating casts, e.g., int2ptr/ptr2int with appropriate sizes, as well; // as casts that can alter the value, e.g., AddrSpaceCasts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:95,Modifiability,extend,extend,95,"// Similar to int2ptr above, we can look through ptr2int here if the cast; // is a no-op or an extend and not a truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Integrability,wrap,wrap,29,"// X + Y.; // If Add has nuw wrap flag, then if either X or Y is non-zero the result is; // non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,Performance,Load,Load,5,// A Load tagged with nonnull or dereferenceable with null pointer undefined; // is never null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:252,Performance,perform,perform,252,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every demanded element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:32,Testability,test,test,32,// Must be non-zero due to null test above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Modifiability,variab,variable,12,"// A global variable in address space 0 is non null unless extern weak; // or an absolute symbol reference. Other address spaces may have null as a; // valid address for a global, so we can't assume anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Testability,test,tests,15,"// Some of the tests below are recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Usability,simpl,simplifications,21,// Check for pointer simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Testability,log,log,21,"// sdiv X, C -> adds log(C) sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:13,Testability,log,log,13,// Add floor(log(C)) bits to the numerator bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:28,Testability,Log,Logical,28,// NOT is handled here.; // Logical binary ops preserve the number of sign bits at the worst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:63,Usability,clear,clear,63,"// If the input is known to be positive (the sign bit is known clear),; // the output of the NEG has the same number of sign bits as the; // input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:226,Modifiability,extend,extended,226,"// Look through extract element. At the moment we keep this simple and; // skip tracking the specific element. But at least we might find; // information valid for all elements of the vector (for example if vector; // is sign extended, shifted, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simple,60,"// Look through extract element. At the moment we keep this simple and; // skip tracking the specific element. But at least we might find; // information valid for all elements of the vector (for example if vector; // is sign extended, shifted, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,reduce,reduces,18,// Absolute value reduces number of sign bits by at most 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:138,Availability,avail,available,138,// We are going to infer semantics of a library function based on mapping it; // to an LLVM intrinsic. Check that the library function is available from; // this callbase and in this environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:86,Testability,test,test,86,"/// Deprecated, use computeKnownFPClass instead.; ///; /// If \p SignBitOnly is true, test for a known 0 sign bit rather than a; /// standard ordered compare. e.g. make -0.0 olt 0.0 be true because of the sign; /// bit despite comparing equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simple,60,// Look through extract element. At the moment we keep this simple and skip; // tracking the specific element. But at least we might find information; // valid for all elements of the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:131,Availability,mask,masks,131,// Compares with fcNone are only exactly equal to fcZero if input denormals; // are not flushed.; // TODO: Handle DAZ by expanding masks to cover subnormal cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,Availability,mask,mask,20,// Compute the test mask that would return true for the ordered comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Testability,test,test,15,// Compute the test mask that would return true for the ordered comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Testability,test,test,50,// First see if we can fold in fabs/fneg into the test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Testability,log,log,3,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Testability,log,log,25,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Testability,log,log,50,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:71,Testability,log,log,71,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,power,power,18,"// If we know the power is <= 0, can't introduce inf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,power,power,18,"// If we know the power is >= 0, can't introduce subnormal or zero",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,avoid,avoid,100,"// Otherwise take the unions of the known bit sets of the operands,; // taking conservative care to avoid excessive recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:147,Safety,detect,detect,147,"// Recurse, but cap the recursion to two levels, because we don't want; // to waste time spinning around in loops. We need at least depth 2 to; // detect known sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:57,Modifiability,variab,variables,57,"// All byte-wide stores are splatable, even of arbitrary variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate some space to put the new indices in,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:85,Performance,load,load,85,"// Otherwise, we don't know (such as, extracting from a function return value; // or load instruction)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:9,Availability,down,down,9,"// Drill down into the pointer expression V, ignoring any intervening; // casts, and determine the identity of the object it references along; // with the cumulative byte offset into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:90,Usability,Simpl,Simply,90,// Off/StartIdx is in the unit of bytes. So we need to convert to number of; // elements. Simply bail out if that isn't possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:232,Safety,detect,detecting,232,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:216,Security,sanitiz,sanitizers,216,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,Usability,simpl,simpler,113,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:284,Availability,failure,failure,284,"/// Extract bytes from the initializer of the constant array V, which need; /// not be a nul-terminated string. On success, store the bytes in Str and; /// return true. When TrimAtNul is set, Str will contain only the bytes up; /// to but not including the first nul. Return false on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:71,Safety,safe,safe,71,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:331,Security,sanitiz,sanitizers,331,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:97,Usability,Simpl,SimplifyLibcalls,97,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:110,Deployability,integrat,integrate,110,"// These next two are very similar to the above, but also look through PHI; // nodes.; // TODO: See if we can integrate these two together.; /// If we can compute the length of the string pointed to by; /// the specified pointer, return 'len+1'. If we can't, return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:110,Integrability,integrat,integrate,110,"// These next two are very similar to the above, but also look through PHI; // nodes.; // TODO: See if we can integrate these two together.; /// If we can compute the length of the string pointed to by; /// the specified pointer, return 'len+1'. If we can't, return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:107,Safety,safe,safe,107,"// Search for the first nul character. Return a conservative result even; // when there is no nul. This is safe since otherwise the string function; // being folded such as strlen is undefined, and can be preferable to; // making the undefined library call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:361,Performance,load,loads,361,"// The amdgcn_make_buffer_rsrc function does not alter the address of the; // input pointer (and thus preserve null-ness for the purposes of escape; // analysis, which is where the MustPreserveNullness flag comes in to play).; // However, it will not necessarily map ptr addrspace(N) null to ptr; // addrspace(8) null, aka the ""null descriptor"", which has ""all loads return; // 0, all stores are dropped"" semantics. Given the context of this intrinsic; // list, no one should be relying on such a strict interpretation of; // MustPreserveNullness (and, at time of writing, they are not), but we; // document this fact out of an abundance of caution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Performance,load,loaded,23,"// If a new pointer is loaded in the loop, the pointer references a different; // object in every iteration. E.g.:; // for (i); // int *p = a[i];; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getUnderlyingObjects and adds support for basic; /// ptrtoint+arithmetic+inttoptr sequences.; /// It returns false if unidentified object is found in getUnderlyingObjects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:115,Safety,safe,safety,115,"// If getUnderlyingObjects fails to find an identifiable object,; // getUnderlyingObjectsForCodeGen also fails for safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Performance,load,load,15,// Speculative load may create a race that did not exist in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Performance,load,load,15,// Speculative load may load data from dirty regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Performance,load,load,24,// Speculative load may load data from dirty regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:8,Safety,safe,safe,8,// It's safe to hoist if the denominator is not 0 or -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:59,Safety,safe,safe,59,// At this point we know that the denominator is -1. It is safe to hoist as; // long we know that the numerator is not INT_MIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:10,Integrability,depend,dependency,10,// Memory dependency possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:136,Safety,safe,safe,136,"// 1) Can't reorder two inf-loop calls, even if readonly; // 2) Also can't reorder an inf-loop call below a instruction which isn't; // safe to speculative execute. (Inverse of above)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:188,Usability,simpl,simplicity,188,// It overflows only when both arguments are negative and the true; // product is exactly the minimum negative number.; // E.g. mul i16 with 17 sign bits: 0xff00 * 0xff80 = 0x8000; // For simplicity we just check if at least one side is not negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:38,Availability,avail,available,38,// The remaining code needs Add to be available. Early returns if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,Usability,simpl,simplify,180,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nuw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.; // TODO: There are other patterns like this.; // See simplifyICmpWithBinOpOnLHS() for candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:412,Usability,simpl,simplifyICmpWithBinOpOnLHS,412,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nuw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.; // TODO: There are other patterns like this.; // See simplifyICmpWithBinOpOnLHS() for candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,Usability,simpl,simplify,180,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nsw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:49,Integrability,wrap,wrap,49,// Check if all users of the add are provably no-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:39,Safety,safe,safe,39,"// Can't tell, just return false to be safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:268,Energy Efficiency,allocate,allocated,268,"// Strip cast operations from a pointer value.; // Note that stripPointerCastsSameRepresentation can strip off getelementptr; // inbounds with zero offset. To guarantee that the result isn't poison, the; // stripped pointer is checked as it has to be pointing into an allocated; // object or be null `null` to ensure `inbounds` getelement pointers with a; // zero offset could not produce poison.; // It can strip off addrspacecast that do not change bit representation as; // well. We believe that such addrspacecast is equivalent to no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,Safe,Safe,100,"// If we can't analyze propagation through this instruction, just skip it; // and transitive users. Safe as false is a conservative result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:40,Testability,test,test,40,"// For CoreCLR, it just involves a type test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:47,Safety,avoid,avoid,47,"// Limit number of instructions we look at, to avoid scanning through large; // blocks. The current limit is chosen arbitrarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:176,Modifiability,extend,extended,176,"/// If the input value is the result of a 'not' op, constant integer, or vector; /// splat of a constant integer, return the bitwise-not source value.; /// TODO: This could be extended to handle non-splat vector integer constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Usability,clear,clear,19,// Is the sign bit clear?; // (X >s -1) ? MINVAL : X ==> (X <u MINVAL) ? MINVAL : X ==> UMAX; // (X >s -1) ? X : MINVAL ==> (X <u MINVAL) ? X : MINVAL ==> UMIN,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:121,Usability,simpl,simple,121,"// When given one NaN and one non-NaN input:; // - maxnum/minnum (C99 fmaxf()/fminf()) return the non-NaN input.; // - A simple C99 (a < b ? a : b) construction will return 'b' (as the; // ordered comparison fails), which could be NaN or non-NaN.; // so here we discover exactly what NaN behavior is required/accepted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:8,Modifiability,extend,extending,8,"// Sign-extending LHS does not change its sign, so TrueVal/FalseVal can; // match against either LHS or sext(LHS).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:793,Security,access,accessed,793,"/// Helps to match a select pattern in case of a type mismatch.; ///; /// The function processes the case when type of true and false values of a; /// select instruction differs from type of the cmp instruction operands because; /// of a cast instruction. The function checks if it is legal to move the cast; /// operation after ""select"". If yes, it returns the new second value of; /// ""select"" (with the assumption that cast is moved):; /// 1. As operand of cast instruction when both values of ""select"" are same cast; /// instructions.; /// 2. As restored constant (by applying reverse cast operation) when the first; /// value of the ""select"" is a cast operation and the second value is a; /// constant.; /// NOTE: We return only the new second value because the first value could be; /// accessed as operand of cast instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:353,Modifiability,extend,extended,353,"// Here we have the following case:; //; // %cond = cmp iN %x, CmpConst; // %tr = trunc iN %x to iK; // %narrowsel = select i1 %cond, iK %t, iK C; //; // We can always move trunc after select operation:; //; // %cond = cmp iN %x, CmpConst; // %widesel = select i1 %cond, iN %x, iN CmpConst; // %tr = trunc iN %widesel to iK; //; // Note that C could be extended in any way because we don't care about; // upper bits after truncation. It can't be abs pattern, because it would; // look like:; //; // select i1 %cond, x, -x.; //; // So only min/max pattern could be matched. Such match requires widened C; // == CmpConst. That is why set widened C = CmpConst, condition trunc; // CmpConst == C is checked below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Usability,simpl,simple,24,"// Handle the case of a simple two-predecessor recurrence PHI.; // There's a lot more that could theoretically be done here, but; // this is sufficient to catch some interesting cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Testability,log,logic,19,"// The rest of the logic assumes the LHS condition is true. If that's not the; // case, invert the predicate to make it so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:105,Usability,Simpl,SimplifyQuery,105,"// TODO: This is a poor/cheap way to determine dominance. Should we use a; // dominator tree (eg, from a SimplifyQuery) instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Usability,simpl,simplified,25,// The branch should get simplified. Don't bother simplifying this condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Usability,simpl,simplifying,50,// The branch should get simplified. Don't bother simplifying this condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Integrability,wrap,wraps,100,"// If the caller expects a signed compare, then try to use a signed range.; // Otherwise if both no-wraps are set, use the unsigned range because it; // is never larger than the signed range. Example:; // ""add nuw nsw i8 X, -2"" is unsigned [254,255] vs. signed [-128, 125].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Energy Efficiency,power,power,15,// X & -X is a power of two or zero. So we can cap the value at max power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:68,Energy Efficiency,power,power,68,// X & -X is a power of two or zero. So we can cap the value at max power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Usability,clear,clear,18,// Maximum of set/clear bits is the bit width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:45,Security,access,access,45,/// Maximum factor for an interleaved memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:58,Security,access,access,58,"// For fixed-length vector, return undef for out of range access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:29,Modifiability,variab,variable,29,"// If this is an insert to a variable element, we don't know what it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:30,Availability,mask,mask,30,// Ignore invalid (undefined) mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,Availability,mask,mask,36,// There can be only 1 non-negative mask element value if this is a splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:54,Availability,mask,mask,54,// Initialize the splat index to the 1st non-negative mask element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:94,Availability,mask,mask,94,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Safety,safe,safely,17,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:33,Availability,mask,mask,33,// Match a specific element. The mask should be defined at and match the; // specified index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Usability,Simpl,Simple,3,// Simple case of a shuffle with zeroinitializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:37,Availability,down,down,37,// We must map the original elements down evenly to a type with less elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,Availability,mask,mask,26,// Step through the input mask by splitting into Scale-sized slices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:14,Availability,mask,mask,14,// A positive mask element must be cleanly divisible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:32,Availability,mask,mask,32,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:51,Availability,down,down,51,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:88,Availability,mask,mask,88,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:135,Availability,mask,mask,135,// Try to perform better estimation of the permutation.; // 1. Split the source/destination vectors into real registers.; // 2. Do the mask analysis to identify which real registers are; // permuted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Performance,perform,perform,10,// Try to perform better estimation of the permutation.; // 1. Split the source/destination vectors into real registers.; // 2. Do the mask analysis to identify which real registers are; // permuted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// Process split mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// Find the only mask with at least single undef mask elem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:49,Availability,mask,mask,49,// Find the only mask with at least single undef mask elem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Availability,mask,mask,13,"// The first mask is a permutation of a single register. Since we have >2; // input registers to shuffle, we merge the masks for 2 first registers; // and generate a shuffle of 2 registers rather than the reordering of the; // first register and then shuffle with the second register. Next,; // generate the shuffles of the resulting register + the remaining; // registers from the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Availability,mask,masks,119,"// The first mask is a permutation of a single register. Since we have >2; // input registers to shuffle, we merge the masks for 2 first registers; // and generate a shuffle of 2 registers rather than the reordering of the; // first register and then shuffle with the second register. Next,; // generate the shuffles of the resulting register + the remaining; // registers from the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:49,Performance,load,loaded,49,"// Don't make work for ourselves. If we know the loaded type is legal,; // don't add it to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Performance,load,loads,10,"// Casts, loads and instructions outside of our range terminate a chain; // successfully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Safety,Unsafe,Unsafe,3,"// Unsafe casts terminate a chain unsuccessfully. We can't do anything; // useful with bitcasts, ptrtoints or inttoptrs and it'd be unsafe to; // transform anything that relies on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:132,Safety,unsafe,unsafe,132,"// Unsafe casts terminate a chain unsuccessfully. We can't do anything; // useful with bitcasts, ptrtoints or inttoptrs and it'd be unsafe to; // transform anything that relies on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:118,Performance,optimiz,optimize,118,"// Now we've discovered all values, walk them to see if there are; // any users we didn't see. If there are, we can't optimize that; // chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Energy Efficiency,power,power,17,// Round up to a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:75,Performance,perform,performed,75,// If any of M's operands demand more bits than MinBW then M cannot be; // performed safely in MinBW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:85,Safety,safe,safely,85,// If any of M's operands demand more bits than MinBW then M cannot be; // performed safely in MinBW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:12,Security,access,access,12,/// Add all access groups in @p AccGroups to @p List.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:16,Security,access,access,16,// Interpret an access group as a list containing itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:15,Performance,scalab,scalable,15,// Use set for scalable 'contains' check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// All 1's means mask is not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,Security,access,access,26,// TODO: support reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Safety,Avoid,Avoid,3,// Avoid casts in the loop and make sure we have a reasonable number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Availability,mask,mask,10,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:125,Availability,mask,mask,125,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,Energy Efficiency,reduce,reduce,50,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Modifiability,Extend,Extend,3,// Extend with UNDEFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:31,Performance,load,load,31,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:268,Performance,load,load,268,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:320,Performance,load,load,320,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:355,Performance,load,load,355,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:112,Security,access,access,112,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:373,Security,Access,AccessStrideInfo,373,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:18,Integrability,wrap,wrapping,18,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:129,Integrability,wrap,wrapping,129,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:257,Integrability,wrap,wrapping,257,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:301,Integrability,wrap,wrap,301,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:411,Integrability,wrap,wrapping,411,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:352,Security,access,access,352,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:455,Integrability,depend,dependences,455,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:582,Integrability,depend,dependences,582,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:621,Integrability,depend,dependence,621,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:866,Integrability,depend,dependences,866,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1329,Integrability,depend,dependences,1329,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1368,Integrability,depend,dependence,1368,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1564,Integrability,depend,dependent,1564,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1721,Integrability,depend,dependences,1721,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:66,Performance,load,load,66,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:141,Performance,load,load,141,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:182,Performance,load,loads,182,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:230,Performance,load,load,230,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:409,Performance,load,load,409,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:746,Performance,load,load,746,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:23,Security,access,accesses,23,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:991,Security,access,accesses,991,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1155,Security,access,accesses,1155,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1193,Security,access,accesses,1193,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1618,Security,access,accesses,1618,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1236,Usability,simpl,simplify,1236,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Security,access,accesses,13,// Holds all accesses with a constant stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:15,Integrability,depend,dependences,15,// Collect the dependences in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:25,Performance,load,load,25,// Holds all interleaved load groups temporarily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:578,Integrability,depend,dependences,578,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:99,Performance,load,load,99,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,Security,access,accesses,50,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:145,Security,access,access,145,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:167,Security,access,access,167,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:183,Integrability,depend,dependences,183,"// Initialize a group for B if it has an allowable stride. Even if we don't; // create a group for B, we continue with the bottom-up algorithm to ensure; // we don't break any of B's dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:55,Integrability,depend,dependences,55,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:322,Integrability,depend,dependences,322,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:455,Integrability,depend,dependent,455,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:753,Integrability,depend,dependent,753,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:827,Integrability,depend,dependent,827,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:387,Modifiability,extend,extend,387,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,Security,access,accesses,79,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:122,Security,access,accesses,122,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:293,Security,access,accesses,293,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:345,Security,access,accesses,345,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:465,Security,access,accesses,465,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:527,Security,access,accesses,527,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:728,Security,access,accesses,728,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:837,Security,access,access,837,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,Availability,toler,tolerable,36,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:19,Integrability,depend,dependencies,19,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:163,Integrability,depend,dependencies,163,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Performance,load,load,13,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:192,Deployability,release,release,192,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:126,Integrability,depend,dependency,126,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:18,Performance,load,load,18,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:101,Performance,load,load,101,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:290,Performance,load,load,290,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:376,Performance,load,load,376,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:99,Deployability,Release,Release,99,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Integrability,depend,dependence,17,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:45,Performance,load,load,45,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:142,Integrability,Depend,DependentInst,142,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Performance,load,load,13,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:62,Performance,load,loads,62,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:93,Deployability,release,released,93,"// Skip trying to add A to B, continue to look for other conflicting A's; // in groups to be released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:197,Performance,load,loads,197,"// Ignore A if it's already in a group or isn't the same kind of memory; // operation as B.; // Note that mayReadFromMemory() isn't mutually exclusive to; // mayWriteToMemory in the case of atomic loads. We shouldn't see those; // here, canVectorizeMemory() should have returned false - except for the; // case we asked for optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:324,Performance,optimiz,optimization,324,"// Ignore A if it's already in a group or isn't the same kind of memory; // operation as B.; // Note that mayReadFromMemory() isn't mutually exclusive to; // mayWriteToMemory in the case of atomic loads. We shouldn't see those; // here, canVectorizeMemory() should have returned false - except for the; // case we asked for optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Performance,load,load,17,// Set the first load in program order as the insert position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,Security,access,accesses,20,// Iteration over A accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,Security,access,accesses,20,// Iteration over B accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:69,Integrability,wrap,wrap,69,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:221,Integrability,wrap,wrapping,221,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:588,Integrability,wrap,wrap,588,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:649,Integrability,wrap,wrap,649,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:767,Integrability,wrap,wrap,767,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:489,Performance,optimiz,optimizations,489,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Security,access,accesses,56,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:90,Integrability,wrap,wrap,90,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,Performance,load,load,79,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:141,Security,access,access,141,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Integrability,wrap,wrap,56,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and group member Factor - 1; If the latter doesn't exist we rely on; // peeling (if it is a non-reversed accsess -- see Case 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Integrability,wrap,wrap,119,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and group member Factor - 1; If the latter doesn't exist we rely on; // peeling (if it is a non-reversed accsess -- see Case 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:38,Performance,load,load,38,"// Case 3: A non-reversed interleaved load group with gaps: We need; // to execute at least one scalar epilogue iteration. This will ensure; // we don't speculatively access memory out-of-bounds. We only need; // to look for a member at index factor - 1, since every group must have; // a member at index zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:167,Security,access,access,167,"// Case 3: A non-reversed interleaved load group with gaps: We need; // to execute at least one scalar epilogue iteration. This will ensure; // we don't speculatively access memory out-of-bounds. We only need; // to look for a member at index factor - 1, since every group must have; // a member at index zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:91,Integrability,wrap,wrap,91,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // store would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:142,Security,access,access,142,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // store would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:57,Availability,mask,masked,57,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:129,Availability,mask,masked-interleaved-accesses,129,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:148,Security,access,accesses,148,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:323,Availability,mask,masked-store,323,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Integrability,wrap,wrap,56,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Integrability,wrap,wrap,119,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:379,Performance,load,loads,379,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:365,Security,access,access,365,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Deployability,Release,Release,3,// Release groups requiring scalar epilogues. Note that this also removes them; // from InterleaveGroups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:176,Testability,mock,mock,176,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:201,Testability,mock,mock,201,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:30,Modifiability,variab,variable,30,# We have to set this useless variable in order for the TF C API to correctly; # intake it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. ; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. ; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:24,Testability,mock,mock,24,"## By construction, the mock model will always output the first liverange that can be evicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:30,Modifiability,variab,variable,30,# We have to set this useless variable in order for the TF C API to correctly; # intake it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:15,Testability,test,testing,15,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:73,Testability,test,tests,73,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:206,Testability,test,tests,206,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:358,Testability,test,test,358,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:405,Testability,test,test,405,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:702,Testability,test,testing,702,"""""""Host the compiler.; Args:; temp_rootname: the base file name from which to construct the 2 pipes for; communicating with the compiler.; make_response: a function that, given the current tensor values, provides a; response.; process_and_args: the full commandline for the compiler. It it assumed it; contains a flag poiting to `temp_rootname` so that the InteractiveModeRunner; would attempt communication on the same pair as this function opens. This function sets up the communication with the compiler - via 2 files named; `temp_rootname`.in and `temp_rootname`.out - prints out the received features,; and sends back to the compiler an advice (which it gets from `make_response`).; It's used for testing, and also to showcase how to set up communication in an; interactive ML (""gym"") environment.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py:23,Testability,log,log,23,"""""""Reader for training log. See lib/Analysis/TrainingLogger.cpp for a description of the format.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:321,Availability,error,error,321,"//===----------------------------------------------------------------------===//; // Helper functions.; //===----------------------------------------------------------------------===//; // atoull - Convert an ascii string of decimal digits into the unsigned long; // long representation... this does not have to do input error checking,; // because we know that the input will be matched by a suitable regex...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:20,Safety,detect,detected,20,"// Uh, oh, overflow detected!!!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:20,Safety,detect,detected,20,"// Uh, oh, overflow detected!!!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:56,Modifiability,variab,variable,56,/// ReadVarName - Read the rest of a token containing a variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:103,Availability,Error,Error,103,"// Lex an ID: [0-9]+. On success, the ID is stored in UIntVal and Token is; // returned, otherwise the Error token is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:91,Safety,avoid,avoid,91,// Check for [us]0x[0-9A-Fa-f]+ which are Hexadecimal constant generated by; // the CFE to avoid forcing it to deal with 64-bit numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:30,Availability,error,error,30,"// Bad token, return it as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:43,Availability,error,error,43,"// Finally, if this isn't known, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:30,Availability,error,error,30,"// Bad token, return it as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:25,Energy Efficiency,Power,PowerPC,25,// PPC128HexFPConstant - PowerPC 128-bit in hexadecimal format (16 bytes),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Safety,safe,safe,34,// White-list intrinsics that are safe to drop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:46,Integrability,wrap,wrappers,46,// Also remove no longer used MetadataAsValue wrappers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:4,Security,validat,validateEndOfModule,4,/// validateEndOfModule - Do final validity and basic correctness checks at the; /// end of the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:115,Availability,error,error,115,// Don't do anything if the intrinsic is called with different function; // types. This would result in a verifier error anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:61,Deployability,upgrade,upgraded,61,// Look for intrinsic functions and CallInst that need to be upgraded. We use; // make_early_inc_range here because we may remove some functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:75,Security,validat,validated,75,"// Initialize the slot mapping.; // Because by this point we've parsed and validated everything, we can ""steal""; // the mapping from LLParser as it doesn't need it anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:184,Modifiability,variab,variable,184,/// parseUnnamedGlobal:; /// OptionalVisibility (ALIAS | IFUNC) ...; /// OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable; /// GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:384,Modifiability,variab,variable,384,/// parseUnnamedGlobal:; /// OptionalVisibility (ALIAS | IFUNC) ...; /// OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable; /// GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:210,Modifiability,variab,variable,210,/// parseNamedGlobal:; /// GlobalVar '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:133,Testability,log,logic,133,"// parse DIExpressions inline as a special case. They are still MDNodes,; // so they can still appear in named metadata. Remove this logic if they; // become plain Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Availability,error,error,17,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:3,Safety,Detect,Detect,3,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:96,Availability,down,down,96,"// Now walk through the parenthesized entry, until the number of open; // parentheses goes back down to 0 (the first '(' was parsed above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:39,Deployability,update,update,39,"// If there was an explicit dso_local, update GV. In the absence of an explicit; // dso_local we keep the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:118,Integrability,Rout,Routines,118,//===----------------------------------------------------------------------===//; // GlobalValue Reference/Resolution Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:113,Integrability,Rout,Routines,113,//===----------------------------------------------------------------------===//; // Comdat Reference/Resolution Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:309,Availability,error,error,309,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:326,Availability,failure,failure,326,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:92,Integrability,Rout,Routines,92,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:30,Availability,mask,masks,30,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:56,Availability,error,errors,56,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:39,Safety,avoid,avoid,39,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:90,Integrability,synchroniz,synchronization,90,"/// parseScope; /// ::= syncscope(""singlethread"" | ""<target scope>"")?; ///; /// This sets synchronization scope ID to the ID of the parsed value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:15,Availability,error,error,15,// Give a nice error for 'ptr*'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Usability,clear,clear,34,"// This type is being defined, so clear the location to indicate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Usability,clear,clear,34,"// This type is being defined, so clear the location to indicate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:135,Availability,error,error,135,"// The only other kind of parameter we support is type parameters, which; // must precede the integer parameters. This is therefore an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:94,Deployability,install,installs,94,"/// setInstName - After an instruction is parsed and inserted into its; /// basic block, this installs its name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:103,Availability,error,error,103,"/// defineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Modifiability,variab,variable,17,// Make a global variable as a placeholder for this reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:29,Modifiability,variab,variable,29,// Make a placeholder global variable as a placeholder for this reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:100,Security,checksum,checksumkind,100,"/// parseDIFileType:; /// ::= !DIFileType(filename: ""path/to/file"", directory: ""/path/to/dir"",; /// checksumkind: CSK_MD5,; /// checksum: ""000102030405060708090a0b0c0d0e0f"",; /// source: ""source file contents"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:128,Security,checksum,checksum,128,"/// parseDIFileType:; /// ::= !DIFileType(filename: ""path/to/file"", directory: ""/path/to/dir"",; /// checksumkind: CSK_MD5,; /// checksum: ""000102030405060708090a0b0c0d0e0f"",; /// source: ""source file contents"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:37,Security,checksum,checksumkind,37,"// The default constructed value for checksumkind is required, but will never; // be used, as the parser checks if the field was actually Seen before using; // the Val.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:69,Modifiability,config,configMacros,69,"/// parseDIModule:; /// ::= !DIModule(scope: !0, name: ""SomeModule"", configMacros:; /// ""-DNDEBUG"", includePath: ""/usr/include"", apinotes: ""module.apinotes"",; /// file: !1, line: 4, isDecl: false)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:26,Usability,resume,resume,26,/// parseResume; /// ::= 'resume' TypeAndValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:24,Performance,load,load,24,"/// parseLoad; /// ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?; /// ::= 'load' 'atomic' 'volatile'? TypeAndValue; /// 'singlethread'? AtomicOrdering (',' 'align' i32)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Performance,load,load,84,"/// parseLoad; /// ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?; /// ::= 'load' 'atomic' 'volatile'? TypeAndValue; /// 'singlethread'? AtomicOrdering (',' 'align' i32)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:3,Deployability,Update,Update,3,// Update consistency checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:73,Security,hash,hash,73,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:83,Security,Hash,Hash,83,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:97,Security,Hash,Hash,97,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Deployability,update,update,55,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Usability,GUID,GUIDs,84,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:151,Deployability,update,update,151,"// Keep track of the TypeIdCompatibleVtableInfo array index needing a; // forward reference. We will save the location of the ValueInfo needing an; // update, but can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:46,Safety,safe,safe,46,"// Now that the TI vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Deployability,update,update,55,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Usability,GUID,GUIDs,84,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:80,Deployability,update,updates,80,/// Stores the given Name/GUID and associated summary into the Index.; /// Also updates any forward references to the associated entry ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:26,Usability,GUID,GUID,26,/// Stores the given Name/GUID and associated summary into the Index.; /// Also updates any forward references to the associated entry ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:52,Usability,GUID,GUID,52,// First create the ValueInfo utilizing the Name or GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:14,Deployability,continuous,continuous,14,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:42,Testability,test,test,42,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:47,Usability,simpl,simplification,47,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:182,Modifiability,Variab,VariableSummary,182,"/// parseGVEntry; /// ::= 'gv' ':' '(' ('name' ':' STRINGCONSTANT | 'guid' ':' UInt64); /// [',' 'summaries' ':' Summary[',' Summary]* ]? ')'; /// Summary ::= '(' (FunctionSummary | VariableSummary | AliasSummary) ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:69,Usability,guid,guid,69,"/// parseGVEntry; /// ::= 'gv' ':' '(' ('name' ':' STRINGCONSTANT | 'guid' ':' UInt64); /// [',' 'summaries' ':' Summary[',' Summary]* ]? ')'; /// Summary ::= '(' (FunctionSummary | VariableSummary | AliasSummary) ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:16,Usability,GUID,GUID,16,// Can't create GUID/ValueInfo until we have the linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Integrability,Wrap,Wrap,17,// No summaries. Wrap up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:72,Usability,GUID,GUID,72,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:130,Usability,GUID,GUID,130,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:190,Usability,GUID,GUID,190,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:294,Usability,GUID,GUID,294,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:4,Modifiability,Variab,VariableSummary,4,"/// VariableSummary; /// ::= 'variable' ':' '(' 'module' ':' ModuleReference ',' GVFlags; /// [',' OptionalRefs]? ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:30,Modifiability,variab,variable,30,"/// VariableSummary; /// ::= 'variable' ':' '(' 'module' ':' ModuleReference ',' GVFlags; /// [',' OptionalRefs]? ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the Call array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:49,Safety,safe,safe,49,"// Now that the Calls vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:132,Deployability,update,update,132,"// Keep track of the VTableFuncs array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Safety,safe,safe,55,"// Now that the VTableFuncs vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:43,Safety,safe,safe,43,"// Now that the Params is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the Refs array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:48,Safety,safe,safe,48,"// Now that the Refs vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the TypeTests array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:109,Usability,GUID,GUID,109,"// Keep track of the TypeTests array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Safety,safe,safe,53,"// Now that the TypeTests vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Safety,safe,safe,55,"// Now that the VFuncIdList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:58,Safety,safe,safe,58,"// Now that the ConstVCallList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Usability,guid,guid,53,"/// VFuncId; /// ::= 'vFuncId' ':' '(' (SummaryID | 'guid' ':' UInt64) ','; /// 'offset' ':' UInt64 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:115,Deployability,update,update,115,"// Keep track of the array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the caller's std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:99,Usability,GUID,GUID,99,"// Keep track of the array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the caller's std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:130,Deployability,update,update,130,"// Keep track of the Callsites array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the SmallVector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Safety,safe,safe,53,"// Now that the Callsites vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp:3,Security,Access,Accessibility,3,// Accessibility codes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:19,Integrability,wrap,wraper,19,// 0x0B17C0DE = BC wraper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC Windows,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:19,Testability,stub,stub,19,"// Possible MS-DOS stub on Windows PE file, MSF/PDB file or a; // Minidump file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:419,Security,expose,exposes,419,"//===-- MsgPackDocument.cpp - MsgPack Document --------------------------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:429,Usability,simpl,simple,429,"//===-- MsgPackDocument.cpp - MsgPack Document --------------------------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode. The string data must remain valid for the; /// lifetime of the Document.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode for integer key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:31,Modifiability,extend,extends,31,/// Array element access. This extends the array if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:18,Security,access,access,18,/// Array element access. This extends the array if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:293,Safety,avoid,avoid,293,"// Convenience assignment operators. This only works if the destination; // DocNode has an associated Document, i.e. it was not constructed using the; // default constructor. The string one does not copy, so the string must; // remain valid for the lifetime of the Document. Use fromString to avoid; // that restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:510,Availability,error,error,510,"// Read a document from a binary msgpack blob, merging into anything already in; // the Document.; // The blob data must remain valid for the lifetime of this Document (because a; // string object in the document contains a StringRef into the original blob).; // If Multi, then this sets root to an array and adds top-level objects to it.; // If !Multi, then it only reads a single top-level object, even if there are; // more, and sets root to that.; // Returns false if failed due to illegal format or merge error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:24,Availability,Error,Error,24,// FIXME: Propagate the Error to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:56,Integrability,interface,interface,56,"//===-- MsgPackDocumentYAML.cpp - MsgPack Document YAML interface -------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// This file implements YAMLIO on a msgpack::Document.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:3,Availability,Toler,Tolerate,3,"// Tolerate signedness of int changing, as tags do not differentiate between; // them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:63,Availability,failure,failure,63,/// Read YAML text into the MsgPack document. Returns false on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp:419,Integrability,Message,MessagePack,419,"//===- MsgPackReader.cpp - Simple MsgPack reader ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack reader.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp:27,Usability,Simpl,Simple,27,"//===- MsgPackReader.cpp - Simple MsgPack reader ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack reader.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp:419,Integrability,Message,MessagePack,419,"//===- MsgPackWriter.cpp - Simple MsgPack writer ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack writer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp:27,Usability,Simpl,Simple,27,"//===- MsgPackWriter.cpp - Simple MsgPack writer ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack writer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:23,Testability,test,test,23,"// TODO: need to add a test case for ""Unknown"" and other SMC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:340,Availability,avail,available,340,"// In the function PPCFunctionInfo::getParmsType(), when there are no vector; // parameters, the 31st bit of ParmsType is always zero even if it indicates a; // floating point parameter. The parameter type information is lost. There; // are only 8 GPRs used for parameters passing, the floating parameters; // also occupy GPRs if there are available, so the 31st bit can never be a; // fixed parameter. At the same time, we also do not know whether the zero of; // the 31st bit indicates a float or double parameter type here. Therefore, we; // ignore the 31st bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:48,Availability,mask,mask,48,// Two of the bits that haven't got used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:16,Integrability,wrap,wrapper,16,"// If we have a wrapper header, parse it and ignore the non-bc file; // contents. The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:43,Integrability,wrap,wrapper,43,// Use the cursor modified by skipping the wrapper header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:83,Security,validat,validate,83,"// If we found a metadata index, let's verify that we had an offset; // before and validate its forward reference offset was correct!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:24,Security,hash,hash,24,"// If we found a module hash, let's verify that it matches!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:17,Security,hash,hash,17,// Recompute the hash and compare it to the one in the bitcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:16,Integrability,wrap,wrapper,16,"// If we have a wrapper header, parse it and ignore the non-bc file contents.; // The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:71,Availability,failure,failure,71,"/// Convert a string from a record into an std::string, return true on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:318,Deployability,upgrade,upgrade,318,"/// This represents a constant expression or constant aggregate using a custom; /// structure internal to the bitcode reader. Later, this structure will be; /// expanded by materializeValue() either into a constant expression/aggregate,; /// or into an instruction sequence at the point of use. This allows us to; /// upgrade bitcode using constant expressions even if this kind of constant; /// expression is no longer supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:53,Safety,avoid,avoid,53,// Value subclass ID: Pick largest possible value to avoid any clashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:265,Safety,avoid,avoid,265,"// Opcodes used for non-expressions. This includes constant aggregates; // (struct, array, vector) that might need expansion, as well as non-leaf; // constants that don't need expansion (no_cfi, dso_local, blockaddress),; // but still go through BitcodeConstant to avoid different uselist orders; // between the two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:117,Deployability,upgrade,upgrades,117,/// Track type IDs of contained types. Order is the same as the contained; /// types of a Type*. This is used during upgrades of typed pointer IR in; /// opaque pointer mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:124,Performance,load,loaded,124,/// These are basic blocks forward-referenced by block addresses. They are; /// inserted lazily into functions when they're loaded. The basic block ID is; /// its index into the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:128,Performance,queue,queue,128,"/// These are Functions that contain BlockAddresses which refer a different; /// Function. When parsing the different Function, queue Functions that refer; /// to the different Function. Those Functions must be materialized in order; /// to resolve their BlockAddress constants before the different Function; /// gets moved into another Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:73,Availability,error,error,73,/// Main interface to parsing a bitcode buffer.; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:9,Integrability,interface,interface,9,/// Main interface to parsing a bitcode buffer.; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:158,Availability,failure,failure,158,/// Read a value/type pair out of the specified record from slot 'Slot'.; /// Increment Slot past the number of slots used in the record. Return true on; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:173,Availability,error,error,173,/// Read a value out of the specified record from slot 'Slot'. Increment Slot; /// past the number of slots used by the value in the record. Return true if; /// there is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,Availability,error,error,79,"/// Version of getValue that returns ResVal directly, or 0 if there is an; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:4,Deployability,Upgrade,Upgrades,4,/// Upgrades old-style typeless byval/sret/inalloca attributes by adding the; /// corresponding argument's pointee type. Also upgrades intrinsics that now; /// require an elementtype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:126,Deployability,upgrade,upgrades,126,/// Upgrades old-style typeless byval/sret/inalloca attributes by adding the; /// corresponding argument's pointee type. Also upgrades intrinsics that now; /// require an elementtype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:162,Availability,error,error,162,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:38,Energy Efficiency,power,power,38,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:63,Availability,error,error,63,"/// Indicates whether we have already parsed the VST, used for error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:354,Usability,GUID,GUID,354,"// Map to save ValueId to ValueInfo association that was recorded in the; // ValueSymbolTable. It is used after the VST is parsed to convert; // call graph edges read from the function summary from referencing; // callees by their ValueId to using the ValueInfo instead, which is how; // they are recorded in the summary index being built.; // We save a GUID which refers to the same global as the ValueInfo, but; // ignoring the linkage, i.e. for values other than local linkage they are; // identical (this is the second tuple member).; // The third tuple member is the real GUID of the ValueInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:577,Usability,GUID,GUID,577,"// Map to save ValueId to ValueInfo association that was recorded in the; // ValueSymbolTable. It is used after the VST is parsed to convert; // call graph edges read from the function summary from referencing; // callees by their ValueId to using the ValueInfo instead, which is how; // they are recorded in the summary index being built.; // We save a GUID which refers to the same global as the ValueInfo, but; // ignoring the linkage, i.e. for values other than local linkage they are; // identical (this is the second tuple member).; // The third tuple member is the real GUID of the ValueInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:130,Modifiability,variab,variable,130,"// Check for a function that isn't materializable to prevent an infinite; // loop. When parsing a blockaddress stored in a global variable, there; // isn't a trivial way to check if a function will have a body without a; // linear search through FunctionsWithBodies, so just check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:62,Deployability,upgrade,upgrade,62,"// Summary were not emitted before LLVM 3.9, we don't need to upgrade Linkage; // like getDecodedLinkage() above. Any future change to the linkage enum and; // to getDecodedLinkage() will need to be taken into account here as above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:186,Performance,cache,cache,186,"// The cmpxchg return value is the only place we need more than one; // contained type ID, however the second one will always be the same (i1),; // so we don't need to include it in the cache key. This asserts that the; // contained types are indeed as expected and there are no collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:202,Testability,assert,asserts,202,"// The cmpxchg return value is the only place we need more than one; // contained type ID, however the second one will always be the same (i1),; // so we don't need to include it in the cache key. This asserts that the; // contained types are indeed as expected and there are no collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,Cache,Cache,3,// Cache resolved constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:47,Deployability,upgrade,upgraded,47,"// 1ULL << 49 is InaccessibleMemOnly, which is upgraded separately.; // 1ULL << 50 is InaccessibleMemOrArgMemOnly, which is upgraded separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:124,Deployability,upgrade,upgraded,124,"// 1ULL << 49 is InaccessibleMemOnly, which is upgraded separately.; // 1ULL << 50 is InaccessibleMemOrArgMemOnly, which is upgraded separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:21,Deployability,upgrade,upgraded,21,// Type will be auto-upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:98,Availability,down,down,98,// The alignment is stored as a 16-bit raw value from bits 31--16. We shift; // the bits above 31 down by 11 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade old memory attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade old-style byval attribute to one with a type, even if it's; // nullptr. We will have to insert the real type when we associate; // this AttributeList with a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:52,Performance,scalab,scalable,52,"// VECTOR: [numelts, eltty] or; // [numelts, eltty, scalable]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Integrability,Synchroniz,Synchronization,3,// Synchronization scope names are implicitly mapped to synchronization; // scope IDs by their order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Integrability,synchroniz,synchronization,56,// Synchronization scope names are implicitly mapped to synchronization; // scope IDs by their order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:95,Usability,resume,resumed,95,"// Set the LastFunctionBlockBit to point to the last function block.; // Later when parsing is resumed after function materialization,; // we can simply skip that last function block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:146,Usability,simpl,simply,146,"// Set the LastFunctionBlockBit to point to the last function block.; // Later when parsing is resumed after function materialization,; // we can simply skip that last function block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:340,Security,access,access,340,"// Compute the delta between the bitcode indices in the VST (the word offset; // to the word-aligned ENTER_SUBBLOCK for the function block, and that; // expected by the lazy reader. The reader's EnterSubBlock expects to have; // already read the ENTER_SUBBLOCK code (size getAbbrevIDWidth) and BlockID; // (size BlockIDWidth). Note that we access the stream's AbbrevID width here; // just before entering the VST subblock because: 1) the EnterSubBlock; // changes the AbbrevID width; 2) the VST block is nested within the same; // outer MODULE_BLOCK as the FUNCTION_BLOCKs and therefore have the same; // AbbrevID width before calling EnterSubBlock; and 3) when we want to; // jump to the FUNCTION_BLOCK using this offset later, we don't want; // to rely on the stream's AbbrevID width being that of the MODULE_BLOCK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:112,Deployability,upgrade,upgraded,112,"// Mismatches can happen if the functions are being materialized lazily; // (out-of-order), or a value has been upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:97,Deployability,upgrade,upgrade,97,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:146,Deployability,upgrade,upgrade,146,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:140,Safety,avoid,avoid,140,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Patch,Patch,3,// Patch the initializers for globals and aliases up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:49,Deployability,upgrade,upgraded,49,// Look for intrinsic functions which need to be upgraded at some point; // and functions that need to have their function attributes upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:134,Deployability,upgrade,upgraded,134,// Look for intrinsic functions which need to be upgraded at some point; // and functions that need to have their function attributes upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:19,Modifiability,variab,variables,19,// Look for global variables which need to be renamed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any old-style byval or sret without a type by propagating the; // argument's pointee type. There should be no opaque pointers where the byval; // type is implicit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:28,Integrability,depend,depend,28,// Parts of bitcode parsing depend on the datalayout. Make sure we; // finalize the datalayout before we run any of that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:128,Deployability,upgrade,upgrades,128,"// In order to support importing modules with illegal data layout strings,; // delay parsing the data layout string until after upgrades and overrides; // have been applied, allowing to fix illegal data layout strings.; // Initialize to the current module's layout string in case none is specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:8,Deployability,upgrade,upgrade,8,// Auto-upgrade the layout string,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:223,Usability,Resume,ResumeBit,223,"// If we have a VST forward declaration record, but have already; // parsed the VST (just above, when the first function body was; // encountered here), then we are resuming the parse after; // materializing functions. The ResumeBit points to the; // start of the last function block recorded in the; // DeferredFunctionInfo map. Skip it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:96,Usability,resume,resume,96,"// Suspend parsing when we reach the function bodies. Subsequent; // materialization calls will resume it when necessary. If the bitcode; // file is old, the symbol table will be at the end instead and will not; // have been seen yet. In this case, just finish the parse now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:83,Deployability,upgrade,upgraded,83,"// After the VST has been parsed, we need to make sure intrinsic name; // are auto-upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:707,Availability,failure,failure,707,"// When we have the RARE case of a BlockAddress Constant that is not; // scoped to the Function it refers to, we need to conservatively; // materialize the referred to Function, regardless of whether or not; // that Function will ultimately be linked, otherwise users of; // BitcodeReader might start splicing out Function bodies such that we; // might no longer be able to materialize the BlockAddress since the; // BasicBlock (and entire body of the Function) the BlockAddress refers; // to may have been moved. In the case that the user of BitcodeReader; // decides ultimately not to link the Function body, materializing here; // could be considered wasteful, but it's better than a deserialization; // failure as described. This keeps BitcodeReader unaware of complex; // linkage policy decisions such as those use by LTO, leaving those; // decisions ""one layer up.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:20,Usability,clear,clear,20,// FIXME: It is not clear whether values in the range should be; // compared as signed or unsigned values. The partially; // implemented changes that used this format in the past used; // unsigned comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Usability,RESUME,RESUME,3,// RESUME: [opval],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade explicit blockaddress arguments to label constraints.; // Verify that the last arguments are blockaddress arguments that; // match the indirect destinations. Clang always generates callbr; // in this form. We could support reordering with more effort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Update,Update,3,// Update constraint string to use label constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:169,Safety,avoid,avoid,169,"// Phi nodes may contain the same predecessor multiple times, in which; // case the incoming value must be identical. Directly reuse the already; // seen value here, to avoid expanding a constant expression multiple; // times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,LOAD,LOADATOMIC,3,"// LOADATOMIC: [opty, op, align, vol, ordering, ssid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,Performance,load,loaded,79,"// Before weak cmpxchgs existed, the instruction simply returned the; // value loaded from memory, so bitcode files from that era will be; // expecting the first component of a modern cmpxchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:49,Usability,simpl,simply,49,"// Before weak cmpxchgs existed, the instruction simply returned the; // value loaded from memory, so bitcode files from that era will be; // expecting the first component of a modern cmpxchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:60,Modifiability,variab,variable,60,// A call or an invoke can be optionally prefixed with some variable; // number of operand bundle blocks. These blocks are read into; // OperandBundles and consumed at the next call or invoke instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:60,Safety,avoid,avoid,60,// We found at least one unresolved value. Nuke them all to avoid leaks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:23,Availability,down,down,23,// Trim the value list down to the size it was before we parsed this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:195,Testability,Assert,Assert,195,"// This is the fallback handling for the old format bitcode that; // didn't contain the function index in the VST, or when we have; // an anonymous function which would not have a VST entry.; // Assert that we have one of those two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:15,Integrability,synchroniz,synchronization,15,// Map unknown synchronization scopes to system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any old intrinsic calls in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:25,Deployability,upgrade,upgrade,25,// Finish fn->subprogram upgrade for materialized functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:4,Deployability,Upgrade,Upgrade,4,"// ""Upgrade"" older incorrect branch weights by dropping them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any intrinsic calls that slipped through (should not happen!) and; // delete the old functions to clean up. We can't do this unless the entire; // module is materialized because there could always be another function body; // with calls to the old function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:97,Integrability,rout,routine,97,// Parse just the blocks needed for building the index out of the module.; // At the end of this routine the module Index is populated with a map; // from global value id to GlobalValueSummary objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:120,Performance,perform,performing,120,// We might not have a VST if there were no values in the; // summary. An empty summary block generated when we are; // performing ThinLTO compiles so we don't later invoke; // the regular LTO process on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:114,Modifiability,variab,variables,114,// We can expect to see any number of type ID information records before; // each function summary records; these variables store the information; // collected so far so that it can be used to create the summary object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:36,Integrability,depend,depends,36,// Read a record. The record format depends on whether this; // is a per-module index or a combined index file. In the per-module; // case the records contain the associated value's ID for correlation; // with VST entries. In the combined index the correlation is done; // via the bitcode offset of the summary records (which were saved; // in the combined index VST entries). The records also contain; // information used for ThinLTO renaming and importing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:159,Availability,avail,available,159,"// FS_ALIAS: [valueid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_PERMODULE entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:174,Availability,avail,available,174,"// FS_COMBINED_ALIAS: [valueid, modid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_COMBINED entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,Safety,avoid,avoid,27,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:48,Security,hash,hash,48,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:94,Integrability,interface,interface,94,//===----------------------------------------------------------------------===//; // External interface; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,Performance,load,loading,27,"/// Get a lazy one-at-time loading module from bitcode.; ///; /// This isn't always used in a lazy context. In particular, it's also used by; /// \a parseModule(). If this is truly lazy, then we need to eagerly pull; /// in forward-referenced functions from block address references.; ///; /// \param[in] MaterializeAll Set to \c true if we should materialize; /// everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:193,Availability,error,error,193,"/* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:199,Integrability,message,message,199,"/* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:196,Availability,error,error,196,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:202,Integrability,message,message,202,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:106,Performance,perform,performs,106,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:3,Deployability,Release,Release,3,// Release the buffer if we didn't take ownership of it since we never owned; // it anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type that had an MDString reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type that had an MDString reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type ref array that may have MDString references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:18,Usability,clear,clearly,18,// Bail out for a clearly invalid value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade from old type ref arrays. In strange cases, this could add to; // OldTypeRefs.Unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:48,Performance,queue,queue,48,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:77,Performance,load,loaded,77,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:108,Performance,queue,queue,108,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:36,Performance,load,loading,36,"/// Cursor associated with the lazy-loading of Metadata. This is the easy way; /// to keep around the right ""context"" (Abbrev list) to be able to jump in; /// the middle of the metadata block and load any record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:196,Performance,load,load,196,"/// Cursor associated with the lazy-loading of Metadata. This is the easy way; /// to keep around the right ""context"" (Abbrev list) to be able to jump in; /// the middle of the metadata block and load any record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,Performance,load,loading,14,/// On-demand loading of a single MDString. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:80,Performance,load,loading,80,"/// Cursor position of the start of the global decl attachments, to enable; /// loading using the index built for lazy loading, instead of forward; /// references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:119,Performance,load,loading,119,"/// Cursor position of the start of the global decl attachments, to enable; /// loading using the index built for lazy loading, instead of forward; /// references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Performance,Load,Load,4,"/// Load the global decl attachments, using the index built for lazy loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:69,Performance,load,loading,69,"/// Load the global decl attachments, using the index built for lazy loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:46,Performance,load,loading,46,"/// Populate the index above to enable lazily loading of metadata, and load; /// the named metadata as well as the transitively referenced global; /// Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:71,Performance,load,load,71,"/// Populate the index above to enable lazily loading of metadata, and load; /// the named metadata as well as the transitively referenced global; /// Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,Performance,load,loading,14,/// On-demand loading of a single metadata. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:58,Deployability,update,update,58,"// Keep mapping of seens pair of old-style CU <-> SP, and update pointers to; // point from SP to CU after a block is completly parsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade old-style CU <-> SP pointers to point from SP to CU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade old-style bare DIGlobalVariables to DIGlobalVariableExpressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade list of variables attached to the CUs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:19,Modifiability,variab,variables,19,// Upgrade list of variables attached to the CUs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade variables attached to globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Modifiability,variab,variables,11,// Upgrade variables attached to globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Update,Update,3,// Update DISubprograms' retainedNodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade the expression from previous versions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,loading,11,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:53,Performance,load,load,53,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:67,Performance,load,loadable,67,"// Get the abbrevs, and preload record positions to make them lazy-loadable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:85,Performance,load,load,85,"// This is the offset to the index, when we see this we skip all the; // records and load only an index to these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:46,Performance,load,loaded,46,"// We don't expect to get there, the Index is loaded when we encounter; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:172,Modifiability,Inherit,Inherit,172,"// FIXME: We could use a placeholder here, however NamedMDNode are; // taking MDNode as operand and not using the Metadata infrastructure.; // It is acknowledged by 'TODO: Inherit from Metadata' in the; // NamedMDNode class definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:75,Performance,load,loading,75,"// We don't expect to see any of these, if we see one, give up on; // lazy-loading and fallback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Performance,Load,Load,3,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Performance,load,loading,60,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:88,Performance,load,load,88,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:90,Performance,load,loading,90,// Use a temporary cursor so that we don't mess up the main Stream cursor or; // the lazy loading IndexCursor (which holds the necessary abbrev ids).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:63,Energy Efficiency,efficient,efficiently,63,// Record the entry position so that we can jump back here and efficiently; // skip the whole block in case we lazy-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:116,Performance,load,load,116,// Record the entry position so that we can jump back here and efficiently; // skip the whole block in case we lazy-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,load,11,"// We lazy-load module-level metadata: we build an index for each record, and; // then load individual record as needed, starting with the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:87,Performance,load,load,87,"// We lazy-load module-level metadata: we build an index for each record, and; // then load individual record as needed, starting with the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Performance,load,load,60,// An index was successfully created and we will be able to load metadata; // on-demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:37,Performance,load,load,37,"// Now that we have built the index, load the global decl attachments; // that were deferred during that process. This avoids creating; // temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:119,Safety,avoid,avoids,119,"// Now that we have built the index, load the global decl attachments; // that were deferred during that process. This avoids creating; // temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:24,Availability,error,error,24,"// FIXME this drops the error on the floor, which; // ThinLTO/X86/debuginfo-cu-import.ll relies on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:12,Performance,load,load,12,"// Couldn't load an index, fallback to loading all the block ""old-style"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:39,Performance,load,loading,39,"// Couldn't load an index, fallback to loading all the block ""old-style"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:52,Performance,load,loaded,52,// Lookup first if the metadata hasn't already been loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:92,Performance,load,loading,92,/// Ensure that all forward-references and placeholders are resolved.; /// Iteratively lazy-loading metadata on-demand if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:64,Performance,load,loaded,64,// Populate Temporaries with the placeholders that haven't been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:10,Performance,load,load,10,"// First, load all the temporaries. This can add new placeholders or; // forward references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,load,11,"// Second, load the forward-references. This can also add new placeholders; // or forward references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:99,Performance,load,loaded,99,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:114,Safety,safe,safely,114,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:257,Availability,Error,ErrorInfo,257,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:296,Availability,failure,failure,296,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:323,Availability,error,error,323,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,loading,11,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:53,Performance,load,load,53,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:84,Performance,load,load,84,// Create a temporary for the node that is referencing the operand we; // will lazy-load. It is needed before recursing in case there are; // uniquing cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:104,Deployability,upgrade,upgrade,104,"// If this isn't a LocalAsMetadata record, we're dropping it. This used; // to be legal, but there's no upgrade path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Usability,simpl,simplified,60,// This is a hack around preserving template parameters for simplified; // template names - it should probably be replaced with a; // DICompositeType flag specifying whether template parameters are; // required on declarations of this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:65,Security,Checksum,Checksum,65,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:193,Security,Checksum,ChecksumKind,193,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:262,Security,Checksum,ChecksumKind,262,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:12,Deployability,Upgrade,Upgrade,12,// Move the Upgrade the list of subprograms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade sp->function mapping to function->sp mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:106,Availability,avail,available,106,// No upgrade necessary. A null field will be introduced to indicate; // that no parameter information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:6,Deployability,upgrade,upgrade,6,// No upgrade necessary. A null field will be introduced to indicate; // that no parameter information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade old metadata, which stored a global variable reference or a; // ConstantInt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:47,Modifiability,variab,variable,47,"// Upgrade old metadata, which stored a global variable reference or a; // ConstantInt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Testability,Test,Test,3,// Test for upgrading !llvm.loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Performance,Load,Load,3,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:44,Performance,load,loadable,44,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:79,Performance,load,loaded,79,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:66,Deployability,upgrade,upgrade,66,"// Drop the attachment. This used to be legal, but there's no; // upgrade path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:42,Performance,Load,Load,42,"//===-- Bitcode/Reader/MetadataLoader.h - Load Metadatas -------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class handles loading Metadatas.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:402,Performance,load,loading,402,"//===-- Bitcode/Reader/MetadataLoader.h - Load Metadatas -------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class handles loading Metadatas.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:65,Availability,avail,available,65,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:30,Performance,load,loading,30,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:43,Performance,load,load,43,/// Set the mode to strip TBAA metadata on load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:23,Performance,Load,Loader,23,/// Return true if the Loader is stripping TBAA metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:20,Deployability,upgrade,upgrades,20,/// Perform bitcode upgrades on llvm.dbg.* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:4,Performance,Perform,Perform,4,/// Perform bitcode upgrades on llvm.dbg.* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:18,Usability,clear,clearly,18,// Bail out for a clearly invalid value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:48,Availability,error,error,48,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:54,Integrability,message,message,54,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:46,Usability,GUID,GUIDs,46,"/// Map that holds the correspondence between GUIDs in the summary index,; /// that came from indirect call profiles, and a value id generated by this; /// class to use in the VST and summary block records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:45,Usability,GUID,GUIDToValueMap,45,/// Tracks the last value id recorded in the GUIDToValueMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:118,Usability,GUID,GUID,118,"// Assign ValueIds to any callee values in the index that came from; // indirect call profiles and were recorded as a GUID not a Value*; // (which would have been assigned an ID by the ValueEnumerator).; // The starting ValueId is just after the number of values in the; // ValueEnumerator, so that they can be emitted in the VST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:34,Usability,GUID,GUID,34,// Examine all summaries for this GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:70,Usability,GUID,GUID,70,"// For each call in the function summary, see if the call; // is to a GUID (which means it is for an indirect call,; // otherwise we would have a Value for it). If so, synthesize; // a value id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Usability,GUID,GUID,19,// Expect that any GUID value had a value Id assigned by an; // earlier call to assignValueId.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:26,Energy Efficiency,allocate,allocated,26,/// Pointer to the buffer allocated by caller for bitcode writing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:21,Security,hash,hash,21,/// True if a module hash record should be written.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:58,Security,hash,hash,58,"/// If non-null, when GenerateHash is true, the resulting hash is written; /// into ModHash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:124,Usability,GUID,GUIDs,124,"/// When writing a subset of the index for distributed backends, client; /// provides a map of modules to the corresponding GUIDs/summaries to write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:50,Usability,GUID,GUID,50,/// Map that holds the correspondence between the GUID used in the combined; /// index and a value id generated by this class to use in references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:45,Usability,GUID,GUIDToValueMap,45,/// Tracks the last value id recorded in the GUIDToValueMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:130,Usability,GUID,GUID,130,"// Assign unique value ids to all summaries to be written, for use; // in writing out the call graph edges. Save the mapping from GUID; // to the new global value id to use when writing those edges, which; // are currently saved in the index in terms of GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:254,Usability,GUID,GUID,254,"// Assign unique value ids to all summaries to be written, for use; // in writing out the call graph edges. Save the mapping from GUID; // to the new global value id to use when writing those edges, which; // are currently saved in the index in terms of GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:129,Usability,GUID,GUID,129,"// If the stack id list is empty, this callsite info was synthesized for; // a missing tail call frame. Ensure that the callee's GUID gets a value; // id. Normally we only generate these for defined summaries, which in; // the case of distributed ThinLTO is only the functions already defined; // in the module or that we want to import. We don't bother to include; // all the callee symbols as they aren't normally needed in the backend.; // However, for the synthesized callsite infos we do need the callee; // GUID in the backend so that we can correlate the identified callee; // with this callsite info (which for non-tail calls is done by the; // ordering of the callsite infos and verified via stack ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:513,Usability,GUID,GUID,513,"// If the stack id list is empty, this callsite info was synthesized for; // a missing tail call frame. Ensure that the callee's GUID gets a value; // id. Normally we only generate these for defined summaries, which in; // the case of distributed ThinLTO is only the functions already defined; // in the module or that we want to import. We don't bother to include; // all the callee symbols as they aren't normally needed in the backend.; // However, for the synthesized callsite infos we do need the callee; // GUID in the backend so that we can correlate the identified callee; // with this callsite info (which for non-tail calls is done by the; // ordering of the callsite infos and verified via stack ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:35,Usability,GUID,GUID,35,/// The below iterator returns the GUID and associated summary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:38,Usability,GUID,GUID,38,/// Calls the callback for each value GUID and summary to be written to; /// bitcode. This hides the details of whether they are being pulled from the; /// entire index or just those in a provided ModuleToSummariesForIndex map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:144,Safety,avoid,avoid,144,"// Since StringMap iteration order isn't guaranteed, order by path string; // first.; // FIXME: Make this a vector of StringMapEntry instead to avoid the later; // map lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:51,Performance,scalab,scalable,51,"// VECTOR [numelts, eltty] or; // [numelts, eltty, scalable]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:202,Deployability,update,updated,202,"// Write a placeholder value in for the offset of the real VST,; // which is written after the function blocks so that it can include; // the offset of each function. The placeholder offset will be; // updated when the real VST is written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:73,Deployability,patch,patched,73,"// Compute and save the bit offset to the placeholder, which will be; // patched when the real VST is written. We can simply subtract the 32-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:118,Usability,simpl,simply,118,"// Compute and save the bit offset to the placeholder, which will be; // patched when the real VST is written. We can simply subtract the 32-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:107,Modifiability,variab,variables,107,"/// Emit top-level description of module, including target triple, inline asm,; /// descriptors for global variables, and function prototype info.; /// Returns the bit offset to backpatch with the location of the real VST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Modifiability,variab,variable,19,// Emit the global variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:92,Security,Checksum,ChecksumKind,92,// Maintain backwards compatibility with the old internal representation of; // CSK_None in ChecksumKind by writing nulls here when Checksum is None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:132,Security,Checksum,Checksum,132,// Maintain backwards compatibility with the old internal representation of; // CSK_None in ChecksumKind by writing nulls here when Checksum is None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:92,Performance,load,load,92,"// Emit all abbrevs upfront, so that the reader can jump in the middle of the; // block and load any metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:198,Deployability,update,updated,198,"// Write a placeholder value in for the offset of the metadata index,; // which is written after the records, so that it can include; // the offset of each entry. The placeholder offset will be; // updated after all records are emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:78,Deployability,patch,patched,78,"// Compute and save the bit offset to the current position, which will be; // patched when we emit the index later. We can simply subtract the 64-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:123,Usability,simpl,simply,123,"// Compute and save the bit offset to the current position, which will be; // patched when we emit the index later. We can simply subtract the 64-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:162,Energy Efficiency,efficient,efficiently,162,// Now that we have emitted all the records we will emit the index. But; // first; // backpatch the forward reference so that the reader can skip the records; // efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:82,Modifiability,variab,variable,82,"// FIXME: Only store metadata for declarations here, and move data for global; // variable definitions to a separate block (PR28134).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:106,Energy Efficiency,efficient,efficiently,106,/// Write a GlobalValue VST to the module. The purpose of this data structure is; /// to allow clients to efficiently find the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:10,Security,Hash,Hash,10,"// Module Hash, 160 bits SHA1. Optionally, emitted after each MST_CODE_ENTRY.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:20,Security,hash,hash,20,// Emit an optional hash for the module now,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:12,Security,hash,hash,12,// Emit the hash record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:31,Testability,test,tests,31,/// Collect type IDs from type tests used by function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:52,Modifiability,variab,variable,52,"// Collect the global value references in the given variable's initializer,; // and emit them in a summary record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:427,Testability,test,testing,427,"// We don't need to emit the original name if we are writing the index for; // distributed backends (in which case ModuleToSummariesForIndex is; // non-null). The original name is only needed during the thin link, since; // for SamplePGO the indirect call targets for local functions have; // have the original name annotated in profile.; // Continue to emit it when writing out the entire combined index, which is; // used in testing the thin link via llvm-lto.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:85,Performance,load,loaded,85,// Will process aliases as a post-pass because the reader wants all; // global to be loaded first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:204,Security,validat,validation,204,// This can happen in shared index files for distributed ThinLTO if; // the callee function summary is not included. Record 0 which we; // will have to deal with conservatively when doing any kind of; // validation in the ThinLTO backends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:11,Usability,GUID,GUID,11,"// If this GUID doesn't have a value id, it doesn't have a function; // summary and we don't need to record any calls to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:12,Usability,GUID,GUIDs,12,"// Walk the GUIDs that were referenced, and write the; // corresponding type id records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:21,Security,hash,hash,21,// Emit the module's hash.; // MODULE_CODE_HASH: [5*i32],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:20,Security,hash,hash,20,// Save the written hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:105,Modifiability,variab,variables,105,"// Emit top-level description of module, including target triple, inline asm,; // descriptors for global variables, and function prototype info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:31,Energy Efficiency,power,powerpc,31,"// Match x86_64-*, i[3-9]86-*, powerpc-*, powerpc64-*, arm-*, thumb-*,; // armv[0-9]-*, thumbv[0-9]-*, armv5te-*, or armv6t2-*. The CPUType is a magic; // number from /usr/include/mach/machine.h. It is ok to reproduce the; // specific constants here because they are implicitly part of the Darwin ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:292,Availability,error,error,292,"// The irsymtab::build function may be unable to create a symbol table if the; // module is malformed (e.g. it contains an invalid alias). Writing a symbol; // table is not required for correctness, but we still want to be able to; // write malformed modules to bitcode files, so swallow the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Modifiability,variab,variable,19,// Emit the global variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:16,Security,hash,hash,16,// Write module hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:63,Safety,avoid,avoid,63,// Explicitly sequence get-size and insert-value operations to avoid UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:19,Performance,cache,cache,19,"// Note: we cannot cache this lookup above, since inserting into the map; // changes the map's size, and thus affects the other IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:175,Safety,predict,predictValueUseListOrderImpl,175,"// Initializers of GlobalValues are processed in; // BitcodeReader::ResolveGlobalAndAliasInits(). Match the order there rather; // than ValueEnumerator, and match the code in predictValueUseListOrderImpl(); // by giving IDs in reverse order.; //; // Since GlobalValues never reference each other directly (just through; // initializers), their relative IDs only matter for determining order of; // uses in their initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Safety,Predict,Predict,3,// Predict use-list order for this one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:11,Safety,predict,predicted,11,// Already predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:17,Safety,predict,prediction,17,// Do the actual prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:24,Modifiability,variab,variables,24,// Enumerate the global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:24,Modifiability,variab,variable,24,// Enumerate the global variable initializers and attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:110,Modifiability,variab,variable,110,// FIXME: Pass GV to EnumerateMetadata and arrange for the bitcode writer; // to write metadata to the global variable's own metadata block; // (PR28134).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimize,3,// Optimize constant ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:4,Performance,Optimiz,OptimizeConstants,4,/// OptimizeConstants - Reorder constant pool for denser encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimizing,3,// Optimizing constants makes the use-list order difficult to predict.; // Disable it for now when trying to preserve the order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:62,Safety,predict,predict,62,// Optimizing constants makes the use-list order difficult to predict.; // Disable it for now when trying to preserve the order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:106,Safety,detect,detect,106,// ConstantAsMetadata doesn't reference anything. We may as well shuffle it; // to the front since we can detect it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:427,Modifiability,variab,variable,427,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:289,Safety,avoid,avoid,289,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:118,Safety,safe,safe,118,"// If it is a non-anonymous struct, mark the type as being visited so that we; // don't recursively visit it. This is safe because we allow forward; // references of these in the bitcode reader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:292,Availability,avail,available,292,"// Check to see if we got the pointer another way. This can happen when; // enumerating recursive types that hit the base case deeper than they start.; //; // If this is actually a struct that we are treating as forward ref'able,; // then emit the definition now that all of its contents are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the constant layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:55,Availability,avail,available,55,// Add the function's parameter attributes so they are available for use in; // the function's instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:66,Performance,optimiz,optimization,66,"/// Reorder the reachable metadata.; ///; /// This is not just an optimization, but is mandatory for emitting MDString; /// correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:297,Safety,avoid,avoids,297,"/// Enumerate reachable metadata in (almost) post-order.; ///; /// Enumerate all the metadata reachable from MD. We want to minimize the; /// cost of reading bitcode records, and so the primary consideration is that; /// operands of uniqued nodes are resolved before the nodes are read. This; /// avoids re-uniquing them on the context and factors away RAUW support.; ///; /// This algorithm guarantees that subgraphs of uniqued nodes are in; /// post-order. Distinct subgraphs reachable only from a single uniqued node; /// will be in post-order.; ///; /// \note The relative order of a distinct and uniqued node is irrelevant.; /// \a organizeMetadata() will later partition distinct nodes ahead of; /// uniqued ones.; ///{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:54,Safety,avoid,avoid,54,"// If we can return a reference to the data, do so to avoid copying it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:143,Safety,avoid,avoids,143,"// As a special case, handle fixed(0) (i.e., a fixed field with zero bits); // and vbr(0) as a literal zero. This is decoded the same way, and avoids; // a slow path in Read() to have to handle reading zero bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:20,Deployability,install,installs,20,// ReadAbbrevRecord installs the abbrev in CurAbbrevs. Move it to the; // appropriate BlockInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:514,Energy Efficiency,schedul,scheduling,514,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:475,Integrability,depend,dependence,475,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:556,Integrability,depend,dependencies,556,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:146,Energy Efficiency,schedul,scheduled,146,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:212,Energy Efficiency,schedul,schedule,212,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:330,Energy Efficiency,schedul,schedule,330,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,Integrability,depend,dependencies,57,/// AntiDepEdges - Return in Edges the anti- and output- dependencies; /// in SU that we want to consider for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:48,Integrability,depend,dependency,48,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Performance,latency,latency,20,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:91,Usability,clear,clear,91,"// FIXME: We must leave subregisters of live super registers as live, so that; // we don't clear out the register tracking information for subregisters of; // super registers we're still tracking (and with which we're unioning; // subregister definitions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:51,Deployability,update,update,51,// Scan the register defs for this instruction and update; // live-ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update def for Reg and aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:223,Safety,safe,safely,223,"// If MI's uses have special allocation requirement, don't allow; // any use registers to be changed. Also assume all registers; // used in a call must not be changed (ABI).; // Inline Assembly register uses also cannot be safely changed.; // FIXME: The issue with predicated instruction is more complex. We are being; // conservatively here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:858,Safety,safe,safe,858,"// If MI's uses have special allocation requirement, don't allow; // any use registers to be changed. Also assume all registers; // used in a call must not be changed (ABI).; // Inline Assembly register uses also cannot be safely changed.; // FIXME: The issue with predicated instruction is more complex. We are being; // conservatively here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:51,Deployability,update,update,51,"// Scan the register uses for this instruction and update; // live-ranges, groups and RegRefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:143,Integrability,depend,dependence,143,// Collect all referenced registers in the same group as; // AntiDepReg. These all need to be renamed together if we are to; // break the anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:107,Testability,assert,assert,107,"// FIXME: remove this once PR18663 has been properly fixed. For now,; // return a conservative answer:; // assert(IsSub && ""Expecting group subregister"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:98,Availability,avail,available,98,"// Check each possible rename register for SuperReg in round-robin; // order. If that register is available, and the corresponding; // registers are available for the other group subregisters, then we; // can use those registers to rename.; // FIXME: Using getMinimalPhysRegClass is very conservative. We should; // check every use of the register and find the largest register class; // that can be used in all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:149,Availability,avail,available,149,"// Check each possible rename register for SuperReg in round-robin; // order. If that register is available, and the corresponding; // registers are available for the other group subregisters, then we; // can use those registers to rename.; // FIXME: Using getMinimalPhysRegClass is very conservative. We should; // check every use of the register and find the largest register class; // that can be used in all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:86,Safety,safe,safe,86,"// If NewReg is dead and NewReg's most recent def is not before; // Regs's kill, it's safe to replace Reg with NewReg. We; // must also check all aliases of NewReg, because we can't define a; // register when any sub or super is already live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:29,Availability,avail,available,29,// No registers are free and available!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:72,Energy Efficiency,Schedul,ScheduleDAG,72,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:43,Integrability,depend,dependencies,43,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:168,Integrability,depend,dependencies,168,// Track progress along the critical path through the SUnit graph as; // we walk the instructions. This is needed for regclasses that only; // break critical-path anti-dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:176,Availability,avail,available,176,"// Attempt to break anti-dependence edges. Walk the instructions; // from the bottom up, tracking information about liveness as we go; // to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:25,Integrability,depend,dependence,25,"// Attempt to break anti-dependence edges. Walk the instructions; // from the bottom up, tracking information about liveness as we go; // to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:7,Integrability,depend,dependence,7,// The dependence edges that represent anti- and output-; // dependencies that are candidates for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:61,Integrability,depend,dependencies,61,// The dependence edges that represent anti- and output-; // dependencies that are candidates for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:95,Integrability,depend,dependence,95,// Ignore KILL instructions (they form a group in ScanInstruction; // but don't cause any anti-dependence breaking themselves),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:30,Integrability,depend,dependency,30,// Attempt to break each anti-dependency...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies on non-allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies for critical path registers; // if not on the critical path,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:185,Energy Efficiency,schedul,scheduled,185,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:26,Integrability,depend,dependencies,26,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:69,Integrability,depend,depends,69,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:116,Integrability,depend,dependency,116,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:254,Integrability,depend,dependencies,254,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:322,Integrability,depend,dependency,322,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,Integrability,depend,dependence,57,// Look for a suitable register to use to break the anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update the references to the old register CurrReg to; // refer to the new register NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:39,Deployability,update,updated,39,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:131,Deployability,update,update,131,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:514,Energy Efficiency,schedul,scheduling,514,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:475,Integrability,depend,dependence,475,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:556,Integrability,depend,dependencies,556,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:47,Integrability,depend,dependence,47,/// The state used to identify and rename anti-dependence registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:68,Energy Efficiency,Schedul,ScheduleDAG,68,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp:509,Integrability,depend,depends,509,"//===-- llvm/CodeGen/AllocationOrder.cpp - Allocation Order ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an allocation order for virtual registers.; //; // The preferred allocation order for a virtual register depends on allocation; // hints and target hooks. The AllocationOrder class encapsulates all of that.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:509,Integrability,depend,depends,509,"//===-- llvm/CodeGen/AllocationOrder.h - Allocation Order -*- C++ -*-------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an allocation order for virtual registers.; //; // The preferred allocation order for a virtual register depends on allocation; // hints and target hooks. The AllocationOrder class encapsulates all of that.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:301,Safety,avoid,avoid,301,"// How far into the Order we can iterate. This is 0 if the AllocationOrder is; // constructed with HardHints = true, Order.size() otherwise. While; // technically a size_t, it will participate in comparisons with the; // Iterator's Pos, which must be signed, so it's typed here as signed, too, to; // avoid warnings and under the assumption that the size of Order is; // relatively small.; // IterationLimit defines an invalid iterator position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:86,Energy Efficiency,allocate,allocate,86,/// Create a new AllocationOrder for VirtReg.; /// @param VirtReg Virtual register to allocate for.; /// @param VRM Virtual register map for function.; /// @param RegClassInfo Information about reserved and allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:107,Performance,scalab,scalable,107,"// If the Offsets aren't needed, don't query the struct layout. This allows; // us to support structs with scalable vectors for operations that don't; // need offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:107,Performance,scalab,scalable,107,"// If the Offsets aren't needed, don't query the struct layout. This allows; // us to support structs with scalable vectors for operations that don't; // need offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:370,Deployability,update,updated,370,"/// Look through operations that will be free to find the earliest source of; /// this value.; ///; /// @param ValLoc If V has aggregate type, we will be interested in a particular; /// scalar component. This records its address; the reverse of this list gives a; /// sequence of indices appropriate for an extractvalue to locate the important; /// value. This value is updated during the function and on exit will indicate; /// similar information for the Value returned.; ///; /// @param DataBits If this function looks through truncate instructions, this; /// will record the smallest size attained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:67,Modifiability,extend,extending,67,"// Look through inttoptr.; // Make sure this isn't a truncating or extending cast. We could; // support this eventually, but don't bother for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:67,Modifiability,extend,extending,67,"// Look through ptrtoint.; // Make sure this isn't a truncating or extending cast. We could; // support this eventually, but don't bother for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:175,Usability,simpl,simple,175,"// Trace the sub-value needed by the return value as far back up the graph as; // possible, in the hope that it will intersect with the value produced by the; // call. In the simple case with no ""returned"" attribute, the hope is actually; // that we end up back at the tail call instruction itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:132,Usability,simpl,simple,132,"// Now do a similar search up through the graph to find where the value; // actually returned by the ""tail call"" comes from. In the simple case without; // a ""returned"" attribute, the search will be blocked immediately and the loop; // a Noop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:87,Performance,Perform,Performs,87,"/// Move the given iterators to the next leaf type in depth first traversal.; ///; /// Performs a depth-first traversal of the type as specified by its arguments,; /// stopping at the next leaf node (which may be a legitimate scalar type or an; /// empty struct or array).; ///; /// @param SubTypes List of the partial components making up the type from; /// outermost to innermost non-empty aggregate. The element currently; /// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).; ///; /// @param Path Set of extractvalue indices leading from the outermost type; /// (SubTypes[0]) to the leaf node currently represented.; ///; /// @returns true if a new type was found, false otherwise. Calling this; /// function again on a finished iterator will repeatedly return; /// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty; /// aggregate or a non-aggregate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:56,Availability,down,down,56,"// We know there's *some* valid leaf now, so march back down the tree picking; // out the left-most element at each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:186,Energy Efficiency,schedul,scheduled,186,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:57,Performance,optimiz,optimized,57,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:4,Testability,Test,Test,4,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:257,Testability,test,tests,257,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:186,Performance,optimiz,optimization,186,"// The block must end in a return statement or unreachable.; //; // FIXME: Decline tailcall if it's not guaranteed and if the block ends in; // an unreachable, for now. The way tailcall optimization is currently; // implemented means it will add an epilogue followed by a jump. That is; // not profitable. Also, if the callee is a special function (e.g.; // longjmp on x86), it can end up causing miscompilation that has not; // been fully understood.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:60,Performance,optimiz,optimization,60,// Debug info intrinsics do not get in the way of tail call optimization.; // Pseudo probe intrinsics do not block tail call optimization either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:125,Performance,optimiz,optimization,125,// Debug info intrinsics do not get in the way of tail call optimization.; // Pseudo probe intrinsics do not block tail call optimization either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:82,Performance,optimiz,optimization,82,"// A lifetime end, assume or noalias.decl intrinsic should not stop tail; // call optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:155,Safety,safe,safe,155,"// If they're still different, there's some facet we don't understand; // (currently only ""inreg"", but in future who knows). It may be OK but the; // only safe option is to reject the tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:192,Energy Efficiency,efficient,efficient,192,"// The manipulations performed when we're looking through an insertvalue or; // an extractvalue would happen at the front of the RetPath list, so since; // we have to copy it anyway it's more efficient to create a reversed copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:21,Performance,perform,performed,21,"// The manipulations performed when we're looking through an insertvalue or; // an extractvalue would happen at the front of the RetPath list, so since; // we have to copy it anyway it's more efficient to create a reversed copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:120,Modifiability,variab,variable,120,"/// Option for debugging the pass, determines if the memory location fragment; /// filling happens after generating the variable locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,Energy Efficiency,reduce,reduces,101,/// Coalesce adjacent dbg locs describing memory locations that have contiguous; /// fragments. This reduces the cost of LiveDebugValues which does SSA; /// construction for each explicitly stated variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:197,Modifiability,variab,variable,197,/// Coalesce adjacent dbg locs describing memory locations that have contiguous; /// fragments. This reduces the cost of LiveDebugValues which does SSA; /// construction for each explicitly stated variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:113,Integrability,wrap,wrapper,113,"// Implicit conversions are disabled for enum class types, so unfortunately we; // need to create a DenseMapInfo wrapper around the specified underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,variab,variable,10,/// Get a variable from its \p ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variable,20,/// Add a def for a variable that is valid for its lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:13,Modifiability,variab,variable,13,// Print the variable table first. TODO: Sorting by variable could make the; // output more stable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:52,Modifiability,variab,variable,52,// Print the variable table first. TODO: Sorting by variable could make the; // output more stable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variables,29,// Print the single location variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:27,Modifiability,variab,variables,27,// Add the single-location variables first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Availability,redundant,redundant,108,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Safety,redund,redundant,108,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:12,Modifiability,Variab,Variables,12,// Copy the Variables vector from the builder's UniqueVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,/// A whole (unfragmented) source variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:32,Energy Efficiency,reduce,reduces,32,"// Enabling fragment coalescing reduces compiler run time when instruction; // referencing is enabled. However, it may cause LiveDebugVariables to create; // incorrect locations. Since instruction-referencing mode effectively; // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag; // has not been explicitly set and instruction-referencing is turned on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,Availability,recover,recover,631,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:768,Modifiability,variab,variable,768,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:809,Modifiability,variab,variable,809,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:906,Modifiability,variab,variable,906,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:998,Modifiability,variab,variable,998,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:700,Performance,perform,performs,700,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,Safety,recover,recover,631,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:129,Deployability,update,updated,129,"/// BBInsertBeforeMap holds a description for the set of location defs to be; /// inserted after the analysis is complete. It is updated during the dataflow; /// and the entry for a block is CLEARED each time it is (re-)visited. After; /// the dataflow is complete, each block entry will contain the set of defs; /// calculated during the final (fixed-point) iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:191,Usability,CLEAR,CLEARED,191,"/// BBInsertBeforeMap holds a description for the set of location defs to be; /// inserted after the analysis is complete. It is updated during the dataflow; /// and the entry for a block is CLEARED each time it is (re-)visited. After; /// the dataflow is complete, each block entry will contain the set of defs; /// calculated during the final (fixed-point) iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:72,Performance,perform,performing,72,// This is basically copied from process() and inverted (process is; // performing something like a union whereas this is more of an; // intersect).; // There's no work to do if interval `a` overlaps no fragments in map `B`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:102,Modifiability,variab,variables,102,// Ignore preds that haven't been processed yet. This is essentially the; // same as initialising all variables to implicit top value () which is; // the identity value for the meet operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:51,Deployability,update,update,51,// If the LiveIn set has changed (expensive check) update it and return; // true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:320,Availability,redundant,redundant,320,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:97,Modifiability,variab,variable,97,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:320,Safety,redund,redundant,320,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variables,40,// Don't bother doing anything for this variables if we know it's fully; // promoted. We're only interested in variables that (sometimes) live on; // the stack here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:111,Modifiability,variab,variables,111,// Don't bother doing anything for this variables if we know it's fully; // promoted. We're only interested in variables that (sometimes) live on; // the stack here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:463,Modifiability,variab,variable,463,"// We will only fill fragments for simple memory-describing dbg.value; // intrinsics. If the fragment offset is the same as the offset from the; // base pointer, do The Thing, otherwise fall back to normal dbg.value; // behaviour. AssignmentTrackingLowering has generated DIExpressions; // written in terms of the base pointer.; // TODO: Remove this condition since the fragment offset doesn't always; // equal the offset from base pointer (e.g. for a SROA-split variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:35,Usability,simpl,simple,35,"// We will only fill fragments for simple memory-describing dbg.value; // intrinsics. If the fragment offset is the same as the offset from the; // base pointer, do The Thing, otherwise fall back to normal dbg.value; // behaviour. AssignmentTrackingLowering has generated DIExpressions; // written in terms of the base pointer.; // TODO: Remove this condition since the fragment offset doesn't always; // equal the offset from base pointer (e.g. for a SROA-split variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:16,Modifiability,variab,variable,16,// Check if the variable does not exist in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:12,Modifiability,variab,variable,12,// Add this variable to the BB map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:7,Modifiability,variab,variable,7,// The variable has an entry in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variable,8,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:65,Modifiability,variab,variable,65,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:167,Modifiability,variab,variable,167,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:254,Modifiability,variab,variable,254,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Perform,Perform,3,"// Perform the traversal.; //; // This is a standard ""intersect of predecessor outs"" dataflow problem. To; // solve it, we perform meet() and process() using the two worklist method; // until the LiveIn data for each block becomes unchanging.; //; // This dataflow is essentially working on maps of sets and at each meet we; // intersect the maps and the mapped sets. So, initialized live-in maps; // monotonically decrease in value throughout the dataflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:123,Performance,perform,perform,123,"// Perform the traversal.; //; // This is a standard ""intersect of predecessor outs"" dataflow problem. To; // solve it, we perform meet() and process() using the two worklist method; // until the LiveIn data for each block becomes unchanging.; //; // This dataflow is essentially working on maps of sets and at each meet we; // intersect the maps and the mapped sets. So, initialized live-in maps; // monotonically decrease in value throughout the dataflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:132,Performance,queue,queue,132,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,Safety,avoid,avoid,47,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:98,Safety,avoid,avoid,98,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:182,Modifiability,variab,variable,182,/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function; /// that interprets assignment tracking debug info metadata and stores in IR to; /// create a map of variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,Availability,recover,recovered,918,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:38,Modifiability,variab,variable,38,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,Safety,recover,recovered,918,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:872,Usability,clear,clear,872,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:53,Modifiability,variab,variable,53,"/// An abstraction of the assignment of a value to a variable or memory; /// location.; ///; /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a; /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or; /// can't) know the ID of the last assignment that took place.; ///; /// The Status of the Assignment (Known or NoneOrPhi) is another; /// join-semilattice. The partial order is:; /// NoneOrPhi > Known {id_0, id_1, ...id_N}; ///; /// i.e. for all values x and y where x != y:; /// join(x, x) = x; /// join(x, y) = NoneOrPhi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:25,Modifiability,Variab,VariableID,25,"/// The highest numbered VariableID for partially promoted variables plus 1,; /// the values for which start at 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:59,Modifiability,variab,variables,59,"/// The highest numbered VariableID for partially promoted variables plus 1,; /// the values for which start at 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,variab,variable,10,/// Map a variable to the set of variables that it fully contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:33,Modifiability,variab,variables,33,/// Map a variable to the set of variables that it fully contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:31,Modifiability,variab,variable,31,/// Map untagged stores to the variable fragments they assign to. Used by; /// processUntaggedInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Performance,cache,cached,45,/// Clear the location definitions currently cached for insertion after /p; /// After.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Usability,Clear,Clear,4,/// Clear the location definitions currently cached for insertion after /p; /// After.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:210,Integrability,interface,interface,210,"// emitDbgValue can be called with:; // Source=[AssignRecord|DbgValueInst*|DbgAssignIntrinsic*|DPValue*]; // Since AssignRecord can be cast to one of the latter two types, and all; // other types have a shared interface, we use a template to handle the latter; // three types, and an explicit overload for AssignRecord that forwards to; // the template version with the right type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:15,Modifiability,variab,variables,15,/// The set of variables (VariableID) being tracked in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:26,Modifiability,Variab,VariableID,26,/// The set of variables (VariableID) being tracked in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Modifiability,variab,variable,45,"/// Dominating assignment to memory for each variable, indexed by; /// VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:71,Modifiability,Variab,VariableID,71,"/// Dominating assignment to memory for each variable, indexed by; /// VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,"/// Dominating assignemnt to each variable, indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:55,Modifiability,Variab,VariableID,55,"/// Dominating assignemnt to each variable, indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:27,Modifiability,variab,variable,27,"/// Location kind for each variable. LiveLoc indicates whether the; /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue; /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of; /// preference. This cannot be derived by inspecting DebugValue and; /// StackHomeValue due to the fact that there's no distinction in; /// Assignment (the class) between whether an assignment is unknown or a; /// merge of multiple assignments (both are Status::NoneOrPhi). In other; /// words, the memory location may well be valid while both DebugValue and; /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.; /// Indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:663,Modifiability,Variab,VariableID,663,"/// Location kind for each variable. LiveLoc indicates whether the; /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue; /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of; /// preference. This cannot be derived by inspecting DebugValue and; /// StackHomeValue due to the fact that there's no distinction in; /// Assignment (the class) between whether an assignment is unknown or a; /// merge of multiple assignments (both are Status::NoneOrPhi). In other; /// words, the memory location may well be valid while both DebugValue and; /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.; /// Indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:58,Modifiability,Variab,VariableIDs,58,/// Set LocKind for \p Var only: does not set LocKind for VariableIDs of; /// fragments contained win \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:107,Modifiability,Variab,VariableIDs,107,/// Set the assignment in the \p Kind assignment map for \p Var only: does; /// not set the assignment for VariableIDs of fragments contained win \p; /// Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:123,Modifiability,Variab,VariableIDs,123,/// Return true if there is an assignment matching \p AV in the \p Kind; /// assignment map. Does consider assignments for VariableIDs of fragments; /// contained win \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:58,Modifiability,variab,variables,58,/// Clear everything and initialise with -values for all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Usability,Clear,Clear,4,/// Clear everything and initialise with -values for all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:265,Modifiability,variab,variables,265,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:464,Modifiability,variab,variables,464,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:584,Modifiability,variab,variable,584,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:677,Modifiability,Variab,VariableIDsInBlock,677,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:727,Modifiability,variab,variables,727,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:213,Performance,perform,performing,213,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:431,Performance,perform,performing,431,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:651,Performance,perform,perform,651,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ) for x where Var(x) is in A xor B; // Join = Intersect  Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding -value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the -value for the map element since join(x, ) = .; // BlockInfo::init initializes all variable entries to the  value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variables,40,/// Helper for process methods to track variables touched each frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:15,Modifiability,variab,variables,15,/// The set of variables that sometimes are not located in their stack home.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:681,Modifiability,variab,variable,681,"///@name joinMethods; /// Functions that implement `join` (the least upper bound) for the; /// join-semilattice types used in the dataflow. There is an explicit bottom; /// value () for some types and and explicit top value () for all types.; /// By definition:; ///; /// Join(A, B) >= A && Join(A, B) >= B; /// Join(A, ) = A; /// Join(A, ) = ; ///; /// These invariants are important for monotonicity.; ///; /// For the map-type functions, all unmapped keys in an empty map are; /// associated with a bottom value (). This represents their values being; /// unknown. Unmapped keys in non-empty maps (joining two maps with a key; /// only present in one) represents either a variable going out of scope or; /// dropped debug info. It is assumed the key is associated with a top value; /// () in this case (unknown location / assignment).; ///@{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:73,Deployability,update,update,73,///@name processMethods; /// Methods to process instructions in order to update the LiveSet (current; /// location information).; ///@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Deployability,Update,Update,4,"/// Update \p LiveSet after encountering an instruction with a DIAssignID; /// attachment, \p I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Deployability,Update,Update,4,"/// Update \p LiveSet after encountering an instruciton without a DIAssignID; /// attachment, \p I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variable,40,/// Add an assignment to memory for the variable /p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,/// Add an assignment to the variable /p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:22,Modifiability,Variab,VariableIDs,22,/// Return the set of VariableIDs corresponding the fragments contained fully; /// within the variable/fragment \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Modifiability,variab,variable,94,/// Return the set of VariableIDs corresponding the fragments contained fully; /// within the variable/fragment \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:18,Modifiability,variab,variables,18,/// Emit info for variables that are fully promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,"/// Run the analysis, adding variable location info to \p FnVarLocs. Returns; /// true if any variable locations have been added to FnVarLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Modifiability,variab,variable,94,"/// Run the analysis, adding variable location info to \p FnVarLocs. Returns; /// true if any variable locations have been added to FnVarLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Deployability,Update,Update,3,// Update the LocKind for all fragments contained within Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:85,Modifiability,variab,variables,85,"// Interpret stack stores that are not tagged as an assignment in memory for; // the variables associated with that address. These stores may not be tagged; // because a) the store cannot be represented using dbg.assigns (non-const; // length or offset) or b) the tag was accidentally dropped during; // optimisations. For these stores we fall back to assuming that the stack; // home is a valid location for the variables. The benefit is that this; // prevents us missing an assignment and therefore incorrectly maintaining; // earlier location definitions, and in many cases it should be a reasonable; // assumption. However, this will occasionally lead to slight; // inaccuracies. The value of a hoisted untagged store will be visible; // ""early"", for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:413,Modifiability,variab,variables,413,"// Interpret stack stores that are not tagged as an assignment in memory for; // the variables associated with that address. These stores may not be tagged; // because a) the store cannot be represented using dbg.assigns (non-const; // length or offset) or b) the tag was accidentally dropped during; // optimisations. For these stores we fall back to assuming that the stack; // home is a valid location for the variables. The benefit is that this; // prevents us missing an assignment and therefore incorrectly maintaining; // earlier location definitions, and in many cases it should be a reasonable; // assumption. However, this will occasionally lead to slight; // inaccuracies. The value of a hoisted untagged store will be visible; // ""early"", for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:6,Modifiability,variab,variables,6,// No variables associated with the store destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variables,20,"// Iterate over the variables that this store affects, add a NoneOrPhi dbg; // and mem def, set lockind to Mem, and emit a location def for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:67,Modifiability,variab,variable,67,// Something has gone wrong if VarsWithStackSlot doesn't contain a variable; // that is linked to a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:46,Modifiability,variab,variable,46,// The StackHomeValue and DebugValue for this variable match so we can; // emit a stack home location here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:46,Modifiability,variab,variable,46,"// The StackHomeValue and DebugValue for this variable do not match. I.e.; // The value currently stored in the stack is not what we'd expect to; // see, so we cannot use emit a stack home location here. Now we will; // look at the live LocKind for the variable and determine an appropriate; // dbg.value to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:253,Modifiability,variab,variable,253,"// The StackHomeValue and DebugValue for this variable do not match. I.e.; // The value currently stored in the stack is not what we'd expect to; // see, so we cannot use emit a stack home location here. Now we will; // look at the live LocKind for the variable and determine an appropriate; // dbg.value to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:86,Modifiability,variab,variable,86,"// There's been an assignment to memory that we were using as a; // location for this variable, and the Assignment doesn't match what; // we'd expect to see in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:97,Modifiability,variab,variable,97,// There's been an assignment to memory and we currently are; // not tracking a location for the variable. Do not emit anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:24,Modifiability,variab,variables,24,// Only bother tracking variables that are at some point stack homed. Other; // variables can be dealt with trivially later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:80,Modifiability,variab,variables,80,// Only bother tracking variables that are at some point stack homed. Other; // variables can be dealt with trivially later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:205,Modifiability,variab,variable,205,"// They match. We can use the stack home because the debug intrinsics; // state that an assignment happened here, and we know that specific; // assignment was the last one to take place in memory for this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:23,Modifiability,variab,variables,23,// Only other tracking variables that are at some point stack homed.; // Other variables can be dealt with trivally later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:79,Modifiability,variab,variables,79,// Only other tracking variables that are at some point stack homed.; // Other variables can be dealt with trivally later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:382,Modifiability,variab,variables,382,"// We have no ID to create an Assignment with so we mark this assignment as; // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine; // the assignment responsible for setting this value.; // This is fine; dbg.values are essentially interchangable with unlinked; // dbg.assigns, and some passes such as mem2reg and instcombine add them to; // PHIs for promoted variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:42,Modifiability,variab,variable,42,// Ignore assignments to zero bits of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:42,Modifiability,variab,variable,42,// Ignore assignments to zero bits of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:300,Modifiability,variab,variables,300,"// II is now a non-debug instruction either with no attached DPValues, or; // with attached processed DPValues. II has not been processed, and all; // debug instructions or DPValues in the frame preceding II have been; // processed.; // We've processed everything in the ""frame"". Now determine which variables; // cannot be represented by a dbg.declare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variable,8,"// If a variable's LocKind is anything other than LocKind::Mem then we; // must note that it cannot be represented with a dbg.declare.; // Note that this check is enough without having to check the result of; // joins() because for join to produce anything other than Mem after; // we've already seen a Mem we'd be joining None or Val with Mem. In that; // case, we've already hit this codepath when we set the LocKind to Val; // or None in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:487,Performance,perform,performed,487,"// Source is used to lookup the value + expression in the debug program if; // the stack slot gets assigned a value earlier than expected. Because; // we're only tracking the one dbg.assign, we can't capture debug PHIs.; // It's unlikely that we're losing out on much coverage by avoiding that; // extra work.; // The Source may differ in this situation:; // Pred.1:; // dbg.assign i32 0, ..., !1, ...; // Pred.2:; // dbg.assign i32 1, ..., !1, ...; // Here the same assignment (!1) was performed in both preds in the source,; // but we can't use either one unless they are identical (e.g. .we don't; // want to arbitrarily pick between constant values).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:280,Safety,avoid,avoiding,280,"// Source is used to lookup the value + expression in the debug program if; // the stack slot gets assigned a value earlier than expected. Because; // we're only tracking the one dbg.assign, we can't capture debug PHIs.; // It's unlikely that we're losing out on much coverage by avoiding that; // extra work.; // The Source may differ in this situation:; // Pred.1:; // dbg.assign i32 0, ..., !1, ...; // Pred.2:; // dbg.assign i32 1, ..., !1, ...; // Here the same assignment (!1) was performed in both preds in the source,; // but we can't use either one unless they are identical (e.g. .we don't; // want to arbitrarily pick between constant values).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:116,Modifiability,variab,variables,116,// Don't bother checking if this is an AllocaInst. We know this; // instruction has no tag which means there are no variables associated; // with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:878,Energy Efficiency,reduce,reduce,878,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,Variab,Variable,20,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:32,Modifiability,Variab,Variables,32,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:55,Modifiability,variab,variable,55,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:100,Modifiability,variab,variable,100,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:351,Modifiability,Variab,Variables,351,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:427,Modifiability,Variab,Variables,427,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:517,Modifiability,variab,variable,517,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:542,Modifiability,variab,variables,542,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:658,Modifiability,variab,variables,658,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:812,Modifiability,variab,variable,812,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,Variab,Variable,10,// Map of Variable: [Fragments].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:192,Deployability,update,update,192,// Iterate over all instructions:; // - dbg.declare -> add single location variable record; // - dbg.* -> Add fragments to FragmentMap; // - untagged store -> Add fragments to FragmentMap and update; // UntaggedStoreVars.; // We need to add fragments for untagged stores too so that we can correctly; // clobber overlapped fragment locations later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:75,Modifiability,variab,variable,75,// Iterate over all instructions:; // - dbg.declare -> add single location variable record; // - dbg.* -> Add fragments to FragmentMap; // - untagged store -> Add fragments to FragmentMap and update; // UntaggedStoreVars.; // We need to add fragments for untagged stores too so that we can correctly; // clobber overlapped fragment locations later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:68,Modifiability,variab,variable,68,// Skip this assignment if the affected bits are outside of the; // variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:118,Modifiability,variab,variable,118,"// FragInfo from calculateFragmentIntersect is nullopt if the; // resultant fragment matches DAI's fragment or entire variable - in; // which case copy the fragment info from DAI. If FragInfo is still; // nullopt after the copy it means ""no fragment info"" instead, which; // is how it is usually interpreted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Cache,Cache,3,// Cache this info for later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Modifiability,Variab,VariableIDs,3,// VariableIDs are 1-based so the variable-tracking bitvector needs; // NumVariables plus 1 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable-tracking,34,// VariableIDs are 1-based so the variable-tracking bitvector needs; // NumVariables plus 1 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:102,Modifiability,variab,variable,102,// The general structure here is inspired by VarLocBasedImpl.cpp; // (LiveDebugValues).; // Build the variable fragment overlap map.; // Note that this pass doesn't handle partial overlaps correctly (FWIW; // neither does LiveDebugVariables) because that is difficult to do and; // appears to be rare occurance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Perform,Perform,3,"// Perform the traversal.; //; // This is a standard ""union of predecessor outs"" dataflow problem. To solve; // it, we perform join() and process() using the two worklist method until; // the LiveIn data for each block becomes unchanging. The ""proof"" that this; // terminates can be put together by looking at the comments around LocKind,; // Assignment, and the various join methods, which show that all the elements; // involved are made up of join-semilattices; LiveIn(n) can only; // monotonically increase in value throughout the dataflow.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:119,Performance,perform,perform,119,"// Perform the traversal.; //; // This is a standard ""union of predecessor outs"" dataflow problem. To solve; // it, we perform join() and process() using the two worklist method until; // the LiveIn data for each block becomes unchanging. The ""proof"" that this; // terminates can be put together by looking at the comments around LocKind,; // Assignment, and the various join methods, which show that all the elements; // involved are made up of join-semilattices; LiveIn(n) can only; // monotonically increase in value throughout the dataflow.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,Safety,avoid,avoid,47,// We track what is on the pending worklist to avoid inserting the same; // thing twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Modifiability,variab,variables,45,// Identify and add defs for single location variables.; //; // Go through all of the defs that we plan to add. If the aggregate variable; // it's a part of is not in the NotAlwaysStackHomed set we can emit a single; // location def and omit the rest. Add an entry to AlwaysStackHomed so that; // we can identify those uneeded defs later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:129,Modifiability,variab,variable,129,// Identify and add defs for single location variables.; //; // Go through all of the defs that we plan to add. If the aggregate variable; // it's a part of is not in the NotAlwaysStackHomed set we can emit a single; // location def and omit the rest. Add an entry to AlwaysStackHomed so that; // we can identify those uneeded defs later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:195,Energy Efficiency,reduce,reduce,195,"// Skip complex cases such as when different fragments of a variable have; // been split into different allocas. Skipping in this case means falling; // back to using a list of defs (which could reduce coverage, but is no; // less correct).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:60,Modifiability,variab,variable,60,"// Skip complex cases such as when different fragments of a variable have; // been split into different allocas. Skipping in this case means falling; // back to using a list of defs (which could reduce coverage, but is no; // less correct).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:88,Modifiability,variab,variable,88,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:200,Modifiability,variab,variable,200,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:147,Testability,assert,assert,147,// TODO: When more complex cases are handled VarLoc.Expr should be; // built appropriately rather than always using an empty DIExpression.; // The assert below is a reminder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Modifiability,variab,variable,11,// If this variable is always stack homed then we have already inserted a; // dbg.declare and deleted this dbg.value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:79,Modifiability,variab,variables,79,"// Go through every block, translating debug intrinsics for fully promoted; // variables into FnVarLocs location defs. No analysis required for these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variables,8,// Skip variables that haven't been promoted - we've dealt with those; // already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Availability,redundant,redundant,11,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:168,Modifiability,variab,variable,168,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Safety,redund,redundant,11,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:39,Usability,Clear,Clear,39,// Sequence of consecutive defs ended. Clear map for the next one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variables,20,// Cutoff for large variables to prevent expensive bitvector operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:104,Modifiability,variab,variables,104,"// If the size is unknown (0) then keep this location def to be safe.; // Do the same for defs of large variables, which would be expensive; // to represent with a BitVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:64,Safety,safe,safe,64,"// If the size is unknown (0) then keep this location def to be safe.; // Do the same for defs of large variables, which would be expensive; // to represent with a BitVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Availability,Redundant,Redundant,3,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Safety,Redund,Redundant,3,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Availability,redundant,redundant,11,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Availability,redundant,redundant,108,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:143,Modifiability,variab,variable,143,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Safety,redund,redundant,11,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Safety,redund,redundant,108,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:421,Modifiability,Variab,Variable,421,"// Do extra work to ensure that we remove semantically unimportant undefs.; //; // This is to work around the fact that SelectionDAG will hoist dbg.values; // using argument values to the top of the entry block. That can move arg; // dbg.values before undef and constant dbg.values which they previously; // followed. The easiest thing to do is to just try to feed SelectionDAG; // input it's happy with.; //; // Map of {Variable x: Fragments y} where the fragments y of variable x have; // have at least one non-undef location defined already. Don't use directly,; // instead call DefineBits and HasDefinedBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:471,Modifiability,variab,variable,471,"// Do extra work to ensure that we remove semantically unimportant undefs.; //; // This is to work around the fact that SelectionDAG will hoist dbg.values; // using argument values to the top of the entry block. That can move arg; // dbg.values before undef and constant dbg.values which they previously; // followed. The easiest thing to do is to just try to feed SelectionDAG; // input it's happy with.; //; // Map of {Variable x: Fragments y} where the fragments y of variable x have; // have at least one non-undef location defined already. Don't use directly,; // instead call DefineBits and HasDefinedBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:7,Modifiability,variab,variable,7,"// Any variable linked to an instruction is considered; // interesting. Ideally we only need to check Allocas, however, a; // DIAssignID might get dropped from an alloca but not stores. In that; // case, we need to consider the variable interesting for NFC behaviour; // with this change. TODO: Consider only looking at allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:228,Modifiability,variab,variable,228,"// Any variable linked to an instruction is considered; // interesting. Ideally we only need to check Allocas, however, a; // DIAssignID might get dropped from an alloca but not stores. In that; // case, we need to consider the variable interesting for NFC behaviour; // with this change. TODO: Consider only looking at allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:59,Modifiability,variab,variables,59,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:127,Modifiability,variab,variables,127,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Performance,perform,perform,94,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,Energy Efficiency,reduce,reduce,101,// Use a scope block to clean up AssignmentTrackingLowering before running; // MemLocFragmentFill to reduce peak memory consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:120,Energy Efficiency,consumption,consumption,120,// Use a scope block to clean up AssignmentTrackingLowering before running; // MemLocFragmentFill to reduce peak memory consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Availability,redundant,redundant,10,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:56,Energy Efficiency,consumption,consumption,56,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Safety,redund,redundant,10,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:76,Safety,avoid,avoiding,76,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear previous results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:656,Performance,load,load-linked,656,"//===- AtomicExpandPass.cpp - Expand atomic instructions ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass (at IR level) to replace atomic instructions with; // __atomic_* library calls, or target specific instruction which implement the; // same semantics in a way which better fits the target backend. This can; // include the use of (intrinsic-based) load-linked/store-conditional loops,; // AtomicCmpXchg, or type coercions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:73,Modifiability,extend,extend,73,"// TODO: when we're ready to make the change at the IR level, we can; // extend convertCmpXchgToInteger for floating point too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:141,Availability,failure,failure,141,"// If a compare and swap is lowered to LL/SC, we can do smarter fence; // insertion, with a stronger one on the success path than on the; // failure path. As a result, fence insertion is directly done by; // expandAtomicCmpXchg in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:76,Performance,load,load,76,// There are two different ways of expanding RMW instructions:; // - into a load if it is idempotent; // - into a Cmpxchg/LL-SC loop otherwise; // we try them in that order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:22,Performance,load,load,22,/// Convert an atomic load of a non-integral type to an integer load of the; /// equivalent bitwidth. See the function comment on; /// convertAtomicStoreToIntegerType for background.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:64,Performance,load,load,64,/// Convert an atomic load of a non-integral type to an integer load of the; /// equivalent bitwidth. See the function comment on; /// convertAtomicStoreToIntegerType for background.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Performance,load,load-linked,26,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:95,Performance,load,loads,95,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:131,Performance,load,load,131,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:196,Usability,learn,learned,196,"/// Convert an atomic store of a non-integral type to an integer store of the; /// equivalent bitwidth. We used to not support floating point or vector; /// atomics in the IR at all. The backends learned to deal with the bitcast; /// idiom because that was the only way of expressing the notion of a atomic; /// float or vector store. The long term plan is to teach each backend to; /// instruction select from the original atomic store, but as a migration; /// mechanism, we convert back to the old format which the backends understand.; /// Each backend will need individual work to recognize the new format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:256,Availability,mask,masks,256,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:356,Availability,down,down,356,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:564,Availability,Mask,Mask,564,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:579,Availability,mask,mask,579,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:723,Availability,Mask,Mask,723,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:454,Performance,load,loaded,454,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:536,Performance,load,loaded,536,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:599,Performance,load,loaded,599,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:670,Performance,load,loaded,670,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:27,Availability,mask,masked,27,"/// Emit IR to implement a masked version of a given atomicrmw; /// operation. (That is, only the bits under the Mask should be; /// affected by the operation)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:113,Availability,Mask,Mask,113,"/// Emit IR to implement a masked version of a given atomicrmw; /// operation. (That is, only the bits under the Mask should be; /// affected by the operation)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:80,Availability,Mask,MaskedMerge,80,// TODO: update to use; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge in order; // to merge bits from two values without requiring PMV.Inv_Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:9,Deployability,update,update,9,// TODO: update to use; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge in order; // to merge bits from two values without requiring PMV.Inv_Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:39,Availability,mask,masked,39,// The other arithmetic ops need to be masked into place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:66,Availability,down,down,66,"// Finally, other ops will operate on the full value, so truncate down to; // the original size, and expand out again after doing the; // operation. Bitcasts will be inserted for FP values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:258,Availability,failure,failure,258,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:323,Availability,mask,mask,323,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:698,Availability,failure,failure,698,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1126,Availability,failure,failure,1126,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1155,Availability,failure,failure,1155,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:461,Performance,load,load,461,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:37,Availability,mask,mask,37,"// Load the entire current word, and mask into place the expected and new; // values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Performance,Load,Load,3,"// Load the entire current word, and mask into place the expected and new; // values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Availability,Mask,Mask,3,// Mask/Or the expected and new values into place in the loaded word.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:57,Performance,load,loaded,57,// Mask/Or the expected and new values into place in the loaded word.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:20,Availability,failure,failure,20,// partword.cmpxchg.failure:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:8,Availability,failure,failure,8,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:33,Availability,mask,masked-out,33,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:139,Availability,mask,masked-in,139,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:56,Performance,load,loaded,56,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:106,Safety,abort,abort,106,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:34,Modifiability,extend,extended,34,"// The value operand must be sign-extended for signed min/max so that the; // target's signed comparison instructions can be used. Otherwise, just; // zero-ext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:139,Performance,load,loaded,139,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:149,Performance,load,load,149,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:191,Performance,load,loaded,191,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:286,Deployability,update,update,286,"/// Convert an atomic cmpxchg of a non-integral type to an integer cmpxchg of; /// the equivalent bitwidth. We used to not support pointer cmpxchg in the; /// IR. As a migration step, we convert back to what use to be the standard; /// way to represent a pointer cmpxchg so that we can update backends one by; /// one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:425,Availability,down,down,425,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:53,Deployability,release,release,53,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:250,Performance,load,load-linked,250,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:529,Safety,avoid,avoid,529,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:306,Testability,log,logic,306,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:554,Testability,log,logic,554,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:39,Deployability,release,release,39,"// There's no overhead for sinking the release barrier in a weak cmpxchg, so; // do it even on minsize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:877,Availability,failure,failure,877,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1149,Availability,failure,failure,1149,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1417,Availability,failure,failure,1417,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1437,Availability,failure,failure,1437,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1550,Availability,failure,failure,1550,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1667,Availability,failure,failure,1667,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:602,Deployability,release,releasedload,602,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:625,Deployability,release,releasedload,625,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:644,Deployability,update,updated,644,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:726,Deployability,update,updated,726,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:855,Deployability,release,releasedload,855,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:897,Deployability,release,releasedload,897,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:916,Deployability,release,releasedload,916,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:964,Deployability,release,releasedload,964,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1007,Deployability,release,releasedload,1007,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1049,Deployability,release,releasedload,1049,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1303,Deployability,release,releasedload,1303,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1330,Deployability,release,releasedload,1330,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:197,Performance,load,load,197,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:530,Performance,load,loaded,530,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:676,Performance,load,loaded,676,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:932,Performance,load,load,932,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1241,Performance,load,loaded,1241,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1505,Performance,load,loaded,1505,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1525,Performance,load,loaded,1525,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1566,Performance,load,loaded,1566,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1681,Performance,load,loaded,1681,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1710,Performance,load,loaded,1710,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1770,Performance,load,loaded,1770,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Deployability,Update,Update,3,// Update PHI node in TryStoreBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:198,Energy Efficiency,monitor,monitor,198,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:115,Performance,load,load-linked,115,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:175,Usability,clear,clearing,175,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:171,Performance,load,loaded,171,"// Finally, we have control-flow based knowledge of whether the cmpxchg; // succeeded or not. We expose this to later passes by converting any; // subsequent ""icmp eq/ne %loaded, %oldval"" into a use of an appropriate; // PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:97,Security,expose,expose,97,"// Finally, we have control-flow based knowledge of whether the cmpxchg; // succeeded or not. We expose this to later passes by converting any; // subsequent ""icmp eq/ne %loaded, %oldval"" into a use of an appropriate; // PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:65,Performance,load,loaded,65,"// Look for any users of the cmpxchg that are just comparing the loaded value; // against the desired one, and replace them with the CFG-derived version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:132,Performance,load,load,132,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:188,Performance,load,loaded,188,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:276,Performance,load,loaded,276,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:325,Performance,load,loaded,325,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:108,Performance,load,load,108,"// The split call above ""helpfully"" added a branch at the end of BB (to the; // wrong place), but we want a load. It's easiest to just remove; // the branch entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Security,expose,exposed,26,// Note: This function is exposed externally by AtomicExpandUtils.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:358,Availability,reliab,reliable,358,"// TODO: ""LargestSize"" is an approximation for ""largest type that; // you can express in C"". It seems to be the case that int128 is; // supported on all 64-bit platforms, otherwise only up to 64-bit; // integers are supported. If we get this wrong, then we'll try to; // call a sized libcall that doesn't actually exist. There should; // really be some more reliable way in LLVM of determining integer; // sizes which are valid in the target's C ABI...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Availability,avail,available,26,// No atomic libcalls are available for max/min/umax/umin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:12,Integrability,rout,routine,12,"// A helper routine for the above expandAtomic*ToLibcall functions.; //; // 'Libcalls' contains an array of enum values for the particular; // ATOMIC libcalls to be emitted. All of the other arguments besides; // 'I' are extracted from the Instruction subclass by the; // caller. Depending on the particular call, some will be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:280,Integrability,Depend,Depending,280,"// A helper routine for the above expandAtomic*ToLibcall functions.; //; // 'Libcalls' contains an array of enum values for the particular; // ATOMIC libcalls to be emitted. All of the other arguments besides; // 'I' are extracted from the Instruction subclass by the; // caller. Depending on the particular call, some will be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1088,Integrability,depend,depending,1088,"// Build up the function call. There's two kinds. First, the sized; // variants. These calls are going to be one of the following (with; // N=1,2,4,8,16):; // iN __atomic_load_N(iN *ptr, int ordering); // void __atomic_store_N(iN *ptr, iN val, int ordering); // iN __atomic_{exchange|fetch_*}_N(iN *ptr, iN val, int ordering); // bool __atomic_compare_exchange_N(iN *ptr, iN *expected, iN desired,; // int success_order, int failure_order); //; // Note that these functions can be used for non-integer atomic; // operations, the values just need to be bitcast to integers on the; // way in and out.; //; // And, then, the generic variants. They look like the following:; // void __atomic_load(size_t size, void *ptr, void *ret, int ordering); // void __atomic_store(size_t size, void *ptr, void *val, int ordering); // void __atomic_exchange(size_t size, void *ptr, void *val, void *ret,; // int ordering); // bool __atomic_compare_exchange(size_t size, void *ptr, void *expected,; // void *desired, int success_order,; // int failure_order); //; // The different signatures are built up depending on the; // 'UseSizedLibcall', 'CASExpected', 'ValueOperand', and 'HasResult'; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1179,Modifiability,variab,variables,1179,"// Build up the function call. There's two kinds. First, the sized; // variants. These calls are going to be one of the following (with; // N=1,2,4,8,16):; // iN __atomic_load_N(iN *ptr, int ordering); // void __atomic_store_N(iN *ptr, iN val, int ordering); // iN __atomic_{exchange|fetch_*}_N(iN *ptr, iN val, int ordering); // bool __atomic_compare_exchange_N(iN *ptr, iN *expected, iN desired,; // int success_order, int failure_order); //; // Note that these functions can be used for non-integer atomic; // operations, the values just need to be bitcast to integers on the; // way in and out.; //; // And, then, the generic variants. They look like the following:; // void __atomic_load(size_t size, void *ptr, void *ret, int ordering); // void __atomic_store(size_t size, void *ptr, void *val, int ordering); // void __atomic_exchange(size_t size, void *ptr, void *val, void *ret,; // int ordering); // bool __atomic_compare_exchange(size_t size, void *ptr, void *expected,; // void *desired, int success_order,; // int failure_order); //; // The different signatures are built up depending on the; // 'UseSizedLibcall', 'CASExpected', 'ValueOperand', and 'HasResult'; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:191,Modifiability,extend,extend,191,"// 'ptr' argument.; // note: This assumes all address spaces share a common libfunc; // implementation and that addresses are convertable. For systems without; // that property, we'd need to extend this mechanism to support AS-specific; // families of atomic intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:37,Performance,load,load,37,"// The final result from the CAS is {load of 'expected' alloca, bool result; // from call}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cloning when the block contains non-duplicable instructions.; // CFI instructions are marked as non-duplicable only because of Darwin,; // so we exclude them from this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:1089,Performance,optimiz,optimized,1089,"Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BasicBlockSections implementation.; //; // The purpose of this pass is to assign sections to basic blocks when; // -fbasic-block-sections= option is used. Further, with profile information; // only the subset of basic blocks with profiles are placed in separate sections; // and the rest are grouped in a cold section. The exception handling blocks are; // treated specially to ensure they are all in one seciton.; //; // Basic Block Sections; // ====================; //; // With option, -fbasic-block-sections=list, every function may be split into; // clusters of basic blocks. Every cluster will be emitted into a separate; // section with its basic blocks sequenced in the given order. To get the; // optimized performance, the clusters must form an optimal BB layout for the; // function. We insert a symbol at the beginning of every cluster's section to; // allow the linker to reorder the sections in any arbitrary sequence. A global; // order of these sections would encapsulate the function layout.; // For example, consider the following clusters for a function foo (consisting; // of 6 basic blocks 0, 1, ..., 5).; //; // 0 2; // 1 3 5; //; // * Basic blocks 0 and 2 are placed in one section with symbol `foo`; // referencing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:1099,Performance,perform,performance,1099,"Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BasicBlockSections implementation.; //; // The purpose of this pass is to assign sections to basic blocks when; // -fbasic-block-sections= option is used. Further, with profile information; // only the subset of basic blocks with profiles are placed in separate sections; // and the rest are grouped in a cold section. The exception handling blocks are; // treated specially to ensure they are all in one seciton.; //; // Basic Block Sections; // ====================; //; // With option, -fbasic-block-sections=list, every function may be split into; // clusters of basic blocks. Every cluster will be emitted into a separate; // section with its basic blocks sequenced in the given order. To get the; // optimized performance, the clusters must form an optimal BB layout for the; // function. We insert a symbol at the beginning of every cluster's section to; // allow the linker to reorder the sections in any arbitrary sequence. A global; // order of these sections would encapsulate the function layout.; // For example, consider the following clusters for a function foo (consisting; // of 6 basic blocks 0, 1, ..., 5).; //; // 0 2; // 1 3 5; //; // * Basic blocks 0 and 2 are placed in one section with symbol `foo`; // referencing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:3419,Testability,log,logic,3419,"ing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be reordered by the linker.; // The compiler should make these fallthroughs explicit by adding; // unconditional jumps..; //; // 2. All inter-cluster branch targets would now need to be resolved by the; // linker as they cannot be calculated during compile time. This is done; // using static relocations. Further, the compiler tries to use short branch; // instructions on some ISAs for small branch offsets. This is not possible; // for inter-cluster branches as the offset is not determined at compile; // time, and therefore, long branch instructions have to be used for those.; //; // 3. Debug Information (DebugInfo) and Call Frame Information (CFI) emission; // needs special handling with basic block sections. DebugInfo needs to be; // emitted with more relocations as basic block sections can break a; // function into potentially several disjoint pieces, and CFI needs to be; // emitted per cluster. This also bloats the object file and binary sizes.; //; // Basic Block Labels; // ==================; //; // With -fbasic-block-sections=labels, we encode the offsets of BB addresses of; // every function into the .llvm_bb_addr_map section. Along with the function; // symbols, this allows for mapping of virtual addresses in PMU profiles back to; // the corresponding basic blocks. This logic is implemented in AsmPrinter. This; // pass only assigns the BBSectionType of every function to ``labels``.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:98,Performance,optimiz,optimizations,98,"// Placing the cold clusters in a separate section mitigates against poor; // profiles and allows optimizations such as hugepage mapping to be applied at a; // section granularity. Defaults to "".text.split."" which is recognized by lld; // via the `-z keep-text-section-prefix` flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:17,Deployability,update,updates,17,// This function updates and optimizes the branching instructions of every basic; // block in a given function to account for changes in the layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:29,Performance,optimiz,optimizes,29,// This function updates and optimizes the branching instructions of every basic; // block in a given function to account for changes in the layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:13,Performance,optimiz,optimize,13,"// We do not optimize branches for machine basic blocks ending sections, as; // their adjacent block might be reordered by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:27,Performance,optimiz,optimize,27,// It might be possible to optimize branches by flipping the branch; // condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:8,Modifiability,variab,variable,8,"// This variable stores the section ID of the cluster containing eh_pads (if; // all eh_pads are one cluster). If more than one cluster contain eh_pads, we; // set it equal to ExceptionSectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:67,Deployability,update,updated,67,"// If we already have one cluster containing eh_pads, this must be updated; // to ExceptionSectionID. Otherwise, we set it equal to the current; // section ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:42,Deployability,update,update,42,"// After reordering basic blocks, we must update basic block branches to; // insert explicit fallthrough branches when required and optimize branches; // when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:132,Performance,optimiz,optimize,132,"// After reordering basic blocks, we must update basic block branches to; // insert explicit fallthrough branches when required and optimize branches; // when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:91,Performance,optimiz,optimizing,91,"// Check for source drift. If the source has changed since the profiles; // were obtained, optimizing basic blocks might be sub-optimal.; // This only applies to BasicBlockSection::List as it creates; // clusters of basic blocks using basic block ids. Source drift can; // invalidate these groupings leading to sub-optimal code generation with; // regards to performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:359,Performance,perform,performance,359,"// Check for source drift. If the source has changed since the profiles; // were obtained, optimizing basic blocks might be sub-optimal.; // This only applies to BasicBlockSection::List as it creates; // clusters of basic blocks using basic block ids. Source drift can; // invalidate these groupings leading to sub-optimal code generation with; // regards to performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:59,Security,access,accessing,59,// Renumber blocks before sorting them. This is useful for accessing the; // original layout positions and finding the original fallthroughs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:10,Availability,error,error,10,// Report error when multiple profiles have been specified for the same; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:52,Safety,avoid,avoid,52,// We won't need DIFilename anymore. Clean it up to avoid its application; // on the next function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:10,Availability,error,error,10,// Report error when multiple profiles have been specified for the same; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:719,Performance,load,loaded,719,"// Basic Block Sections can be enabled for a subset of machine basic blocks.; // This is done by passing a file containing names of functions for which basic; // block sections are desired. Additionally, machine basic block ids of the; // functions can also be specified for a finer granularity. Moreover, a cluster; // of basic blocks could be assigned to the same section.; // Optionally, a debug-info filename can be specified for each function to allow; // distinguishing internal-linkage functions of the same name.; // A file with basic block sections for all of function main and three blocks; // for function foo (of which 1 and 2 are placed in a cluster) looks like this:; // (Profile for function foo is only loaded when its debug-info filename; // matches 'path/to/foo_file.cc').; // ----------------------------; // list.txt:; // !main; // !foo M=path/to/foo_file.cc; // !!1 2; // !!4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:50,Availability,down,downstream,50,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:39,Deployability,integrat,integrated,39,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:39,Integrability,integrat,integrated,39,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp:643,Integrability,interface,interface,643,"//===- BasicTargetTransformInfo.cpp - Basic target-independent TTI impl ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the implementation of a basic TargetTransformInfo pass; /// predicated on the target abstractions present in the target independent; /// code generator. It uses these (primarily TargetLowering) to model as much; /// of the TTI query interface as possible. It is included by most targets so; /// that they can specialize only a small subset of the query space.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Performance,Throttle,Throttle,3,// Throttle for huge numbers of predecessors (compile speed problems),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,Integrability,Wrap,Wrap,23,/// BranchFolderPass - Wrap branch folder in a machine function pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Safety,Avoid,Avoid,3,// Avoid matching if this pointer gets reused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Deployability,Update,Update,3,// Update call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:195,Security,Hash,HashMachineInstr,195,//===----------------------------------------------------------------------===//; // Tail Merging of Blocks; //===----------------------------------------------------------------------===//; /// HashMachineInstr - Compute a hash value for MI and its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:224,Security,hash,hash,224,//===----------------------------------------------------------------------===//; // Tail Merging of Blocks; //===----------------------------------------------------------------------===//; /// HashMachineInstr - Compute a hash value for MI and its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:138,Security,hash,hash,138,// Merge in bits from the operand if easy. We can't use MachineOperand's; // hash_code here because it's not deterministic and we sort by hash value; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:4,Security,Hash,HashEndOfMBB,4,/// HashEndOfMBB - Hash the last instruction in the MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:19,Security,Hash,Hash,19,/// HashEndOfMBB - Hash the last instruction in the MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:213,Performance,optimiz,optimizations,213,// FIXME: This check is dubious. It's used to get around a problem where; // people incorrectly expect inline asm directives to remain in the same; // relative order. This is untenable because normal compiler; // optimizations (like this one) may reorder and/or merge these; // directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Modifiability,inherit,inherits,10,// NewMBB inherits CurMBB's block frequency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:199,Performance,optimiz,optimize,199,"// CurMBB needs to add an unconditional branch to SuccMBB (we removed these; // branches temporarily for tail merging). In the case where CurMBB ends; // with a conditional branch to the next block, optimize by reversing the; // test and conditionally branching to SuccMBB instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:229,Testability,test,test,229,"// CurMBB needs to add an unconditional branch to SuccMBB (we removed these; // branches temporarily for tail merging). In the case where CurMBB ends; // with a conditional branch to the next block, optimize by reversing the; // test and conditionally branching to SuccMBB instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:892,Usability,undo,undoing,892,"/// ProfitableToMerge - Check if two machine basic blocks have a common tail; /// and decide if it would be profitable to merge those tails. Return the; /// length of the common tail and iterators to the first common instruction; /// in each block.; /// MBB1, MBB2 The blocks to check; /// MinCommonTailLength Minimum size of tail block to be merged.; /// CommonTailLen Out parameter to record the size of the shared tail between; /// MBB1 and MBB2; /// I1, I2 Iterator references that will be changed to point to the first; /// instruction in the common tail shared by MBB1,MBB2; /// SuccBB A common successor of MBB1, MBB2 which are in a canonical form; /// relative to SuccBB; /// PredBB The layout predecessor of SuccBB, if any.; /// EHScopeMembership map from block to EH scope #.; /// AfterPlacement True if we are merging blocks after layout. Stricter; /// thresholds apply to prevent undoing tail-duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:116,Safety,avoid,avoid,116,// Move the iterators to the beginning of the MBB if we only got debug; // instructions before the tail. This is to avoid splitting a block when we; // only got debug instructions before the tail (to be invariant on -g).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:334,Energy Efficiency,reduce,reduce,334,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:144,Safety,abort,abort,144,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:188,Integrability,depend,depends,188,"// If both blocks are identical and end in a branch, merge them unless they; // both have a fallthrough predecessor and successor.; // We can only do this after block placement because it depends on whether; // there are fallthroughs, and we don't know until after layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:13,Performance,optimiz,optimizing,13,"// If we are optimizing for code size, 2 instructions in common is enough if; // we don't have to split a block. At worst we will be introducing 1 new; // branch instruction, which is likely to be smaller than the 2; // instructions that would be deleted in the merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:111,Testability,log,logic,111,// Skip the register if we are about to add one of its super registers.; // TODO: Common this up with the same logic in addLineIns().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:11,Security,hash,hash,11,// Sort by hash value so that blocks with identical end sequences sort; // together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:60,Security,hash,hash,60,"// Build SameTails, identifying the set of blocks with this hash code; // and with the maximum number of instructions in common.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:124,Security,hash,hash,124,"// If we didn't find any pair that has at least MinCommonTailLength; // instructions in common, remove all blocks with this hash code and retry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,Safety,avoid,avoid,31,"// If this is a large problem, avoid visiting the same basic blocks; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:725,Performance,Optimiz,OptimizeBranches,725,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:752,Usability,undo,undo,752,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:868,Usability,undo,undoing,868,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:401,Modifiability,flexible,flexible,401,"// Bail if merging after placement and IBB is the loop header because; // -- If merging predecessors that belong to the same loop as IBB, the; // common tail of merged predecessors may become the loop top if block; // placement is called again and the predecessors may branch to this common; // tail and require more branches. This can be relaxed if; // MachineBlockPlacement::findBestLoopTop is more flexible.; // --If merging predecessors that do not belong to the same loop as IBB, the; // loop info of IBB's loop and the other loops may be affected. Calling the; // block placement again may make big change to the layout and eliminate the; // reason to do tail merging here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,Safety,avoid,avoid,31,"// If this is a large problem, avoid visiting the same basic blocks multiple; // times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Branch Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:53,Usability,clear,clearly,53,"/// IsBetterFallthrough - Return true if it would be clearly better to; /// fall-through to MBB1 than to fall through into MBB2. This has to return; /// a strict ordering, returning true for both (MBB1,MBB2) and (MBB2,MBB1) will; /// result in infinite loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:148,Performance,optimiz,optimize,148,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:209,Testability,assert,assert,209,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,Usability,simpl,simple,23,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:17,Usability,clear,clear,17,// If there is a clear successor ordering we make sure that one block; // will fall through to the next,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:261,Usability,simpl,simple,261,"// Try to salvage DBG_VALUE instructions from an otherwise empty block. If such; // a basic block is removed we would lose the debug information unless we have; // copied the information to a predecessor/successor.; //; // TODO: This function only handles some simple cases. An alternative would be; // to run a heavier analysis, such as the LiveDebugValues pass, before we do; // branch folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:230,Performance,optimiz,optimized,230,"// If this block is empty, make everyone use its fall-through, not the block; // explicitly. Landing pads should not do this since the landing-pad table; // points to this block. Blocks with their addresses taken shouldn't be; // optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:9,Usability,Simpl,Simplify,9,// TODO: Simplify preds to not branch here if possible!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:9,Modifiability,rewrite,rewrite,9,"// Don't rewrite to a landing pad fallthough. That could lead to the case; // where a BB jumps to more than one landing pad.; // TODO: Is it ever worth rewriting predecessors which don't already; // jump to a landing pad, and so can safely jump to the fallthrough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:233,Safety,safe,safely,233,"// Don't rewrite to a landing pad fallthough. That could lead to the case; // where a BB jumps to more than one landing pad.; // TODO: Is it ever worth rewriting predecessors which don't already; // jump to a landing pad, and so can safely jump to the fallthrough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all predecessors of the old block to go to the fallthrough; // instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:42,Deployability,update,update,42,"// If MBB was the target of a jump table, update jump tables to go to the; // fallthrough instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:26,Usability,simpl,simplify,26,// Check to see if we can simplify the terminator of the block before this; // one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:206,Usability,Simpl,SimplifyCFG,206,"// If the previous block unconditionally falls through to this block and; // this block has no other predecessors, move the contents of this block; // into the prior block. This doesn't usually happen when SimplifyCFG; // has been used, but it can happen if tail merging splits a fall-through; // predecessor of a block.; // This has to check PrevBB->succ_size() because EH edges are ignored by; // analyzeBranch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Availability,redundant,redundant,10,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Safety,redund,redundant,10,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:115,Safety,abort,abort,115,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:430,Testability,assert,asserts,430,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:467,Testability,assert,assert,467,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:259,Usability,clear,clearly,259,"// We have to be careful that the succs of PredBB aren't both no-successor; // blocks. If neither have successors and if PredBB is the second from; // last block in the function, we'd just keep swapping the two blocks for; // last. Only do the swap if one is clearly better to fall through than; // the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:251,Safety,risk,risk,251,"// If the predecessor is falling through to this block, we could reverse; // the branch condition and fold the tail call into that. However, after; // that we might have to re-arrange the CFG to fall through to the other; // block and there is a high risk of regressing code size rather than; // improving it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:95,Deployability,update,updates,95,"// If the prior block falls through into us, turn it into an; // explicit branch to us to make updates simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:103,Usability,simpl,simpler,103,"// If the prior block falls through into us, turn it into an; // explicit branch to us to make updates simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:226,Safety,avoid,avoid,226,"// If the current block doesn't fall through, just move it.; // If the current block can fall through and does not end with a; // conditional branch, we need to append an unconditional jump to; // the (current) next block. To avoid a possible compile-time; // infinite loop, move blocks only backward in this case.; // Also, if there are already 2 branches here, we cannot add a third;; // this means we have the case; // Bcc next; // B elsewhere; // next:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:294,Performance,perform,perform,294,"// Okay, there is no really great place to put this block. If, however,; // the block before this one would be a fall-through if this block were; // removed, move this block to the end of the function. There is no real; // advantage in ""falling through"" to an EH block, so we don't want to; // perform this transformation for that case.; //; // Also, Windows EH introduced the possibility of an arbitrary number of; // successors to a given block. The analyzeBranch call does not consider; // exception handling and so we can get in a state where a block; // containing a call is followed by multiple EH blocks that would be; // rotated infinitely at the end of the function if the transformation; // below were performed for EH ""FallThrough"" blocks. Therefore, even if; // that appears not to be happening anymore, we should assume that it is; // possible and not remove the ""!FallThrough()->isEHPad"" condition below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:712,Performance,perform,performed,712,"// Okay, there is no really great place to put this block. If, however,; // the block before this one would be a fall-through if this block were; // removed, move this block to the end of the function. There is no real; // advantage in ""falling through"" to an EH block, so we don't want to; // perform this transformation for that case.; //; // Also, Windows EH introduced the possibility of an arbitrary number of; // successors to a given block. The analyzeBranch call does not consider; // exception handling and so we can get in a state where a block; // containing a call is followed by multiple EH blocks that would be; // rotated infinitely at the end of the function if the transformation; // below were performed for EH ""FallThrough"" blocks. Therefore, even if; // that appears not to be happening anymore, we should assume that it is; // possible and not remove the ""!FallThrough()->isEHPad"" condition below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:509,Safety,safe,safety,509,"/// findHoistingInsertPosAndDeps - Find the location to move common instructions; /// in successors to. The location is usually just before the terminator,; /// however if the terminator is a conditional branch and its previous; /// instruction is the flag setting instruction, the previous instruction is; /// the preferred location. This function also gathers uses and defs of the; /// instructions from the insertion point to the end of the block. The data is; /// used by HoistCommonCodeInSuccs to ensure safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:132,Safety,safe,safely,132,"// If the terminator is the only instruction in the block and Uses is not; // empty (or we would have returned above), we can still safely hoist; // instructions just before the terminator as long as the Defs/Uses are not; // violated (which is checked in HoistCommonCodeInSuccs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:209,Performance,optimiz,optimization,209,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:199,Safety,abort,abort,199,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:247,Safety,avoid,avoid,247,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:47,Integrability,rout,routine,47,// Find out what registers are live. Note this routine is ignoring other live; // registers which are only used by instructions in successor blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:16,Performance,optimiz,optimization,16,"// Restrict the optimization to cases where MBB is the only predecessor,; // it is an obvious win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:53,Availability,mask,masks,53,// Don't attempt to hoist instructions with register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Safety,Avoid,Avoid,3,// Avoid clobbering a register that's used by the instruction at; // the point of insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:30,Deployability,update,update,30,// Track local defs so we can update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:55,Performance,optimiz,optimizations,55,"/// Perhaps branch folding, tail merging and other CFG optimizations on the; /// given function. Block placement changes the layout and may create new; /// tail merging opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:61,Security,hash,hash,61,/// Look through all the blocks in MergePotentials that have hash CurHash; /// (guaranteed to match the last element). Build the vector SameTails of; /// all those that have the (same) largest number of instructions in common; /// of any pair of these blocks. SameTails entries contain an iterator into; /// MergePotentials (from which the MachineBasicBlock can be found) and a; /// MachineBasicBlock::iterator into that MBB indicating the instruction; /// where the matching code sequence begins. Order of elements in SameTails; /// is the reverse of the order in which those blocks appear in; /// MergePotentials (where they are not necessarily consecutive).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:27,Security,hash,hash,27,"/// Remove all blocks with hash CurHash from MergePotentials, restoring; /// branches at ends of blocks as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:16,Performance,optimiz,optimize,16,/// Analyze and optimize control flow related to the specified block. This; /// is never called on the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:107,Deployability,Update,Update,107,"/// Split the basic block containing MI into two blocks, which are joined by; /// an unconditional branch. Update data structures and renumber blocks to; /// account for this change and returns the newly created block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:164,Availability,avail,available,164,// Add an unconditional branch from OrigBB to NewBB.; // Note the new unconditional branch is not being recorded.; // There doesn't seem to be meaningful DebugInfo available; this doesn't; // correspond to anything in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:76,Deployability,update,updateTerminator,76,// Cleanup potential unconditional branch to successor block.; // Note that updateTerminator may change the size of the blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:93,Safety,avoid,avoid,93,"// Since cross-section conditional branches to the cold section are rarely; // taken, try to avoid inverting the condition. Instead, add a ""trampoline; // branch"", which unconditionally branches to the branch destination. Place; // the trampoline branch at the end of the function and retarget the; // conditional branch to the trampoline.; // tbz L1; // =>; // tbz L1Trampoline; // ...; // L1Trampoline: b L1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the successor lists to include the trampoline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:56,Usability,simpl,simply,56,// Last MI in the BB is an unconditional branch. We can simply invert the; // condition and swap destinations:; // beq L1; // b L2; // =>; // bne L2; // b L1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,"// Update the succesor lists according to the transformation to follow.; // Do it here since if there's no split, no update is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:117,Deployability,update,update,117,"// Update the succesor lists according to the transformation to follow.; // Do it here since if there's no split, no update is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the successor lists according to the transformation to follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update successors and predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the offset starting from the previous block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:215,Safety,avoid,avoid,215,"// Expand the unconditional branch first if necessary. If there is a; // conditional branch, this will end up changing the branch destination of; // it to be over the newly inserted indirect branch block, which may avoid; // the need to try expanding the conditional branch first, saving an extra; // jump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:52,Integrability,Depend,Dependency,52,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:403,Integrability,Depend,Dependency,403,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:459,Integrability,depend,dependencies,459,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:824,Integrability,depend,dependencies,824,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:809,Safety,avoid,avoiding,809,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:4,Deployability,Update,Update,4,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:65,Integrability,depend,dependencies,65,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:22,Integrability,depend,dependencies,22,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:164,Integrability,depend,dependent,164,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:277,Integrability,depend,dependency,277,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:315,Integrability,depend,dependency,315,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:10,Safety,avoid,avoid,10,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:201,Usability,clear,clearance,201,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:361,Usability,clear,clearance,361,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:46,Integrability,depend,dependence,46,/// Return true to if it makes sense to break dependence on a partial; /// def or undef use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:16,Integrability,depend,dependencies,16,"/// Break false dependencies on undefined register reads.; /// Walk the block backward computing precise liveness. This is expensive, so; /// we only do it on demand. Note that the occurrence of undefined register; /// reads that should be broken is very rare, but when they occur we may have; /// many in a single block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,// Update only undef operands that have reg units that are mapped to one root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:33,Integrability,depend,dependency,33,"// If the instruction has a true dependency, we can hide the false depdency; // behind it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:19,Integrability,depend,dependency,19,// We found a true dependency - replace the undef register with the true; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:77,Integrability,depend,dependency,77,// We found a true dependency - replace the undef register with the true; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:82,Usability,clear,clearance,82,// Go over all registers in the register class and find the register with; // max clearance or clearance higher than Pref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:95,Usability,clear,clearance,95,// Go over all registers in the register class and find the register with; // max clearance or clearance higher than Pref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,// Update the operand if we found a register with better clearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:57,Usability,clear,clearance,57,// Update the operand if we found a register with better clearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:9,Integrability,depend,dependence,9,// Break dependence on undef uses. Do this before updating LiveRegs below.; // This can remove a false dependence with no additional instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:103,Integrability,depend,dependence,103,// Break dependence on undef uses. Do this before updating LiveRegs below.; // This can remove a false dependence with no additional instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:181,Availability,avail,available,181,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:45,Integrability,depend,dependency,45,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:91,Integrability,depend,dependency,91,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:81,Integrability,depend,dependence,81,"// The code below allows the target to create a new instruction to break the; // dependence. That opposes the goal of minimizing size, so bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:43,Deployability,update,updates,43,// Check clearance before partial register updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:9,Usability,clear,clearance,9,// Check clearance before partial register updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:81,Integrability,depend,dependence,81,"// The code below allows the target to create a new instruction to break the; // dependence. That opposes the goal of minimizing size, so bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,"// Update liveness, including the current instruction's defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:247,Integrability,depend,dependencies,247,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:205,Safety,avoid,avoid,205,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:87,Usability,clear,clearance,87,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:10,Deployability,update,update,10,// Do not update future local split artifacts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:66,Deployability,update,update,66,// Give extra weight to what looks like a loop induction variable update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:57,Modifiability,variab,variable,57,// Give extra weight to what looks like a loop induction variable update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:98,Availability,mask,mask,98,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:137,Availability,mask,mask,137,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:362,Energy Efficiency,allocate,allocate,362,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:511,Performance,load,load,511,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:326,Safety,risk,risky,326,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:1535,Usability,simpl,simpler,1535,"//===-- CallBrPrepare - Prepare callbr for code generation ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers callbrs in LLVM IR in order to to assist SelectionDAG's; // codegen.; //; // In particular, this pass assists in inserting register copies for the output; // values of a callbr along the edges leading to the indirect target blocks.; // Though the output SSA value is defined by the callbr instruction itself in; // the IR representation, the value cannot be copied to the appropriate virtual; // registers prior to jumping to an indirect label, since the jump occurs; // within the user-provided assembly blob.; //; // Instead, those copies must occur separately at the beginning of each; // indirect target. That requires that we create a separate SSA definition in; // each of them (via llvm.callbr.landingpad), and may require splitting; // critical edges so we have a location to place the intrinsic. Finally, we; // remap users of the original callbr output SSA value to instead point to the; // appropriate llvm.callbr.landingpad value.; //; // Ideally, this could be done inside SelectionDAG, or in the; // MachineInstruction representation, without the use of an IR-level intrinsic.; // But, within the current framework, its simpler to implement as an IR pass.; // (If support for callbr in GlobalISel is implemented, its worth considering; // whether this is still required.); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite the use in the newly inserted intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:180,Availability,avail,available,180,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:389,Performance,optimiz,optimization,389,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:103,Safety,Safe,SafeStackLegacyPass,103,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:225,Safety,avoid,avoids,225,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate space on the stack large enough to pass an argument by value.; /// The size and alignment information of the argument is encoded in; /// its parameter attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:46,Energy Efficiency,allocate,allocated,46,/// Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:86,Performance,perform,performed,86,"/// Analyze the return values of a function, returning true if the return can; /// be performed without sret-demotion and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate something of this value type repeatedly until we get assigned a; // location in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:84,Energy Efficiency,allocate,allocated,84,"// Clear the assigned values and stack memory. We leave the registers marked; // as allocated so that future queries don't return the same registers, i.e.; // when i64 and f64 are both passed in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:3,Usability,Clear,Clear,3,"// Clear the assigned values and stack memory. We leave the registers marked; // as allocated so that future queries don't return the same registers, i.e.; // when i64 and f64 are both passed in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp:3230,Availability,down,down,3230,"/ has not executed any epilogue; // - ""does not have a call frame"", if the function has not executed the; // prologue, or has executed an epilogue; // which can be computed by a single RPO traversal.; // The location of the prologue is determined by finding the first block in the; // reverse traversal which contains CFI instructions.; // In order to accommodate backends which do not generate unwind info in; // epilogues we compute an additional property ""strong no call frame on entry"",; // which is set for the entry point of the function and for every block; // reachable from the entry along a path that does not execute the prologue. If; // this property holds, it takes precedence over the ""has a call frame""; // property.; // From the point of view of the unwind tables, the ""has/does not have call; // frame"" state at beginning of each block is determined by the state at the end; // of the previous block, in layout order. Where these states differ, we insert; // compensating CFI instructions, which come in two flavours:; // - CFI instructions, which reset the unwind table state to the initial one.; // This is done by a target specific hook and is expected to be trivial; // to implement, for example it could be:; // .cfi_def_cfa <sp>, 0; // .cfi_same_value <rN>; // .cfi_same_value <rN-1>; // ...; // where <rN> are the callee-saved registers.; // - CFI instructions, which reset the unwind table state to the one; // created by the function prologue. These are; // .cfi_restore_state; // .cfi_remember_state; // In this case we also insert a `.cfi_remember_state` after the last CFI; // instruction in the function prologue.; //; // Known limitations:; // * the pass cannot handle an epilogue preceding the prologue in the basic; // block layout; // * the pass does not handle functions where SP is used as a frame pointer and; // SP adjustments up and down are done in different basic blocks (TODO); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp:72,Modifiability,inherit,inherits,72,"// Walk the blocks of the function in ""physical"" order.; // Every block inherits the frame state (as recorded in the unwind tables); // of the previous block. If the intended frame state is different, insert; // compensating CFI instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:4,Deployability,Update,Update,4,/// Update in/out cfa offset and register values for successors of the basic; /// block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:3,Deployability,Update,Update,3,// Update outgoing CFA info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:3,Deployability,Update,Update,3,// Update outgoing CSR info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp:430,Integrability,rout,routines,430,"//===-- CodeGen.cpp -------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the common initialization routines for the; // CodeGen library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp:33,Testability,test,tests,33,// Pick the direction with fewer tests; // TODO: Handle more combinations of cases that can be handled together,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp:151,Performance,perform,performance,151,"// These are arbitrary chosen limits on the maximum number of values and the; // maximum size of a debug expression we can salvage up to, used for; // performance reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp:401,Integrability,interface,interfaces,401,"//===--- CodeGenPassBuilder.cpp --------------------------------------- ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp:415,Security,access,access,415,"//===--- CodeGenPassBuilder.cpp --------------------------------------- ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:135,Deployability,update,update,135,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Performance,optimiz,optimizing,28,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Performance,optimiz,optimize,82,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Performance,load,load,157,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:260,Performance,cache,cache,260,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Safety,avoid,avoid,96,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Security,access,accessing,23,/// Keep track of GEPs accessing the same data structures such as structs or; /// arrays that are candidates to be split later because of their large; /// size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Deployability,update,update,86,"/// Building the dominator tree can be expensive, so we only build it; /// lazily and update it when required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:48,Deployability,update,updated,48,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Deployability,update,updated,157,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Performance,optimiz,optimized,82,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Usability,Clear,Clear,3,// Clear per function information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Usability,simpl,simplifications,36,"// Substituting can cause recursive simplifications, which can invalidate; // our iterator. Use a WeakTrackingVH to hold onto it in case this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Performance,optimiz,optimization,9,"/// This optimization identifies DIV instructions that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:79,Performance,optimiz,optimization,79,"// bypassSlowDivision may create new BBs, but we don't want to reapply the; // optimization to those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Deployability,update,updated,16,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Performance,optimiz,optimized,55,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Performance,optimiz,optimization,98,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Deployability,update,updated,23,// Verify BFI has been updated correctly by recomputing BFI and comparing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:100,Safety,avoid,avoid,100,"// Scan all of the blocks in the function, except for the entry block.; // Use a temporary array to avoid iterator being invalidated when; // deleting blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Performance,optimiz,optimize,22,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Availability,redundant,redundant,66,// (Repeatedly) merging blocks into their predecessors can create redundant; // debug intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Safety,redund,redundant,66,// (Repeatedly) merging blocks into their predecessors can create redundant; // debug intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Safety,avoid,avoid,41,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.; // Note that this intentionally skips the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Usability,simpl,simple,12,"// We use a simple cost heuristic which determine skipping merging is; // profitable if the cost of skipping merging is less than the cost of; // merging : Cost(skipping merging) < Cost(merging BB), where the; // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and; // the Cost(merging BB) is Freq(Pred) * Cost(Copy).; // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :; // Freq(Pred) / Freq(BB) > 2.; // Note that if there are multiple empty blocks sharing the same incoming; // value for the PHIs in the DestBB, we consider them together. In such; // case, Cost(merging BB) will be the sum of their frequencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:386,Usability,simpl,simplify,386,"// We use a simple cost heuristic which determine skipping merging is; // profitable if the cost of skipping merging is less than the cost of; // merging : Cost(skipping merging) < Cost(merging BB), where the; // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and; // the Cost(merging BB) is Freq(Pred) * Cost(Copy).; // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :; // Freq(Pred) / Freq(BB) > 2.; // Note that if there are multiple empty blocks sharing the same incoming; // value for the PHIs in the DestBB, we consider them together. In such; // case, Cost(merging BB) will be the sum of their frequencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,Safety,avoid,avoid,184,// If User is inside DestBB block and it is a PHINode then check; // incoming value. If incoming value is not from BB then this is; // a complex condition (e.g. preheaders) we want to avoid here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Deployability,update,updated,53,"/// Replace all old uses with new ones, and push the updated BBs into FreshBBs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Performance,optimiz,optimize,22,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:51,Deployability,Update,Update,51,"// Otherwise, we have multiple predecessors of BB. Update the PHIs in DestBB; // to handle the new incoming edges it is about to have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:20,Deployability,update,updated,20,"// The PHIs are now updated, change everything that refers to BB to use; // DestBB and remove BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:395,Performance,optimiz,optimization,395,// We must ensure the relocation of derived pointer is defined after; // relocation of base pointer. If we find a relocation corresponding to base; // defined earlier than relocation of base then we move relocation of base; // right before found relocation. We consider only relocation in the same; // basic block as relocation of base. Relocations from other basic block will; // be skipped by optimization and we do not care about them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:836,Performance,optimiz,optimized,836,"// If gc_relocate does not match the actual type, cast it to the right type.; // In theory, there must be a bitcast after gc_relocate if the type does not; // match, and we should reuse it to get the derived pointer. But it could be; // cases like this:; // bb1:; // ...; // %g1 = call coldcc i8 addrspace(1)*; // @llvm.experimental.gc.relocate.p1i8(...) br label %merge; //; // bb2:; // ...; // %g2 = call coldcc i8 addrspace(1)*; // @llvm.experimental.gc.relocate.p1i8(...) br label %merge; //; // merge:; // %p1 = phi i8 addrspace(1)* [ %g1, %bb1 ], [ %g2, %bb2 ]; // %cast = bitcast i8 addrspace(1)* %p1 in to i32 addrspace(1)*; //; // In this case, we can not find the bitcast any more. So we insert a new; // bitcast no matter there is already one or not. In this way, we can handle; // all cases, and the extra bitcast should be optimized away in later; // passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:218,Performance,load,load,218,"// Turns this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = relocate(%tok, i32 4, i32 4); // %ptr' = relocate(%tok, i32 4, i32 5); // %val = load %ptr'; //; // into this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = gc.relocate(%tok, i32 4, i32 4); // %ptr' = gep %base' + 15; // %val = load %ptr'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:441,Performance,load,load,441,"// Turns this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = relocate(%tok, i32 4, i32 4); // %ptr' = relocate(%tok, i32 4, i32 5); // %val = load %ptr'; //; // into this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = gc.relocate(%tok, i32 4, i32 4); // %ptr' = gep %base' + 15; // %val = load %ptr'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:161,Energy Efficiency,reduce,reduce,161,"/// If the specified cast instruction is a noop copy (e.g. it's casting from; /// one pointer type to another, i32->i8 on PPC), sink it into user blocks to; /// reduce the number of virtual registers that must be created and coalesced.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,Usability,simpl,simple,11,"// Match a simple increment by constant operation. Note that if a sub is; // matched, the step is negated (as if the step had been canonicalized to; // an add, even though we leave the instruction alone.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:35,Modifiability,variab,variable,35,"/// If given \p PN is an inductive variable with value IVInc coming from the; /// backedge, and on each iteration it gets increased by Step, return pair; /// <IVInc, Step>. Otherwise, return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Safety,risk,risk,10,// Do not risk on moving increment into a child loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:61,Performance,optimiz,optimization,61,"// We used to use a dominator tree here to allow multi-block optimization.; // But that was problematic because:; // 1. It could cause a perf regression by hoisting the math op into the; // critical path.; // 2. It could cause a perf regression by creating a value that was live; // across multiple blocks and increasing register pressure.; // 3. Use of a dominator tree could cause large compile-time regression.; // This is because we recompute the DT on every change in the main CGP; // run-loop. The recomputing is probably unnecessary in many cases, so if; // that was fixed, using a DT here would be ok.; //; // There is one important particular case we still want to handle: if BO is; // the IV increment. Important properties that make it profitable:; // - We can speculate IV increment anywhere in the loop (as long as the; // indvar Phi is its only user);; // - Upon computing Cmp, we effectively compute something equivalent to the; // IV increment (despite it loops differently in the IR). So moving it up; // to the cmp point does not really increase register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:26,Modifiability,variab,variable,26,// Check the users of the variable operand of the compare looking for an add; // with the adjusted constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:35,Usability,simpl,simplify,35,// Convert (A u> B) to (A u< B) to simplify pattern matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,"// Walk the users of a variable operand of a compare looking for a subtract or; // add with that same operand. Also match the 2nd operand of the compare to; // the add/sub, but that may be a negated constant operand of an add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Energy Efficiency,reduce,reduce,47,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:210,Energy Efficiency,Power,PowerPC,210,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:137,Usability,clear,clear,137,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid sinking soft-FP comparisons, since this can move them into a loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:384,Energy Efficiency,Power,PowerPC,384,"/// For pattern like:; ///; /// DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB); /// ...; /// DomBB:; /// ...; /// br DomCond, TrueBB, CmpBB; /// CmpBB: (with DomBB being the single predecessor); /// ...; /// Cmp = icmp eq CmpOp0, CmpOp1; /// ...; ///; /// It would use two comparison on targets that lowering of icmp sgt/slt is; /// different from lowering of icmp eq (PowerPC). This function try to convert; /// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.; /// After that, DomCond and Cmp can use the same comparison so reduce one; /// comparison.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:564,Energy Efficiency,reduce,reduce,564,"/// For pattern like:; ///; /// DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB); /// ...; /// DomBB:; /// ...; /// br DomCond, TrueBB, CmpBB; /// CmpBB: (with DomBB being the single predecessor); /// ...; /// Cmp = icmp eq CmpOp0, CmpOp1; /// ...; ///; /// It would use two comparison on targets that lowering of icmp sgt/slt is; /// different from lowering of icmp eq (PowerPC). This function try to convert; /// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.; /// After that, DomCond and Cmp can use the same comparison so reduce one; /// comparison.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Availability,redundant,redundant,117,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Safety,redund,redundant,117,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking many users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Performance,optimiz,optimize,41,// Double-check that we're not trying to optimize an instruction that was; // already optimized by some other part of this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Performance,optimiz,optimized,86,// Double-check that we're not trying to optimize an instruction that was; // already optimized by some other part of this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Safety,avoid,avoid,10,// Try to avoid cases where sinking/duplicating is likely to increase register; // pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,mask,mask,163,"/// Check if the candidates could be combined with a shift instruction, which; /// includes:; /// 1. Truncate instruction; /// 2. And instruction and the imm is a mask of the low bits:; /// imm & (imm+1) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:544,Performance,perform,performed,544,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:126,Safety,avoid,avoid,126,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update the LoopInfo. The new blocks are in the same loop as the start; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid introducing branch on poison. This also replaces the ctz operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid processing instructions out of order, which could cause; // reuse before a value is defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Modifiability,variab,variables,10,"// Global variables can only be aligned if they are defined in this; // object (i.e. they are uniquely initialized in this object), and; // over-aligning global variables that have an explicit section is; // forbidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:161,Modifiability,variab,variables,161,"// Global variables can only be aligned if they are defined in this; // object (i.e. they are uniquely initialized in this object), and; // over-aligning global variables that have an explicit section is; // forbidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:129,Performance,load,loads,129,"// If we have a cold call site, try to sink addressing computation into the; // cold block. This interacts with our handling for loads and stores to; // ensure that we can fold all uses of a potential addressing computation; // into their uses. TODO: generalize this to work over profiling data",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,optimiz,optimizations,65,"// Mark this instruction as ""inserted by CGP"", so that other; // optimizations don't touch it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,Safety,avoid,avoid,42,"// If counting zeros is expensive, try to avoid it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Performance,optimiz,optimizations,104,"/// Look for opportunities to duplicate return instructions to the predecessor; /// to enable tail call optimizations. The case it is currently looking for is:; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// br label %return; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// br label %return; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// br label %return; /// return:; /// %retval = phi i32 [ %tmp0, %bb0 ], [ %tmp1, %bb1 ], [ %tmp2, %bb2 ]; /// ret i32 %retval; /// @endcode; ///; /// =>; ///; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// ret i32 %tmp0; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// ret i32 %tmp1; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// ret i32 %tmp2; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Memory Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:15,Modifiability,extend,extended,15,/// This is an extended version of TargetLowering::AddrMode; /// which holds actual Value*'s for register values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,rollback,rollback,163,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Deployability,rollback,rollback,163,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:155,Usability,undo,undone,155,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:31,Integrability,interface,interface,31,/// This represents the common interface of the individual transaction.; /// Each class implements the logic for doing one specific modification on; /// the IR via the TypePromotionTransaction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Testability,log,logic,103,/// This represents the common interface of the individual transaction.; /// Each class implements the logic for doing one specific modification on; /// the IR via the TypePromotionTransaction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Performance,perform,performs,52,/// Constructor of the action.; /// The constructor performs the related action on the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Undo,Undo,4,"/// Undo the modification done by this action.; /// When this method is called, the IR must be in the same state as it was; /// before this action was applied.; /// \pre Undoing the action works if and only if the IR is in the exact same; /// state as it was directly after this action was applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:170,Usability,Undo,Undoing,170,"/// Undo the modification done by this action.; /// When this method is called, the IR must be in the same state as it was; /// before this action was applied.; /// \pre Undoing the action works if and only if the IR is in the exact same; /// state as it was directly after this action was applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Usability,undo,undo,47,/// Keep track of the new value so that we can undo it by replacing; /// instances of the new value with the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:116,Usability,undo,undoing,116,"// RAUW has replaced all original uses with references to the new value,; // including the debug uses. Since we are undoing the replacements,; // the original debug uses must also be reinstated to maintain the; // correctness and utility of debug value instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Testability,test,tested,3,// tested by transaction-test I'm adding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Testability,test,test,25,// tested by transaction-test I'm adding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,Performance,optimiz,optimizeBlock,70,/// The instructions removed here will be freed after completing; /// optimizeBlock() for all blocks as we need to keep track of the; /// removed instructions during promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Undo,Undo,4,/// Undo all the changes made after the given point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Availability,rollback,rollback,64,/// \name API for IR modification with state keeping to support rollback.; /// @{; /// Same as Instruction::setOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Deployability,rollback,rollback,64,/// \name API for IR modification with state keeping to support rollback.; /// @{; /// Same as Instruction::setOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Testability,log,logic,82,/// A helper class for matching addressing modes.; ///; /// This encapsulates the logic for matching the target-legal addressing modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Security,Access,AccessTy,4,/// AccessTy/MemoryInst - This is the type for the access (e.g. double) and; /// the memory instruction that we're computing this address for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:51,Security,access,access,51,/// AccessTy/MemoryInst - This is the type for the access (e.g. double) and; /// the memory instruction that we're computing this address for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,Performance,optimiz,optimizations,54,/// The instructions inserted by other CodeGenPrepare optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:19,Performance,optimiz,optimizing,19,/// True if we are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Performance,load,load,44,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:253,Performance,optimiz,optimizations,253,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:83,Security,access,access,83,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Security,Access,AccessTy,98,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,Performance,perform,performance,184,"/// Keeps a set of PHINodes.; ///; /// This is a minimal set implementation for a specific use case:; /// It is very fast when there are very few elements, but also provides good; /// performance when there are many. It is similar to SmallPtrSet, but also; /// provides iteration by insertion order, which is deterministic and stable; /// across runs. It is also similar to SmallSetVector, but provides removing; /// elements in O(1) time. This is achieved by not actually removing the element; /// from the underlying vector, so comes at the cost of using more memory, but; /// that is fine, since PhiNodeSets are used as short lived objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:29,Usability,clear,clears,29,/// Removes all elements and clears the collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Deployability,Update,Updates,4,"/// Updates the CurrentIndex so that it will point to a valid element.; ///; /// If the element of NodeList at CurrentIndex is valid, it does not; /// change it. If there are no more valid elements, it updates CurrentIndex; /// to point to the end of the NodeList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:202,Deployability,update,updates,202,"/// Updates the CurrentIndex so that it will point to a valid element.; ///; /// If the element of NodeList at CurrentIndex is valid, it does not; /// change it. If there are no more valid elements, it updates CurrentIndex; /// to point to the end of the NodeList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:18,Usability,simpl,simplification,18,/// Keep track of simplification of Phi nodes.; /// Accept the set of all phi nodes and erase phi node from this set; /// if it is simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:131,Usability,simpl,simplified,131,/// Keep track of simplification of Phi nodes.; /// Accept the set of all phi nodes and erase phi node from this set; /// if it is simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:7,Safety,safe,safe,7,"// For safe erasing, replace the uses with dummy value first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Simpl,SimplifyQuery,4,/// SimplifyQuery for simplifyInstruction utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Usability,simpl,simplifyInstruction,22,/// SimplifyQuery for simplifyInstruction utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:68,Safety,detect,detect,68,"// Take note of if we have any non-trivial AddrModes, as we need to detect; // when all AddrModes are trivial as then we would introduce a phi or select; // which just duplicates what's already there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Deployability,install,installed,65,// We also must reject the case when GV is different and BaseReg installed; // due to we want to use base reg as a merge of GV values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:693,Performance,load,load,693,"/// We have mapping between value A and other value B where B was a field in; /// addressing mode represented by A. Also we have an original value C; /// representing an address we start with. Traversing from C through phi and; /// selects we ended up with A's in a map. This utility function tries to find; /// a value V which is a field in addressing mode C and traversing through phi; /// nodes and selects we will end up in corresponded values B in a map.; /// The utility will create a new Phi/Selects if needed.; // The simple example looks as follows:; // BB1:; // p1 = b1 + 40; // br cond BB2, BB3; // BB2:; // p2 = b2 + 40; // br BB3; // BB3:; // p = phi [p1, BB1], [p2, BB2]; // v = load p; // Map is; // p1 -> b1; // p2 -> b2; // Request is; // p -> ?; // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:526,Usability,simpl,simple,526,"/// We have mapping between value A and other value B where B was a field in; /// addressing mode represented by A. Also we have an original value C; /// representing an address we start with. Traversing from C through phi and; /// selects we ended up with A's in a map. This utility function tries to find; /// a value V which is a field in addressing mode C and traversing through phi; /// nodes and selects we will end up in corresponded values B in a map.; /// The utility will create a new Phi/Selects if needed.; // The simple example looks as follows:; // BB1:; // p1 = b1 + 40; // br cond BB2, BB3; // BB2:; // p2 = b2 + 40; // br BB3; // BB3:; // p = phi [p1, BB1], [p2, BB2]; // v = load p; // Map is; // p1 -> b1; // p2 -> b2; // Request is; // p -> ?; // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Usability,simpl,simplification,14,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:156,Usability,Simpl,Simplification,156,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:226,Usability,simpl,simplified,226,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:290,Usability,simpl,simplification,290,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:359,Usability,simpl,simplified,359,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Usability,simpl,simplify,52,"// Second Step, fill new nodes by merged values and simplify if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:43,Usability,Simpl,SimplificationTracker,43,/// For the given set of PHI nodes (in the SimplificationTracker) try; /// to find their equivalents.; /// Returns false if this matching fails and creation of new Phi is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:60,Usability,simpl,simplify,60,/// Fill the placeholders with values from predecessors and simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:111,Deployability,update,update,111,"// end anonymous namespace; /// Try adding ScaleReg*Scale to the current addressing mode.; /// Return true and update AddrMode if this addr mode is legal for the target,; /// false if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Availability,avail,available,89,"// If we already have a scale of this value, we can add to it, otherwise, we; // need an available scale field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:198,Availability,avail,available,198,"// Okay, we decided that we can add ScaleReg+Scale to AddrMode. Check now; // to see if ScaleReg is actually X+C. If so, we can turn this into adding; // X*Scale + C*Scale to addr mode. If we found available IV increment, do not; // go any further: we can reuse it and cannot eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:377,Safety,avoid,avoid,377,"// TODO: The result of the intrinsics above is two-complement. However when; // IV inc is expressed as add or sub, iv.next is potentially a poison value.; // If it has nuw or nsw flags, we need to make sure that these flags are; // inferrable at the point of memory instruction. Otherwise we are replacing; // well-defined two-complement computation with poison. Currently, to avoid; // potentially complex analysis needed to prove this, we reject such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:156,Availability,avail,available,156,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:432,Energy Efficiency,reduce,reduce,432,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Modifiability,variab,variable,82,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:17,Testability,assert,assert,17,"// The following assert is important to ensure a lack of infinite loops.; // This transforms is (intentionally) the inverse of the one just above.; // If they don't agree on the definition of an increment, we'd alternate; // back and forth indefinitely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Performance,load,load,117,"/// This is a little filter, which returns true if an addressing computation; /// involving I might be folded into a load/store accessing it.; /// This doesn't need to be perfect, but needs to accept at least; /// the set of instructions that MatchOperationAddr can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:128,Security,access,accessing,128,"/// This is a little filter, which returns true if an addressing computation; /// involving I might be folded into a load/store accessing it.; /// This doesn't need to be perfect, but needs to accept at least; /// the set of instructions that MatchOperationAddr can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:20,Performance,perform,perform,20,/// Hepler class to perform type promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Modifiability,extend,extend,22,"/// Given a sign/zero extend instruction \p Ext, return the appropriate; /// action to promote the operand of \p Ext instead of using Ext.; /// \return NULL if no promotable action is possible with the current; /// sign extension.; /// \p InsertedInsts keeps track of all the instructions inserted by the; /// other CodeGenPrepare optimizations. This information is important; /// because we do not want to promote these instructions as CodeGenPrepare; /// will reinsert them later. Thus creating an infinite loop: create/remove.; /// \p PromotedInsts maps the instructions to their type before promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:331,Performance,optimiz,optimizations,331,"/// Given a sign/zero extend instruction \p Ext, return the appropriate; /// action to promote the operand of \p Ext instead of using Ext.; /// \return NULL if no promotable action is possible with the current; /// sign extension.; /// \p InsertedInsts keeps track of all the instructions inserted by the; /// other CodeGenPrepare optimizations. This information is important; /// because we do not want to promote these instructions as CodeGenPrepare; /// will reinsert them later. Thus creating an infinite loop: create/remove.; /// \p PromotedInsts maps the instructions to their type before promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Modifiability,extend,extend,157,"// The promotion helper does not know how to deal with vector types yet.; // To be able to fix that, we would need to fix the places where we; // statically extend, e.g., constants and such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Usability,simpl,simplification,36,// Check if we can do the following simplification.; // ext(trunc(opnd)) --> ext(opnd),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:181,Testability,log,logic,181,"// If the operand of the truncate is not an instruction, we will not have; // any information on the dropped bits.; // (Actually we could for constant but it is not worth the extra logic).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:91,Modifiability,extend,extended,91,"// Check if the source of the type is narrow enough.; // I.e., check that trunc just drops extended bits of the same kind of; // the extension.; // #1 get the type of the operand and check the kind of the extended bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:205,Modifiability,extend,extended,205,"// Check if the source of the type is narrow enough.; // I.e., check that trunc just drops extended bits of the same kind of; // the extension.; // #1 get the type of the operand and check the kind of the extended bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Modifiability,extend,extended,41,// #2 check that the truncate just drops extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:109,Performance,optimiz,optimization,109,"// Do not promote if the operand has been added by codegenprepare.; // Otherwise, it means we are undoing an optimization that is likely to be; // redone, thus causing potential infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Usability,undo,undoing,98,"// Do not promote if the operand has been added by codegenprepare.; // Otherwise, it means we are undoing an optimization that is likely to be; // redone, thus causing potential infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Safety,Abort,Abort,28,// Regular instruction.; // Abort early if we will have to insert non-free instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:106,Safety,avoid,avoid,106,// Restore the operand of Ext (which has been replaced by the previous call; // to replaceAllUsesWith) to avoid creating a cycle trunc <-> sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Deployability,Update,Update,39,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Modifiability,Extend,Extend,103,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:140,Modifiability,extend,extended,140,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:273,Modifiability,extend,extended,273,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:30,Modifiability,extend,extend,30,// Check if we can statically extend the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Modifiability,extend,extend,55,"// UndefValue are typed, so we have to statically sign extend them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:40,Modifiability,extend,extend,40,// Otherwise we have to explicitly sign extend the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:78,Performance,load,loads,78,// The promotion is neutral but it may help folding the sign extension in; // loads for instance.; // Check that we did not create an illegal instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:114,Deployability,update,update,114,"/// Given an instruction or constant expr, see if we can fold the operation; /// into the addressing mode. If so, update the addressing mode and return; /// true, otherwise return false without modifying AddrMode.; /// If \p MovedAway is not NULL, it contains the information of whether or; /// not AddrInst has to be folded into the addressing mode on success.; /// If \p MovedAway == true, \p AddrInst will not be part of the addressing; /// because it has been moved away.; /// Thus AddrInst must not be added in the matched instructions.; /// This state can happen when AddrInst is a sext, since it may be moved away.; /// Therefore, AddrInst may not be valid when MovedAway is true and it must; /// not be referenced anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid exponential behavior on extremely deep expression trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:136,Usability,undo,undo,136,"// Start a transaction at this point.; // The LHS may match but not the RHS.; // Therefore, we need a higher level restoration point to undo partially; // matched operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:81,Modifiability,variab,variable,81,// Scan the GEP. We check it if it contains constant offsets and at most; // one variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:21,Modifiability,variab,variable,21,// We only allow one variable index at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Modifiability,variab,variable,16,// Remember the variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:238,Security,access,access,238,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:143,Usability,Simpl,Simple,143,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,// Match the remaining variable portion of the GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Availability,rollback,rollback,50,// Start a transaction at this point that we will rollback if the matching; // fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Deployability,rollback,rollback,50,// Start a transaction at this point that we will rollback if the matching; // fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,"// If this is a global variable, try to fold it into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:125,Safety,avoid,avoid,125,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Usability,simpl,simple,104,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:144,Security,access,accessed,144,"/// Recursively walk all the uses of I until we find a memory use.; /// If we find an obviously non-foldable instruction, return true.; /// Add accessed addresses and types to MemoryUses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Safety,avoid,avoids,96,// Conservatively return true if we're seeing a large number or a deep chain; // of users. This avoids excessive compilation times in pathological cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:94,Performance,optimiz,optimizeCallInst,94,"// If this is a cold call, we can sink the addressing calculation into; // the cold path. See optimizeCallInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Performance,load,load,104,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:287,Performance,load,load,287,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:404,Performance,load,load,404,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:483,Performance,load,load,483,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:508,Performance,load,load,508,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:631,Performance,load,load,631,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:876,Performance,load,load,876,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:470,Availability,avail,available,470,"// AMBefore is the addressing mode before this instruction was folded into it,; // and AMAfter is the addressing mode after the instruction was folded. Get; // the set of registers referenced by AMAfter and subtract out those; // referenced by AMBefore: this is the set of values which folding in this; // address extends the lifetime of.; //; // Note that there are only two potential values being referenced here,; // BaseReg and ScaleReg (global addresses are always available, as are any; // folded immediates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:314,Modifiability,extend,extends,314,"// AMBefore is the addressing mode before this instruction was folded into it,; // and AMAfter is the addressing mode after the instruction was folded. Get; // the set of registers referenced by AMAfter and subtract out those; // referenced by AMBefore: this is the set of values which folding in this; // address extends the lifetime of.; //; // Note that there are only two potential values being referenced here,; // BaseReg and ScaleReg (global addresses are always available, as are any; // folded immediates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Modifiability,extend,extended,98,"// If the BaseReg or ScaledReg was referenced by the previous addrmode, their; // lifetime wasn't extended by adding this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:58,Modifiability,extend,extend,58,"// If folding this instruction (and it's subexprs) didn't extend any live; // ranges, we're ok with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1093,Energy Efficiency,reduce,reduce,1093,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:302,Performance,Load,Load,302,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:467,Performance,load,load,467,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:720,Performance,optimiz,optimize,720,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:734,Performance,load,load,734,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Usability,undo,undo,64,// Try to collapse single-value PHI nodes. This is necessary to undo; // unprofitable PRE transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:510,Safety,safe,safely,510,"// We allow traversing cyclic Phi nodes.; // In case of success after this loop we ensure that traversing through; // Phi nodes ends up with all cases to compute address of the form; // BaseGV + Base + Scale * Index + Offset; // where Scale and Offset are constans and BaseGV, Base and Index; // are exactly the same Values in all cases.; // It means that BaseGV, Scale and Offset dominate our memory instruction; // and have the same value as they had in address computation represented; // as Phi. So we can safely sink address computation to memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:99,Integrability,depend,depending,99,"// For non-PHIs, determine the addressing mode being computed. Note that; // the result may differ depending on what other uses our candidate; // addressing instructions might have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Energy Efficiency,reduce,reduce,50,"// If splitting the underlying data structure can reduce the offset of a; // GEP, collect the GEP. Skip the GEPs that are the new bases of; // previously split data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:182,Performance,load,load,182,"// Now that we determined the addressing expression we want to use and know; // that we have to sink it into this block. Check to see if we have already; // done this for some other load/store instr in this block. If so, reuse; // the computation. Before attempting reuse, check if the address is valid; // as it may have been erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Modifiability,extend,extend,27,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:124,Modifiability,extend,extend,124,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:309,Modifiability,extend,extending,309,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Safety,safe,safe,14,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Performance,load,load,89,// We need to add this separately from the scale above to help with; // SDAG consecutive load/store merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Availability,down,down,36,"// We'd require a ptrtoint/inttoptr down the line, which we can't do for; // non-integral pointers, so in that case bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Modifiability,extend,extend,27,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:124,Modifiability,extend,extend,124,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:309,Modifiability,extend,extending,309,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Safety,safe,safe,14,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:45,Performance,cache,cache,45,"// Store the newly computed address into the cache. In the case we reused a; // value, this should be idempotent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite GEP input to gather/scatter to enable SelectionDAGBuilder to find; /// a uniform base to use for ISD::MGATHER/MSCATTER. SelectionDAGBuilder can; /// only handle a 2 operand GEP in the same basic block or a splat constant; /// vector. The 2 operands to the GEP must have a scalar pointer and a vector; /// index.; ///; /// If the existing GEP has a vector base pointer that is splat, we can look; /// through the splat to find the scalar pointer. If we can't find a scalar; /// pointer there's nothing we can do.; ///; /// If we have a GEP with more than 2 indices where the middle indices are all; /// zeroes, we can replace it with 2 GEPs where the second has 2 operands.; ///; /// If the final index isn't a vector or is a splat, we can emit a scalar GEP; /// followed by a GEP with an all zeroes vector index. This will enable; /// SelectionDAGBuilder to use the scalar GEP as the uniform base and have a; /// zero index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Performance,optimiz,optimize,9,// Don't optimize GEPs that don't have indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Performance,optimiz,optimize,66,"// If the GEP and the gather/scatter aren't in the same BB, don't optimize.; // FIXME: We should support this by sinking the GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,Performance,Optimiz,OptimizeMemoryInst,42,"/// If there are any memory operands, use OptimizeMemoryInst to sink their; /// address computing into the block when possible / profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Modifiability,extend,extend,41,"// This is a ZExt, maybe this is free to extend from one type to another.; // In that case, we would not account for a different use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Performance,load,load,39,// Early check if we directly have ext(load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:172,Performance,load,load,172,// Check whether or not we want to do any promotion. The reason we have; // this check inside the for loop is to catch the case where an extension; // is directly fed by a load because in such case the extension can be moved; // up without any promotion on its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:21,Performance,perform,perform,21,// Get the action to perform the promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Performance,load,load,53,"// We would be able to merge only one extension in a load.; // Therefore, if we have more than 1 new extension we heuristically; // cut this search path, because it means we degrade the code quality.; // With exactly 2, the transformation is neutral, because we will merge; // one extension but leave one. However, we optimistically keep going,; // because the new extension may be removed too. Also avoid replacing a; // single free extension with multiple extensions, as this increases the; // number of IR instructions while not providing any savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:400,Safety,avoid,avoid,400,"// We would be able to merge only one extension in a load.; // Therefore, if we have more than 1 new extension we heuristically; // cut this search path, because it means we degrade the code quality.; // With exactly 2, the transformation is neutral, because we will merge; // one extension but leave one. However, we optimistically keep going,; // because the new extension may be removed too. Also avoid replacing a; // single free extension with multiple extensions, as this increases the; // number of IR instructions while not providing any savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Availability,rollback,rollback,37,"// This promotion is not profitable, rollback to the previous state, and; // save the current extension in ProfitablyMovedExts as the latest; // speculative promotion turned out to be unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Deployability,rollback,rollback,37,"// This promotion is not profitable, rollback to the previous state, and; // save the current extension in ProfitablyMovedExts as the latest; // speculative promotion turned out to be unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Performance,load,load,27,"// If we have reached to a load, we need this extra profitability check; // as it could potentially be merged into an ext(load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Performance,load,load,122,"// If we have reached to a load, we need this extra profitability check; // as it could potentially be merged into an ext(load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Availability,rollback,rollback,64,"// If none of speculative promotions for NewExts is profitable, rollback; // and save the current extension (I) as the last profitable extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Deployability,rollback,rollback,64,"// If none of speculative promotions for NewExts is profitable, rollback; // and save the current extension (I) as the last profitable extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Availability,redundant,redundant,12,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Safety,redund,redundant,12,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:441,Performance,load,load,441,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:465,Performance,load,load,465,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:489,Performance,load,load,489,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:719,Performance,load,load,719,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:757,Performance,load,load,757,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:795,Performance,load,load,795,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Security,access,accessing,52,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,Security,access,access,70,// The result type of the GEP might not be the type of the memory; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:90,Performance,load,loads,90,"// We are looking for a collection on interconnected phi nodes that together; // only use loads/bitcasts and are used by stores/bitcasts, and the bitcasts; // are of the same type. Convert the whole set of nodes to the type of the; // bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Performance,load,load,47,// This works by adding extra bitcasts between load/stores and removing; // existing bicasts. If we have a phi(bitcast(load)) or a store(bitcast(phi)); // we can get in the situation where we remove a bitcast in one iteration; // just to add it again in the next. We need to ensure that at least one; // bitcast we remove are anchored to something that will not change back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:119,Performance,load,load,119,// This works by adding extra bitcasts between load/stores and removing; // existing bicasts. If we have a phi(bitcast(load)) or a store(bitcast(phi)); // we can get in the situation where we remove a bitcast in one iteration; // just to add it again in the next. We need to ensure that at least one; // bitcast we remove are anchored to something that will not change back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,load,loads,65,"// Create all the new phi nodes of the new type, and bitcast any loads to the; // correct type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Performance,optimiz,optimize,14,// Attempt to optimize all the phis in the functions to the correct type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Performance,load,load,27,"/// Return true, if an ext(load) can be formed from an extension in; /// \p MovedExts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:159,Modifiability,extend,extend,159,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:636,Modifiability,extend,extended,636,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:33,Performance,load,load,33,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:71,Performance,load,load,71,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:175,Performance,load,load,175,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:219,Performance,load,load,219,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:343,Performance,load,load,343,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:547,Performance,load,load,547,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:673,Security,access,accesses,673,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:172,Security,access,accesses,172,"/// See if it is an interesting sext operations for the address type; /// promotion before trying to promote it, e.g., the ones with the right; /// type and used in memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Modifiability,extend,extended,25,// Look for a load being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Performance,load,load,14,// Look for a load being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Modifiability,extend,extended,65,// Try to promote a chain of computation if it allows to form an extended; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:78,Performance,load,load,78,// Try to promote a chain of computation if it allows to form an extended; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Modifiability,extend,extend,12,// Move the extend into the same block as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:46,Performance,load,load,46,// Move the extend into the same block as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Integrability,depend,depending,53,// Continue promoting SExts if known as considerable depending on targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:165,Modifiability,extend,extended,165,"// Perform address type promotion if doing so is profitable.; // If AllowPromotionWithoutCommonHeader == false, we should find other sext; // instructions that sign extended the same initial value. However, if; // AllowPromotionWithoutCommonHeader == true, we expect promoting the; // extension is just profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Performance,Perform,Perform,3,"// Perform address type promotion if doing so is profitable.; // If AllowPromotionWithoutCommonHeader == false, we should find other sext; // instructions that sign extended the same initial value. However, if; // AllowPromotionWithoutCommonHeader == true, we expect promoting the; // extension is just profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update Inst as promotion happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Modifiability,rewrite,rewrite,65,"// If the result of a {s|z}ext and its source are both live out, rewrite all; // other uses of the source with result of extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Performance,perform,perform,16,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Performance,optimiz,optimization,28,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Safety,safe,safe,8,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:91,Performance,load,load,91,// Be conservative. We don't want this xform to end up introducing; // reloads just before load / store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Modifiability,Rewrite,Rewrite,44,// Both src and def are live in this block. Rewrite the use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,Availability,redundant,redundant,297,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Performance,load,loads,8,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:46,Performance,load,loaded,46,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:99,Performance,load,load,99,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:252,Performance,load,loaded,252,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:424,Performance,load,load,424,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:535,Performance,load,load,535,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:631,Performance,load,load,631,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:730,Performance,load,load,730,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:764,Performance,load,load,764,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:861,Performance,optimiz,optimizeLoadExt,861,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:886,Performance,load,load,886,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:914,Performance,load,load,914,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:971,Performance,load,load,971,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,Safety,redund,redundant,297,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Performance,load,loads,8,// Skip loads we've already transformed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Performance,Load,Load,23,"// Look at all uses of Load, looking through phis, to determine how many bits; // of the loaded value are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Performance,load,loaded,89,"// Look at all uses of Load, looking through phis, to determine how many bits; // of the loaded value are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Performance,optimiz,optimize,39,"// If the BitWidth is 0, do not try to optimize the type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:32,Availability,mask,mask,32,// Keep track of the widest and mask we see.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:596,Availability,mask,mask,596,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:24,Performance,load,load,24,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:241,Performance,load,load,241,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:525,Safety,avoid,avoid,525,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,optimiz,optimizations,65,"// Mark this instruction as ""inserted by CGP"", so that other; // optimizations don't touch it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Performance,load,load,23,// Replace all uses of load with new and (except for the use of load in the; // new and itself).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Performance,load,load,64,// Replace all uses of load with new and (except for the use of load in the; // new and itself).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Availability,redundant,redundant,44,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Safety,redund,redundant,44,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Availability,mask,mask,22,// Check that the and mask is the same as the one we decided to put on the; // new and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,Safety,safe,safe,11,"// If it's safe to speculatively execute, then it should not have side; // effects; therefore, it's safe to sink and possibly *not* execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:100,Safety,safe,safe,100,"// If it's safe to speculatively execute, then it should not have side; // effects; therefore, it's safe to sink and possibly *not* execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:13,Safety,predict,predictable,13,"// If even a predictable select is cheap, then a branch can't be cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:195,Safety,predict,predictable,195,"// FIXME: This should use the same heuristics as IfConversion to determine; // whether a select is better represented as a branch.; // If metadata tells us that the select condition is obviously predictable,; // then we want to replace the select with a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:18,Safety,predict,predictable,18,"// If a branch is predictable, an out-of-order CPU can avoid blocking on its; // comparison condition. If the compare has more than one use, there's; // probably another cmov or setcc around, so it's not worth emitting a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Safety,avoid,avoid,55,"// If a branch is predictable, an out-of-order CPU can avoid blocking on its; // comparison condition. If the compare has more than one use, there's; // probably another cmov or setcc around, so it's not worth emitting a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Safety,predict,prediction,64,"/// If we have a SelectInst that will likely profit from branch prediction,; /// turn it into a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:68,Performance,optimiz,optimized,68,"// If the SelectOptimize pass is enabled, selects have already been optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,mainten,maintenence,163,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:115,Performance,optimiz,optimizeInst,115,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:143,Performance,perform,perform,143,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:229,Performance,optimiz,optimized,229,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Safety,avoid,avoid,157,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,Usability,simpl,simply,92,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:746,Performance,optimiz,optimized,746,"// Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d from; // the entry block into the destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Collect values that go on the true side and the values that go on the false; // side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:62,Safety,avoid,avoid,62,// Sink expensive instructions into the conditional blocks to avoid executing; // them speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,Optimiz,OptimizeBlock,12,// Instruct OptimizeBlock to skip to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:133,Performance,optimiz,optimization,133,"// Now we clone an instruction, its operands' defs may sink to this BB; // now. So we put the operands defs' BBs into FreshBBs to do optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,"// Update the use for the new instruction, making sure that we update the; // sunk instruction uses, if it is part of a chain that has already been; // sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:63,Deployability,update,update,63,"// Update the use for the new instruction, making sure that we update the; // sunk instruction uses, if it is part of a chain that has already been; // sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:281,Modifiability,extend,extended,281,"// If the register width is greater than the type width, expand the condition; // of the switch instruction and each case constant to the width of the; // register. By widening the type of the switch condition, subsequent; // comparisons (for case comparisons) will not need to be extended to the; // preferred register width, so we will potentially eliminate N-1 extends,; // where N is the number of cases in the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:364,Modifiability,extend,extends,364,"// If the register width is greater than the type width, expand the condition; // of the switch instruction and each case constant to the width of the; // register. By widening the type of the switch condition, subsequent; // comparisons (for case comparisons) will not need to be extended to the; // preferred register width, so we will potentially eliminate N-1 extends,; // where N is the number of cases in the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:211,Availability,mask,mask,211,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Modifiability,Extend,Extend,3,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:81,Modifiability,extend,extend,81,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:147,Modifiability,extend,extend,147,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:190,Safety,avoid,avoid,190,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,optimiz,optimization,12,"// The SCCP optimization tends to produce code like this:; // switch(x) { case 42: phi(42, ...) }; // Materializing the constant for the phi-argument needs instructions; So we; // change the code to:; // switch(x) { case 42: phi(x, ...) }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid endless loop in degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:13,Performance,optimiz,optimize,13,// We cannot optimize if there are multiple case labels jumping to; // this block. This check may get expensive when there are many; // case labels so we test for it last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:154,Testability,test,test,154,// We cannot optimize if there are multiple case labels jumping to; // this block. This check may get expensive when there are many; // case labels so we test for it last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Availability,down,downward,96,"/// Helper class to promote a scalar operation to a vector one.; /// This class is used to move downward extractelement transition.; /// E.g.,; /// a = vector_op <2 x i32>; /// b = extractelement <2 x i32> a, i32 0; /// c = scalar_op b; /// store c; ///; /// =>; /// a = vector_op <2 x i32>; /// c = vector_op a (equivalent to scalar_op on the related lane); /// * d = extractelement <2 x i32> c, i32 0; /// * store d; /// Assuming both extractelement and store can be combine, we get rid of the; /// transition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,perform,perform,12,/// Used to perform some checks on the legality of vector operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:31,Availability,down,downwards,31,/// The transition being moved downwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:45,Availability,down,downward,45,"/// Promote \p ToBePromoted by moving \p Def downward through.; /// I.e., we have the following sequence:; /// Def = Transition <ty1> a to <ty2>; /// b = ToBePromoted <ty2> Def, ...; /// =>; /// b = ToBePromoted <ty1> a, ...; /// Def = Transition <ty1> ToBePromoted to <ty2>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:15,Safety,safe,safe,15,// This is not safe to introduce undef when the operand is on; // the right hand side of a division-like instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:72,Availability,down,downward,72,/// Check if it is profitable to promote \p ToBePromoted; /// by moving downward the transition through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:248,Availability,down,down,248,"// At this point, we know that all the operands of ToBePromoted but Def; // can be statically promoted.; // For Def, we need to use its parameter in ToBePromoted:; // b = ToBePromoted ty1 a; // Def = Transition ty1 b to ty2; // Move the transition down.; // 1. Replace all uses of the promoted operation by the transition.; // = ... b => = ... Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:6,Deployability,Update,Update,6,// 2. Update the type of the uses.; // b = ToBePromoted ty2 Def => b = ToBePromoted ty1 Def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:6,Deployability,Update,Update,6,// 3. Update all the operands of the promoted operation with promoted; // operands.; // b = ToBePromoted ty1 Def => b = ToBePromoted ty1 a.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Safety,safe,safe,37,// Use a splat constant if it is not safe to use undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:88,Availability,down,down,88,"// At this point we know that Inst is a vector to scalar transition.; // Try to move it down the def-use chain, until:; // - We can combine the transition with its single use; // => we got rid of the transition.; // - We escape the current basic block; // => we would need to check that we are moving it at a cheaper place and; // we do not do that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:165,Energy Efficiency,efficient,efficient,165,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1367,Testability,log,logic,1367,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:966,Usability,simpl,simple,966,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Usability,simpl,simple,10,// Handle simple but common cases only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:76,Performance,scalab,scalable,76,"// The code below assumes shifting a value by <number of bits>,; // whereas scalable vectors would have to be shifted by; // <2log(vscale) + number of bits> in order to store the; // low/high parts. Bailing out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:555,Availability,alive,alive,555,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:628,Availability,alive,alive,628,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1039,Availability,alive,alive,1039,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1098,Availability,alive,alive,1098,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1366,Availability,alive,alive,1366,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Energy Efficiency,reduce,reduce,25,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1325,Energy Efficiency,reduce,reduced,1325,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1590,Performance,optimiz,optimizations,1590,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1572,Usability,simpl,simplications,1572,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:24,Usability,simpl,simple,24,// Check that GEPI is a simple gep with a single constant index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:58,Availability,alive,alive,58,"// Check that GEP is used outside the block, meaning it's alive on the; // IndirectBr edge(s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:73,Availability,alive,alive,73,// Check each user of GEPIOp to check if unmerging would make GEPIOp not alive; // on IndirectBr edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Usability,simpl,simple,23,"// Check if UGEPI is a simple gep with a single constant index and GEPIOp is; // the pointer operand to it. If so, record it in the vector. If not, give; // up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Safety,avoid,avoid,86,"// If GEPI is not inbounds but UGEPI is inbounds, change UGEPI to not; // inbounds to avoid UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Availability,alive,alive,82,"// After unmerging, verify that GEPIOp is actually only used in SrcBlock (not; // alive on IndirectBr edges).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,Performance,optimiz,optimizations,54,// Bail out if we inserted the instruction to prevent optimizations from; // stepping on each other's toes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:38,Performance,optimiz,optimizations,38,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:134,Safety,detect,detect,134,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:61,Usability,Simpl,SimplifyCFG,61,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:76,Energy Efficiency,efficient,efficient,76,"// freeze(icmp a, const)) -> icmp (freeze a), const; // This helps generate efficient conditional jumps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Modifiability,rewrite,rewrite,96,// In this pass we look for GEP and cast instructions that are used; // across basic blocks and rewrite them to improve basic-block-at-a-time; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:136,Performance,optimiz,optimize,136,// For huge function we tend to quickly go though the inner optmization; // opportunities in the BB. So we go back to the BB head to re-optimize; // each instruction instead of go back to the function head.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,optimiz,optimizations,12,// Some CGP optimizations may move or alter what's computed in a block. Check; // whether a dbg.value intrinsic could be pointed at a more appropriate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Deployability,update,update,122,"// Point dbg.value at locally computed address, which should give the best; // opportunity to be accurately lowered. This update may change the type; // of pointer being referred to; however this makes no difference to; // debugging information, and we can't generate bitcasts that may affect; // codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Deployability,update,update,122,"// Point dbg.value at locally computed address, which should give the best; // opportunity to be accurately lowered. This update may change the type; // of pointer being referred to; however this makes no difference to; // debugging information, and we can't generate bitcasts that may affect; // codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:75,Performance,optimiz,optimizations,75,"// A llvm.dbg.value may be using a value before its definition, due to; // optimizations in this pass and others. Scan for such dbg.values, and rescue; // them by moving the dbg.value to immediately after the value definition.; // FIXME: Ideally this should never be necessary, and this has the potential; // to re-order dbg.value intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:17,Integrability,depend,depend,17,"// This item may depend on multiple instructions, complicating any; // potential sink. This block takes the defensive approach, opting to; // ""undef"" the item if it has more than one instruction and any of them do; // not dominate iem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Integrability,depend,depend,9,"// If we depend on multiple instructions and any of them doesn't; // dominate this DVI, we probably can't salvage it: moving it to; // after any of the instructions could cause us to lose the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Integrability,depend,dependencies,103,// Group scattered pseudo probes in a block to favor SelectionDAG. Scattered; // probes can be chained dependencies of other regular DAG nodes and block DAG; // combine optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:169,Performance,optimiz,optimizations,169,// Group scattered pseudo probes in a block to favor SelectionDAG. Scattered; // probes can be chained dependencies of other regular DAG nodes and block DAG; // combine optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Availability,down,down,10,/// Scale down both weights to fit into uint32_t.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:519,Performance,optimiz,optimizations,519,"/// Some targets prefer to split a conditional branch like:; /// \code; /// %0 = icmp ne i32 %a, 0; /// %1 = icmp ne i32 %b, 0; /// %or.cond = or i1 %0, %1; /// br i1 %or.cond, label %TrueBB, label %FalseBB; /// \endcode; /// into multiple branch instructions like:; /// \code; /// bb1:; /// %0 = icmp ne i32 %a, 0; /// br i1 %0, label %TrueBB, label %bb2; /// bb2:; /// %1 = icmp ne i32 %b, 0; /// br i1 %1, label %TrueBB, label %FalseBB; /// \endcode; /// This usually allows instruction selection to do even further optimizations; /// and combine the compare with the branch instruction. Currently this is; /// applied for targets which have ""cheap"" jump instructions.; ///; /// FIXME: Remove the (equivalent?) implementation in SelectionDAG.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update original basic block by using the first condition directly by the; // branch instruction and removing the no longer needed and/or instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Integrability,Depend,Depending,3,// Depending on the condition we have to either replace the true or the; // false successor of the original branch instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:472,Deployability,update,update,472,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:327,Integrability,Depend,Depending,327,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:452,Performance,perform,perform,452,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update the branch weights (from SelectionDAGBuilder::; // FindMergedConditions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:46,Integrability,Interface,Interface,46,"//===-- CommandFlags.cpp - Command Line Flags Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains codegen-specific flags that are shared between different; // command line tools. The tools ""llc"" and ""opt"" both use this file to prevent; // flag duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:35,Security,expose,expose,35,// FIXME: Command line flag should expose separate input/output modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:35,Security,expose,expose,35,// FIXME: Command line flag should expose separate input/output modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:668,Availability,mask,mask,668,"//===- ComplexDeinterleavingPass.cpp --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid Compos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1097,Availability,error,errors,1097,"rt of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:869,Performance,perform,performed,869,"//===- ComplexDeinterleavingPass.cpp --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid Compos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1341,Performance,Scalab,Scalable,1341,"sible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within said nodes. It also; // holds onto a reference to the root Instruction, and the root node that should; // replace it.; //; // ComplexDeinterleavingCompositeNode:; // A CompositeNode represents a single transformation point; each node should; // transform into a single complex instruction (ignoring vector splitting, which; // would",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1086,Security,validat,validation,1086,"rt of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1621,Security,validat,validate,1621,"complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within said nodes. It also; // holds onto a reference to the root Instruction, and the root node that should; // replace it.; //; // ComplexDeinterleavingCompositeNode:; // A CompositeNode represents a single transformation point; each node should; // transform into a single complex instruction (ignoring vector splitting, which; // would generate more instructions per node). They are identified in a; // depth-first manner, traversing and identifying the operands of each; // instruction in the order they appear in the IR.; // Each node maintains a refer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:21,Availability,mask,mask,21,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:55,Availability,mask,mask,55,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:109,Availability,mask,mask,109,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:269,Availability,mask,mask,269,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:21,Availability,mask,mask,21,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:55,Availability,mask,mask,55,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:113,Availability,mask,mask,113,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:222,Availability,mask,mask,222,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:72,Usability,simpl,simple,72,"/// When examining a basic block for complex deinterleaving, if it is a simple; /// one-block loop, then the only incoming block is 'Incoming' and the; /// 'BackEdge' block is the block itself.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:399,Energy Efficiency,reduce,reduce,399,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:473,Energy Efficiency,reduce,reduce,473,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:524,Energy Efficiency,reduce,reduce,524,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:22,Safety,detect,detecting,22,"/// In the process of detecting a reduction, we consider a pair of; /// %ReductionOP, which we refer to as real and imag (or vice versa), and; /// traverse the use-tree to detect complex operations. As this is a reduction; /// operation, it will eventually reach RealPHI and ImagPHI, which corresponds; /// to the %ReductionOPs that we suspect to be complex.; /// RealPHI and ImagPHI are used by the identifyPHINode method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:172,Safety,detect,detect,172,"/// In the process of detecting a reduction, we consider a pair of; /// %ReductionOP, which we refer to as real and imag (or vice versa), and; /// traverse the use-tree to detect complex operations. As this is a reduction; /// operation, it will eventually reach RealPHI and ImagPHI, which corresponds; /// to the %ReductionOPs that we suspect to be complex.; /// RealPHI and ImagPHI are used by the identifyPHINode method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:84,Safety,detect,detection,84,/// Set this flag to true if RealPHI and ImagPHI were reached during reduction; /// detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:421,Performance,scalab,scalable,421,/// Identifies the Deinterleave operation applied to a vector containing; /// complex numbers. There are two ways to represent the Deinterleave; /// operation:; /// * Using two shufflevectors with even indices for /pReal instruction and; /// odd indices for /pImag instructions (only for fixed-width vectors); /// * Using two extractvalue instructions applied to `vector.deinterleave2`; /// intrinsic (for both fixed and scalable vectors),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:248,Availability,mask,mask,248,/// identifying the operation that represents a complex number repeated in a; /// Splat vector. There are two possible types of splats: ConstantExpr with; /// the opcode ShuffleVector and ShuffleVectorInstr. Both should have an; /// initialization mask with all values set to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:73,Availability,mask,masks,73,/// Identifies SelectInsts in a loop that has reduction with predication masks; /// and/or predicated tail folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:4,Performance,Perform,Perform,4,/// Perform the actual replacement of the underlying instruction graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:53,Availability,mask,mask,53,"// If the size is not even, it's not an interleaving mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Safety,Detect,Detect,3,// Detect 0 and 180 degrees rotation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Safety,Detect,Detect,3,// Detect 90 and 270 degrees rotation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:12,Usability,simpl,simple,12,// Identify simple one-block loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:33,Energy Efficiency,reduce,reduced,33,// Check if final instruction is reduced outside of current block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:38,Integrability,depend,depending,38,// Splats are represented differently depending on whether the repeated; // value is a constant or an Instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:77,Energy Efficiency,reduce,reduced,77,// Deinterleave complex vector outside of loop so that it can be finally; // reduced,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:541,Energy Efficiency,schedul,scheduler,541,"//===- CriticalAntiDepBreaker.cpp - Anti-dep breaker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:473,Integrability,depend,dependence,473,"//===- CriticalAntiDepBreaker.cpp - Anti-dep breaker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Usability,Clear,Clear,3,// Clear out the register class data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Usability,Clear,Clear,3,"// Clear ""do not change"" set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:148,Energy Efficiency,schedul,scheduled,148,"// If Reg is currently live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:54,Energy Efficiency,schedul,scheduling,54,"// Any register which was defined within the previous scheduling region; // may have been rescheduled and its lifetime may overlap with registers; // in ways not reflected in our current liveness state. For each such; // register, adjust the liveness state to be conservatively correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:115,Energy Efficiency,schedul,scheduled,115,"// Move the def index to the end of the previous region, to reflect; // that the def could theoretically have been scheduled at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:48,Integrability,depend,dependency,48,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Performance,latency,latency,20,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:12,Safety,safe,safe,12,"// It's not safe to change register allocation for source operands of; // instructions that have special allocation requirements. Also assume all; // registers used in a call must not be changed (ABI).; // FIXME: The issue with predicated instruction is more complex. We are being; // conservative here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:819,Safety,safe,safe,819,"// It's not safe to change register allocation for source operands of; // instructions that have special allocation requirements. Also assume all; // registers used in a call must not be changed (ABI).; // FIXME: The issue with predicated instruction is more complex. We are being; // conservative here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:55,Deployability,update,update,55,// Scan the register operands for this instruction and update; // Classes and RegRefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Deployability,Update,Update,3,"// Update liveness.; // Proceeding upwards, registers that are defed but not used in this; // instruction are now dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:80,Deployability,update,updates,80,"// Predicated defs are modeled as read + write, i.e. similar to two; // address updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:39,Deployability,update,update,39,"// For the reg itself and all subregs: update the def to current;; // reset the kill state, any restrictions, and references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:448,Performance,load,loads,448,"// Check all machine operands that reference the antidependent register and must; // be replaced by NewReg. Return true if any of their parent instructions may; // clobber the new register.; //; // Note: AntiDepReg may be referenced by a two-address instruction such that; // it's use operand is tied to a def operand. We guard against the case in which; // the two-address instruction also defines NewReg, as may happen with; // pre/postincrement loads. In this case, both the use and def operands are in; // RegRefs because the def is inserted by PrescanInstruction and not erased; // during ScanInstruction. So checking for an instruction with definitions of; // both NewReg and AntiDepReg covers it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:198,Performance,optimiz,optimizing,198,"// Don't allow the instruction defining AntiDepReg to earlyclobber its; // operands, in case they may be assigned to NewReg. In this case antidep; // breaking must fail, but it's too rare to bother optimizing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:63,Availability,repair,repair,63,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:82,Integrability,depend,dependence,82,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:161,Integrability,depend,dependence,161,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:92,Safety,safe,safe,92,"// If NewReg is dead and NewReg's most recent def is not before; // AntiDepReg's kill, it's safe to replace AntiDepReg with NewReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:29,Availability,avail,available,29,// No registers are free and available!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:176,Energy Efficiency,Schedul,ScheduleDAGInstrs,176,// Keep a map of the MachineInstr*'s back to the SUnit representing them.; // This is used for updating debug information.; //; // FIXME: Replace this with the existing map in ScheduleDAGInstrs::MISUnitMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:675,Availability,repair,repair,675,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:1240,Availability,avail,available,1240,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:147,Integrability,depend,dependencies,147,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:365,Integrability,depend,dependence,365,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:457,Integrability,depend,dependencies,457,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:510,Integrability,depend,dependencies,510,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:690,Integrability,depend,dependence,690,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:877,Integrability,depend,dependence,877,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:560,Safety,avoid,avoid,560,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:653,Safety,avoid,avoid,653,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:197,Availability,avail,available,197,"// Attempt to break anti-dependence edges on the critical path. Walk the; // instructions from the bottom up, tracking information about liveness; // as we go to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:25,Integrability,depend,dependence,25,"// Attempt to break anti-dependence edges on the critical path. Walk the; // instructions from the bottom up, tracking information about liveness; // as we go to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:388,Energy Efficiency,schedul,schedule,388,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:35,Integrability,depend,dependence,35,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:87,Integrability,depend,dependence,87,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:207,Integrability,depend,dependence,207,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:313,Integrability,depend,dependence,313,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:567,Integrability,depend,dependencies,567,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:717,Integrability,depend,dependencies,717,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:289,Safety,avoid,avoid,289,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:22,Integrability,depend,dependence,22,// Only consider anti-dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies on non-allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:42,Availability,down,down,42,// Don't break anti-dependencies if a use down below requires; // this exact register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies if a use down below requires; // this exact register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:185,Energy Efficiency,schedul,scheduled,185,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:26,Integrability,depend,dependencies,26,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:69,Integrability,depend,depends,69,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:112,Integrability,depend,dependency,112,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:250,Integrability,depend,dependencies,250,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:318,Integrability,depend,dependency,318,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If this instruction's defs have special allocation requirement, don't; // break this anti-dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:57,Integrability,depend,dependence,57,"// Look for a suitable register to use to break the anti-dependence.; //; // TODO: Instead of picking the first free register, consider which might; // be the best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update the references to the old register to refer to the new; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:39,Deployability,update,updated,39,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:127,Deployability,update,update,127,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependence,93,// We just went back in time and modified history; the; // liveness information for the anti-dependence reg is now; // inconsistent. Set the state as if it were dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:541,Energy Efficiency,schedul,scheduler,541,"//===- llvm/CodeGen/CriticalAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:473,Integrability,depend,dependence,473,"//===- llvm/CodeGen/CriticalAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:66,Integrability,depend,dependencies,66,"/// The set of allocatable registers.; /// We'll be ignoring anti-dependencies on non-allocatable registers,; /// because they may not be safe to break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:138,Safety,safe,safe,138,"/// The set of allocatable registers.; /// We'll be ignoring anti-dependencies on non-allocatable registers,; /// because they may not be safe to break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:79,Integrability,depend,dependencies,79,/// A set of registers which are live and cannot be changed to; /// break anti-dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:68,Energy Efficiency,Schedul,ScheduleDAG,68,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:404,Usability,simpl,simple,404,"//===- DeadMachineInstructionElim.cpp - Remove dead machine instructions --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level dead-code-elimination pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:109,Integrability,depend,dependent,109,"// Loop over all instructions in all blocks, from bottom to top, so that it's; // more likely that chains of dependent but ultimately dead instructions will; // be cleaned up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:121,Modifiability,variab,variable,121,// It is possible that some DBG_VALUE instructions refer to this; // instruction. They will be deleted in the live debug variable; // analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:7,Safety,Detect,DetectDeadLanes,7,"//===- DetectDeadLanes.cpp - SubRegister Lane Usage Analysis --*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:610,Safety,detect,detect,610,"//===- DetectDeadLanes.cpp - SubRegister Lane Usage Analysis --*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:10,Deployability,PATCH,PATCHPOINT,10,"// FIXME: PATCHPOINT instructions announce a Def that does not always exist,; // they really need to be modeled differently!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:4,Deployability,update,update,4,/// update the operand status.; /// The first return value shows whether MF been changed.; /// The second return value indicates we need to call; /// DeadLaneDetector::computeSubRegisterLaneBitInfo and this function again; /// to propagate changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:314,Safety,safe,safe,314,"// Don't bother if we won't track subregister liveness later. This pass is; // required for correctness if subregister liveness is enabled because the; // register coalescer cannot deal with hidden dead defs. However without; // subregister liveness enabled, the expected benefits of this pass are small; // so we safe the compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:679,Energy Efficiency,Schedul,Schedule,679,"//=- llvm/CodeGen/DFAPacketizer.cpp - DFA Packetizer for VLIW -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:937,Energy Efficiency,consumption,consumption,937,"//=- llvm/CodeGen/DFAPacketizer.cpp - DFA Packetizer for VLIW -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:56,Availability,avail,available,56,// Check if the resources occupied by a MCInstrDesc are available in the; // current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:64,Availability,avail,available,64,// Check if the resources occupied by a machine instruction are available; // in the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:13,Energy Efficiency,schedul,scheduling,13,// Build the scheduling graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:34,Availability,avail,available,34,// Ask DFA if machine resource is available for MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:3,Integrability,Depend,Dependency,3,// Dependency check for MI with instructions in CurrentPacketMIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:26,Integrability,depend,dependency,26,// Allow packetization if dependency can be pruned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:21,Integrability,depend,dependency,21,// End the packet if dependency cannot be pruned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:37,Availability,avail,available,37,"// End the packet if resource is not available, or if the instruction; // should not be added to the current packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:437,Energy Efficiency,adapt,adapted,437,"//===- DwarfEHPrepare - Prepare exception handling for code generation ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:437,Modifiability,adapt,adapted,437,"//===- DwarfEHPrepare - Prepare exception handling for code generation ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:69,Usability,resume,resume,69,"/// Return the exception object from the value passed into; /// the 'resume' instruction (typically an aggregate). Clean up any dead; /// instructions, including the 'resume' instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:167,Usability,resume,resume,167,"/// Return the exception object from the value passed into; /// the 'resume' instruction (typically an aggregate). Clean up any dead; /// instructions, including the 'resume' instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:12,Usability,resume,resumes,12,/// Replace resumes that are not reachable from a cleanup landing pad with; /// unreachable and then simplify those blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:101,Usability,simpl,simplify,101,/// Replace resumes that are not reachable from a cleanup landing pad with; /// unreachable and then simplify those blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:16,Usability,Resume,ResumeInsts,16,/// Convert the ResumeInsts that are still present; /// into calls to the appropriate _Unwind_Resume function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:55,Usability,simpl,simplifycfg,55,"// Otherwise, insert unreachable instructions and call simplifycfg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:114,Usability,resume,resume,114,"// Instead of creating a new BB and PHI node, just append the call to; // _Unwind_Resume to the end of the single resume block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:41,Usability,Resume,ResumeInst,41,// Extract the exception object from the ResumeInst and add it to the PHI node; // that feeds the _Unwind_Resume call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:10,Testability,test,testing,10,// Stress testing mode - disable heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:205,Performance,perform,performs,205,"//===----------------------------------------------------------------------===//; // SSAIfConv; //===----------------------------------------------------------------------===//; //; // The SSAIfConv class performs if-conversion on SSA form machine code after; // determining if it is possible. The class contains no heuristics; external; // code should be used to determine when if-conversion is a good idea.; //; // SSAIfConv can convert both triangles and diamonds:; //; // Triangle: Head Diamond: Head; // | \ / \_; // | \ / |; // | [TF]BB FBB TBB; // | / \ /; // | / \ /; // Tail Tail; //; // Instructions in the conditional blocks TBB and/or FBB are spliced into the; // Head block, and phis in the Tail block are converted to select instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,Safety,safe,safely,65,/// Return true if all non-terminator instructions in MBB can be safely; /// speculated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,Safety,safe,safely,65,/// Return true if all non-terminator instructions in MBB can be safely; /// predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:46,Deployability,update,update,46,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:29,Integrability,depend,dependencies,29,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:97,Integrability,depend,dependency,97,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:23,Modifiability,rewrite,rewrite,23,/// Insert selects and rewrite PHI operands to use them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:101,Safety,safe,safely,101,"// end anonymous namespace; /// canSpeculateInstrs - Returns true if all the instructions in MBB can safely; /// be speculated. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:19,Performance,load,loads,19,"// Don't speculate loads. Note that it may be possible and desirable to; // speculate GOT or constant pool loads that are guaranteed not to trap,; // but we don't support that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:107,Performance,load,loads,107,"// Don't speculate loads. Note that it may be possible and desirable to; // speculate GOT or constant pool loads that are guaranteed not to trap,; // but we don't support that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:17,Integrability,depend,dependencies,17,// Check for any dependencies on Head instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:27,Integrability,depend,dependencies,27,"/// Check that there is no dependencies preventing if conversion.; ///; /// If instruction uses any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:73,Safety,safe,safely,73,"/// canPredicateInstrs - Returns true if all the instructions in MBB can safely; /// be predicates. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:17,Integrability,depend,dependencies,17,// Check for any dependencies on Head instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:32,Integrability,depend,depends,32,// Some of the conditional code depends in I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Deployability,Update,Update,3,// Update live regunits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Modifiability,rewrite,rewritePHIOperands,4,"/// rewritePHIOperands - When there are additional Tail predecessors, insert; /// select instructions in Head and rewrite PHI operands to use the selects.; /// Keep the PHI instructions in Tail to handle the other predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:114,Modifiability,rewrite,rewrite,114,"/// rewritePHIOperands - When there are additional Tail predecessors, insert; /// select instructions in Head and rewrite PHI operands to use the selects.; /// Keep the PHI instructions in Tail to handle the other predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite PHI operands TPred -> (DstReg, Head), remove FPred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Deployability,Update,Update,3,// Update statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Deployability,Update,Update,4,/// Update the dominator tree after if-conversion erased some blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Deployability,Update,Update,4,/// Update LoopInfo after if-conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:113,Usability,simpl,simply,113,"// If-conversion doesn't change loop structure, and it doesn't mess with back; // edges, so updating LoopInfo is simply removing the dead blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Availability,down,downward,22,// Adjust cycles with downward saturation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:59,Performance,optimiz,optimization,59,/// Helper class to simplify emission of cycle counts into optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:20,Usability,simpl,simplify,20,/// Helper class to simplify emission of cycle counts into optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:10,Testability,test,testing,10,// Stress testing mode disables all cost considerations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:76,Safety,predict,predictable,76,// Do not try to if-convert if the condition has a high chance of being; // predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:148,Performance,load,load,148,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:46,Safety,predict,predictable,46,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:187,Safety,predict,predictable,187,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:143,Integrability,depend,dependency,143,"// Assume that the depth of the first head terminator will also be the depth; // of the select instruction inserted, as determined by the flag dependency.; // TBB / FBB data dependencies may delay the select even more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:174,Integrability,depend,dependencies,174,"// Assume that the depth of the first head terminator will also be the depth; // of the select instruction inserted, as determined by the flag dependency.; // TBB / FBB data dependencies may delay the select even more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Deployability,update,update,22,// If-convert MBB and update analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:233,Deployability,update,update,233,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:221,Safety,safe,safe,221,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Deployability,update,update,22,// If-convert MBB and update analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:233,Deployability,update,update,233,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:221,Safety,safe,safe,221,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:8,Deployability,release,release,8,// Also release the next DomainValue in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Deployability,Update,Update,3,// Update DVRef to point to DV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Usability,Clear,Clear,3,// Clear the old DomainValue so we won't try to swizzle instructions twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:17,Usability,clear,clearances,17,// Save register clearances at end of MBB - used by enterBasicBlock().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Deployability,Update,Update,3,// Update instructions with explicit execution domains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:14,Availability,avail,available,14,// Bitmask of available domains for this instruction after taking collapsed; // operands into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:34,Availability,avail,available,34,// Bitmask of domains that dv and available have in common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:12,Availability,avail,available,12,"// Restrict available domains to the ones in common with the operand.; // If there are no common domains, we must pay the cross-domain; // penalty for this operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:48,Availability,avail,available,48,"// Kill off any remaining uses that don't match available, and build a list of; // incoming DomainValues that we want to merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:247,Integrability,depend,dependencies,247,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:205,Safety,avoid,avoid,205,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:87,Usability,clear,clearance,87,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:46,Energy Efficiency,power,powers,46,// The backend has peephole optimizations for powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:28,Performance,optimiz,optimizations,28,// The backend has peephole optimizations for powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:47,Performance,load,load,47,"//===--- ExpandMemCmp.cpp - Expand memcmp() to load/stores ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass tries to expand memcmp() calls into optimally-sized loads and; // compares for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:445,Performance,load,loads,445,"//===--- ExpandMemCmp.cpp - Expand memcmp() to load/stores ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass tries to expand memcmp() calls into optimally-sized loads and; // compares for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:134,Performance,load,loads,134,"// Represents the decomposition in blocks of the expansion. For example,; // comparing 33 bytes on X86+sse can be done with 2x16-byte loads and; // 1x1-byte load, which would be represented as [{16, 0}, {16, 16}, {1, 32}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:157,Performance,load,load,157,"// Represents the decomposition in blocks of the expansion. For example,; // comparing 33 bytes on X86+sse can be done with 2x16-byte loads and; // 1x1-byte load, which would be represented as [{16, 0}, {16, 16}, {1, 32}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:19,Performance,load,load,19,"// The size of the load for this block, in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:22,Performance,load,load,22,"// The offset of this load from the base pointer, in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:40,Performance,load,loads,40,// Do not expand if the total number of loads is larger than what the; // target allows. Note that it's important that we exit before completing; // the expansion to avoid using a ton of memory to store the expansion for; // large sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:166,Safety,avoid,avoid,166,// Do not expand if the total number of loads is larger than what the; // target allows. Note that it's important that we exit before completing; // the expansion to avoid using a ton of memory to store the expansion for; // large sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:40,Performance,load,loads,40,// We try to do as many non-overlapping loads as possible starting from the; // beginning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:48,Performance,load,load,48,"// There remain 0 to (MaxLoadSize - 1) bytes to load, this will be done with; // an overlapping load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:96,Performance,load,load,96,"// There remain 0 to (MaxLoadSize - 1) bytes to load, this will be done with; // an overlapping load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:25,Performance,load,loads,25,// Bail if the number of loads (non-overlapping + potential overlapping one); // is larger than the max allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,// Add non-overlapping loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:28,Performance,load,load,28,// Add the last overlapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:33,Performance,optimiz,optimize,33,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:46,Performance,Load,LoadSequence,46,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:107,Performance,load,loads,107,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:101,Performance,load,load,101,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:184,Performance,load,load,184,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:206,Performance,Load,LoadCmpBlocks,206,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:384,Performance,Load,LoadCmpBlock,384,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:22,Availability,down,down,22,// Scale the max size down if the target can load more bytes than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:45,Performance,load,load,45,// Scale the max size down if the target can load more bytes than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:27,Performance,load,loads,27,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:41,Performance,load,load,41,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:99,Performance,load,loads,99,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:26,Performance,load,load,26,// Create a constant or a load from the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:8,Modifiability,extend,extend,8,// Zero extend if Byte Swap intrinsic has different type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:8,Modifiability,extend,extend,8,// Zero extend if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:49,Performance,load,loading,49,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:86,Performance,load,loads,86,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:196,Performance,load,loaded,196,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:86,Performance,Load,LoadCmpBlock,86,"// Early exit branch if difference found to EndBlock. Otherwise, continue to; // next LoadCmpBlock,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:61,Performance,load,loaded,61,/// Generate an equality comparison for one or more pairs of loaded values.; /// This is used in the case where the memcmp() call is compared equal or not; /// equal to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or. The type for the combinations is the largest load; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:146,Performance,load,load,146,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or. The type for the combinations is the largest load; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,load,23,"// If there's only one load per block, we just compare the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Performance,load,loaded,59,"// If there's only one load per block, we just compare the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:89,Performance,Load,LoadCmpBlock,89,"// Early exit branch if difference found to ResultBlock. Otherwise,; // continue to next LoadCmpBlock or EndBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:31,Performance,Load,LoadCmpBlock,31,// Add a phi edge for the last LoadCmpBlock to Endblock with a value of 0; // since early exit to ResultBlock was not taken (no difference was found in; // any of the bytes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:48,Performance,load,loading,48,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:90,Performance,Load,LoadSize,90,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:103,Performance,load,loads,103,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:142,Performance,Load,LoadSize,142,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:266,Performance,load,loaded,266,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:457,Performance,Load,LoadCmpBlock,457,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:510,Performance,Load,LoadCmpBlock,510,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:524,Performance,Load,Loading,524,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:657,Performance,load,loaded,657,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:637,Usability,simpl,simply,637,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:16,Performance,load,load,16,"// There is one load per block in this case, BlockIndex == LoadIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Performance,Load,LoadIndex,59,"// There is one load per block in this case, BlockIndex == LoadIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:11,Performance,load,loaded,11,// Add the loaded values to the phi nodes for calculating memcmp result only; // if result is not used in a zero equality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:89,Performance,Load,LoadCmpBlock,89,"// Early exit branch if difference found to ResultBlock. Otherwise, continue; // to next LoadCmpBlock or EndBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:31,Performance,Load,LoadCmpBlock,31,// Add a phi edge for the last LoadCmpBlock to Endblock with a value of 0; // since early exit to ResultBlock was not taken (no difference was found in; // any of the bytes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:115,Performance,load,loaded,115,// This function populates the ResultBlock with a sequence to calculate the; // memcmp result. It compares the two loaded source values and returns -1 if; // src1 < src2 and 1 if src1 > src2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:112,Usability,simpl,simply,112,"// Special case: if memcmp result is used in a zero equality, result does not; // need to be calculated and can simply return 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:26,Performance,load,load,26,// Note: this assumes one load per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:35,Performance,Load,LoadCmpBlocks,35,// This loop populates each of the LoadCmpBlocks with the IR sequence to; // handle multiple loads per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:93,Performance,load,loads,93,// This loop populates each of the LoadCmpBlocks with the IR sequence to; // handle multiple loads per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:84,Performance,load,load,84,"/// A memcmp expansion that compares equality with 0 and only has one block of; /// load and compare can bypass the compare, branch, and phi IR that is required; /// in the general case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:345,Energy Efficiency,efficient,efficient,345,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:50,Performance,load,load,50,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:57,Performance,load,loaded,57,"// The i8 and i16 cases don't need compares. We zext the loaded values and; // subtract them to get the suitable negative, zero, or positive i32 result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Modifiability,variab,variable,59,// In case of a successful match this call will set `Pred` variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:93,Modifiability,extend,extended,93,"// The result of memcmp is negative, zero, or positive, so produce that by; // subtracting 2 extended compare bits: sub (ugt, ult).; // If a target prefers to use selects to get -1/0/1, they should be able; // to transform this later. The inverse transform (going from selects to math); // may not be possible in the DAG because the selects got converted into; // branches before we got there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:148,Performance,load,loaded,148,"// If return value of memcmp is not used in a zero equality, we need to; // calculate which source was larger. The calculation requires the; // two loaded source values of each load compare block.; // These will be saved in the phi nodes created by setupResultBlockPHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:177,Performance,load,load,177,"// If return value of memcmp is not used in a zero equality, we need to; // calculate which source was larger. The calculation requires the; // two loaded source values of each load compare block.; // These will be saved in the phi nodes created by setupResultBlockPHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:33,Performance,load,load,33,// Create the number of required load compare basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:3,Deployability,Update,Update,3,// Update the terminator added by SplitBlock to branch to the first; // LoadCmpBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:72,Performance,Load,LoadCmpBlock,72,// Update the terminator added by SplitBlock to branch to the first; // LoadCmpBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:413,Performance,load,loadbb,413,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:575,Performance,load,load,575,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:603,Performance,load,load,603,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:860,Performance,load,loadbb,860,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:899,Performance,load,loadbb,899,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:978,Performance,load,loadbb,978,"is function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1159,Performance,load,loadbb,1159,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1419,Performance,load,load,1419,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1449,Performance,load,load,1449,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2013,Performance,load,load,2013,"_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2043,Performance,load,load,2043,"_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2533,Performance,load,load,2533," preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 %phi.res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2561,Performance,load,load,2561," preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 %phi.res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:78,Availability,avail,available,78,"// TTI call to check if target would like to expand memcmp. Also, get the; // available load sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:88,Performance,load,load,88,"// TTI call to check if target would like to expand memcmp. Also, get the; // available load sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:42,Performance,load,loads,42,// Don't expand if this will require more loads than desired by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp:27,Energy Efficiency,Reduce,Reduce,27,/// runOnMachineFunction - Reduce subregister inserts and extracts to register; /// copies.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp:16,Testability,log,logical,16,"// Canonicalize logical or/and reductions:; // Or reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp ne iReduxWidth %val, 0; // And reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp eq iReduxWidth %val, 11111",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:49,Availability,mask,mask,49,///// Helpers {; /// \returns Whether the vector mask \p MaskVal has all lane bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:57,Availability,Mask,MaskVal,57,///// Helpers {; /// \returns Whether the vector mask \p MaskVal has all lane bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:46,Availability,mask,mask,46,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:31,Integrability,depend,depends,31,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:289,Performance,scalab,scalable,289,/// \returns A bitmask that is true where the lane position is less-than \p; /// EVLParam; ///; /// \p Builder; /// Used for instruction creation.; /// \p VLParam; /// The explicit vector length parameter to test against the lane; /// positions.; /// \p ElemCount; /// Static (potentially scalable) number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:208,Testability,test,test,208,/// \returns A bitmask that is true where the lane position is less-than \p; /// EVLParam; ///; /// \p Builder; /// Used for instruction creation.; /// \p VLParam; /// The explicit vector length parameter to test against the lane; /// positions.; /// \p ElemCount; /// Static (potentially scalable) number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:24,Performance,Scalab,Scalable,24,// TODO add caching; // Scalable vector %evl conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:26,Performance,perform,performs,26,// `get_active_lane_mask` performs an implicit less-than comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:12,Safety,safe,safe,12,// Blend in safe operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:7,Safety,safe,safely,7,// Can safely ignore the predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:45,Availability,mask,masked-off,45,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Safety,safe,safe,29,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Availability,mask,masked-out,29,// Insert neutral element in masked-out positions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:44,Availability,mask,mask,44,// Convert the %evl predication into vector mask predication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:58,Availability,mask,mask,58,// Converting a speculatable VP intrinsic means dropping %mask and %evl.; // No need to expand %evl into the %mask only to ignore that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:110,Availability,mask,mask,110,// Converting a speculatable VP intrinsic means dropping %mask and %evl.; // No need to expand %evl into the %mask only to ignore that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:228,Availability,mask,mask,228,"// We have to preserve the predicating effect of %evl for this; // non-speculatable VP intrinsic.; // 1) Never discard %evl.; // 2) If this VP intrinsic will be expanded to non-VP code, make sure that; // %evl gets folded into %mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:76,Energy Efficiency,efficient,efficient,76,"// Overrides set - we are in testing, the following does not need to be; // efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Testability,test,testing,29,"// Overrides set - we are in testing, the following does not need to be; // efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp:7,Availability,Fault,FaultMaps,7,"//===- FaultMaps.cpp ------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp:30,Deployability,Patch,Patchable,30,"//===-- FEntryInsertion.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file edits function bodies to insert fentry calls.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:20,Availability,redundant,redundant,20,"// Try to eliminate redundant copy to register which we're going to; // spill, i.e. try to change:; // X = COPY Y; // SPILL X; // to; // SPILL Y; // If there are no uses of X between copy and STATEPOINT, that COPY; // may be eliminated.; // Reg - register we're about to spill; // RI - On entry points to statepoint.; // On successful copy propagation set to new spill point.; // IsKill - set to true if COPY is Kill (there are no uses of Y); // Returns either found source copy register or original one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:20,Safety,redund,redundant,20,"// Try to eliminate redundant copy to register which we're going to; // spill, i.e. try to change:; // X = COPY Y; // SPILL X; // to; // SPILL Y; // If there are no uses of X between copy and STATEPOINT, that COPY; // may be eliminated.; // Reg - register we're about to spill; // RI - On entry points to statepoint.; // On successful copy propagation set to new spill point.; // IsKill - set to true if COPY is Kill (there are no uses of Y); // Returns either found source copy register or original one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:236,Energy Efficiency,reduce,reduce,236,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:201,Modifiability,extend,extends,201,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:339,Modifiability,extend,extend,339,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Cache,Cache,3,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:203,Performance,cache,cache,203,// Map size to list of frame indexes of this size. If the mode is; // FixupSCSExtendSlotSize then the key 0 is used to keep all frame indexes.; // If the size of required spill slot is greater than in a cache then the; // size will be increased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:110,Availability,avail,available,110,// Reset the current state of used frame indexes. After invocation of; // this function all frame indexes are available for allocation with; // the exception of slots reserved for landing pad processing (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:54,Modifiability,extend,extend,54,// If all sizes are kept together we probably need to extend the; // spill slot size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Availability,Mask,Mask,3,// Mask with callee saved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Cache,Cache,3,// Cache of frame indexes used on previous instruction processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:79,Performance,cache,cache,79,// Iterates over statepoint meta args to find caller saver registers.; // Also cache the size of found registers.; // Returns true if caller save registers found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:48,Modifiability,rewrite,rewrite,48,"// Leave `undef` operands as is, StackMaps will rewrite them; // into a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Perform,Perform,3,// Perform trivial copy propagation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp:160,Testability,log,logic,160,"// TODO If a block is an eh pad, or it has address taken, we don't remove; // it. Removing such blocks is possible, but it probably requires a more; // complex logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp:3,Deployability,Update,Update,3,// Update the jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:468,Availability,redundant,redundant,468,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:218,Safety,safe,safepoints,218,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:323,Safety,safe,safepoint,323,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:468,Safety,redund,redundant,468,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:32,Modifiability,rewrite,rewrites,32,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:126,Performance,load,loads,126,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:187,Performance,perform,performs,187,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:119,Usability,simpl,simple,119,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:120,Safety,safe,safe,120,/// GCMachineCodeAnalysis - This is a target-independent pass over the machine; /// function representation to identify safe points for the garbage collector; /// in the machine code. It inserts labels at safe points and populates a; /// GCMetadata record for each function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:205,Safety,safe,safe,205,/// GCMachineCodeAnalysis - This is a target-independent pass over the machine; /// function representation to identify safe points for the garbage collector; /// in the machine code. It inserts labels at safe points and populates a; /// GCMetadata record for each function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:112,Safety,safe,safe,112,/// CouldBecomeSafePoint - Predicate to conservatively determine whether the; /// instruction could introduce a safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:64,Safety,safe,safe,64,"// The natural definition of instructions which could introduce safe points; // are:; //; // - call, invoke (AfterCall, BeforeCall); // - phis (Loops); // - invoke, ret, unwind (Exit); //; // However, instructions as seemingly inoccuous as arithmetic can become; // libcalls upon lowering (e.g., div i64 on a 32-bit platform), so instead; // it is necessary to take a conservative approach.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:18,Safety,safe,safe,18,// llvm.gcroot is safe because it doesn't do anything at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:59,Performance,load,loads,59,/// runOnFunction - Replace gcread/gcwrite intrinsics with loads and stores.; /// Leave gcroot intrinsics; the code generator needs to see those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:34,Usability,simpl,simple,34,// Replace a write barrier with a simple store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:40,Performance,load,load,40,// Replace a read barrier with a simple load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:33,Usability,simpl,simple,33,// Replace a read barrier with a simple load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:188,Deployability,update,updated,188,// Do not treat tail or sibling call sites as safe points. This is; // legal since any arguments passed to the callee which live in the; // remnants of the callers frame will be owned and updated by the; // callee if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:46,Safety,safe,safe,46,// Do not treat tail or sibling call sites as safe points. This is; // legal since any arguments passed to the callee which live in the; // remnants of the callers frame will be owned and updated by the; // callee if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:12,Safety,safe,safe,12,// Find all safe points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:672,Energy Efficiency,reduce,reduce,672,"//===- GlobalMerge.cpp - Internal globals merging -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:805,Modifiability,variab,variables,805,"merging -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; // ===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:1706,Performance,optimiz,optimizations,1706,"; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:110,Performance,optimiz,optimization,110,"// FIXME: this could be a transitional option, and we probably need to remove; // it if only we are sure this optimization could always benefit all targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:23,Modifiability,variab,variable,23,/// Check if the given variable has been identified as must keep; /// \pre setMustKeepGlobalVariables must have been called on the Module that; /// contains GV,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,"/// Collect every variables marked as ""used"" or used in a landing pad; /// instruction for this Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,"/// Collect every variables marked as ""used""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:36,Modifiability,variab,variables,36,// We don't support scalable global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:20,Performance,scalab,scalable,20,// We don't support scalable global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:201,Energy Efficiency,efficient,efficient,201,"// If we want to be smarter, look at all uses of each global, to try to; // discover all sets of globals used together, and how many times each of; // these sets occurred.; //; // Keep this reasonably efficient, by having an append-only list of all sets; // discovered so far (UsedGlobalSet), and mapping each ""together-ness"" unit of; // code (currently, a Function) to the set of globals seen so far that are; // used together in that unit (GlobalUsesByFunction).; //; // When we look at the Nth global, we know that any new set is either:; // - the singleton set {N}, containing this global only, or; // - the union of {N} and a previously-discovered set, containing some; // combination of the previous N-1 globals.; // Using that knowledge, when looking at the Nth global, we can keep:; // - a reference to the singleton set {N} (CurGVOnlySetIdx); // - a list mapping each previous set to its union with {N} (EncounteredUGS),; // if it actually occurs.; // We keep track of the sets of globals used together ""close enough"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:3,Safety,Avoid,Avoid,3,// Avoid repeating the create-global-set pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:228,Energy Efficiency,efficient,efficiently,228,"// Now, look at each merge-eligible global in turn.; // Keep track of the sets we already encountered to which we added the; // current global.; // Each element matches the same-index element in UsedGlobalSets.; // This lets us efficiently tell whether a set has already been expanded to; // include the current global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:17,Performance,optimiz,optimizing,17,"// If we're only optimizing for size, ignore non-minsize functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:13,Modifiability,variab,variables,13,"// If merged variables doesn't have external linkage, we needn't to expose; // the symbol after merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:68,Security,expose,expose,68,"// If merged variables doesn't have external linkage, we needn't to expose; // the symbol after merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:126,Modifiability,variab,variables,126,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:205,Modifiability,variab,variable,205,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:267,Safety,avoid,avoids,267,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:79,Modifiability,variab,variable,79,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:312,Modifiability,variab,variable,312,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:209,Safety,safe,safe,209,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:237,Safety,safe,safe,237,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:106,Security,access,accessed,106,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,// Extract global variables from llvm.used array,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,Safety,safe,safe,12,"// Merge is safe for ""normal"" internal or external globals only",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,Safety,safe,safe,12,// It's not safe to merge globals that may be preempted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:50,Deployability,update,updated,50,"// If the target requires the counter value to be updated in the loop,; // insert a phi to hold the value. The intended purpose is for use by; // loop_decrement_reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:80,Deployability,update,update,80,"// Create a new cmp, that checks the returned value of loop_decrement*,; // and update the exit branch to use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:166,Integrability,message,message,166,"// TODO: there can be many reasons a loop is not considered a; // candidate, so we should let isHardwareLoopCandidate fill in the; // reason and then report a better message here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:92,Testability,test,tests,92,// Can we replace a conditional branch with an intrinsic that sets the; // loop counter and tests that is not zero?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:31,Testability,test,test,31,"// If we're trying to use the 'test and set' form of the intrinsic, we need; // to replace a conditional branch that is controlling entry to the loop. It; // is likely (guaranteed?) that the preheader has an unconditional branch to; // the loop header, so also check if it has a single predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:15,Safety,safe,safe,15,// If it's not safe to create a while loop then don't force it and create a; // do-while loop instead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:370,Safety,avoid,avoid,370,"// FIXME: We've expanded Count where we hope to insert the counter setting; // intrinsic. But, in the case of the 'test and set' form, we may fallback to; // the just 'set' form and in which case the insertion block is most likely; // different. It means there will be instruction(s) in a block that possibly; // aren't needed. The isLoopEntryGuardedByCond is trying to avoid this issue,; // but it's doesn't appear to work in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:115,Testability,test,test,115,"// FIXME: We've expanded Count where we hope to insert the counter setting; // intrinsic. But, in the case of the 'test and set' form, we may fallback to; // the just 'set' form and in which case the insertion block is most likely; // different. It means there will be instruction(s) in a block that possibly; // aren't needed. The isLoopEntryGuardedByCond is trying to avoid this issue,; // but it's doesn't appear to work in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:103,Modifiability,variab,variable,103,"// The old condition may be dead now, and may have even created a dead PHI; // (the original induction variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:103,Modifiability,variab,variable,103,"// The old condition may be dead now, and may have even created a dead PHI; // (the original induction variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:47,Performance,cache,cache,47,"/// One per MachineBasicBlock, this is used to cache the result; /// if-conversion feasibility analysis. This includes results from; /// TargetInstrInfo::analyzeBranch() (i.e. TBB, FBB, and Cond), and its; /// classification, and common tail block of its successors (if it's a; /// diamond shape), its size, whether it's predicable, and whether any; /// instruction can clobber the 'would-be' predicate.; ///; /// IsDone - True if BB is not to be considered for ifcvt.; /// IsBeingAnalyzed - True if BB is currently being analyzed.; /// IsAnalyzed - True if BB has been analyzed (info is still valid).; /// IsEnqueued - True if BB has been enqueued to be ifcvt'ed.; /// IsBrAnalyzable - True if analyzeBranch() returns false.; /// HasFallThrough - True if BB may fallthrough to the following BB.; /// IsUnpredicable - True if BB is known to be unpredicable.; /// ClobbersPred - True if BB could modify predicates (e.g. has; /// cmp, call, etc.); /// NonPredSize - Number of non-predicated instructions.; /// ExtraCost - Extra cost for multi-cycle instructions.; /// ExtraCost2 - Some instructions are slower when predicated; /// BB - Corresponding MachineBasicBlock.; /// TrueBB / FalseBB- See analyzeBranch().; /// BrCond - Conditions for end of block conditional branches.; /// Predicate - Predicate used in the BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:59,Performance,perform,performance,59,"// Even though we're optimising for size at the expense of performance,; // avoid creating really long predicated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:76,Safety,avoid,avoid,76,"// Even though we're optimising for size at the expense of performance,; // avoid creating really long predicated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:22,Security,expose,expose,22,// Tail merge tend to expose more if-conversion opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:92,Performance,perform,perform,92,// Do an initial analysis for each basic block and find all the potential; // candidates to perform if-conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:44,Performance,queue,queue,44,"// If the block has been evicted out of the queue or it has already been; // marked dead (due to it being predicated), then skip it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:199,Performance,perform,performed,199,/// Returns true if the 'true' block (along with its predecessor) forms a valid; /// simple shape for ifcvt. It also returns the number of instructions that the; /// ifcvt would need to duplicate if performed in Dups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:85,Usability,simpl,simple,85,/// Returns true if the 'true' block (along with its predecessor) forms a valid; /// simple shape for ifcvt. It also returns the number of instructions that the; /// ifcvt would need to duplicate if performed in Dups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:364,Performance,perform,performed,364,"/// Returns true if the 'true' and 'false' blocks (along with their common; /// predecessor) forms a valid triangle shape for ifcvt. If 'FalseBranch' is; /// true, it checks if 'true' block's false branch branches to the 'false' block; /// rather than the other way around. It also returns the number of instructions; /// that the ifcvt would need to duplicate if performed in 'Dups'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:411,Deployability,update,update,411,"/// RescanInstructions - Run ScanInstructions on a pair of blocks.; /// @param TIB - True Iterator Begin, points to first non-shared instruction; /// @param FIB - False Iterator Begin, points to first non-shared instruction; /// @param TIE - True Iterator End, points past last non-shared instruction; /// @param FIE - False Iterator End, points past last non-shared instruction; /// @param TrueBBI - BBInfo to update for the true block.; /// @param FalseBBI - BBInfo to update for the false block.; /// @returns - false if either block cannot be predicated or if both blocks end; /// with a predicate-clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:471,Deployability,update,update,471,"/// RescanInstructions - Run ScanInstructions on a pair of blocks.; /// @param TIB - True Iterator Begin, points to first non-shared instruction; /// @param FIB - False Iterator Begin, points to first non-shared instruction; /// @param TIE - True Iterator End, points past last non-shared instruction; /// @param FIE - False Iterator End, points past last non-shared instruction; /// @param TrueBBI - BBInfo to update for the true block.; /// @param FalseBBI - BBInfo to update for the false block.; /// @returns - false if either block cannot be predicated or if both blocks end; /// with a predicate-clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:468,Safety,avoid,avoid,468,"/// ValidForkedDiamond - Returns true if the 'true' and 'false' blocks (along; /// with their common predecessor) form a diamond if a common tail block is; /// extracted.; /// While not strictly a diamond, this pattern would form a diamond if; /// tail-merging had merged the shared tails.; /// EBB; /// _/ \_; /// | |; /// TBB FBB; /// / \ / \; /// FalseBB TrueBB FalseBB; /// Currently only handles analyzable branches.; /// Specifically excludes actual diamonds to avoid overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:656,Integrability,depend,dependency,656,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:8,Safety,unsafe,unsafe,8,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:606,Safety,safe,safe,606,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:715,Safety,safe,safe,715,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:1236,Safety,unsafe,unsafe,1236,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:197,Usability,simpl,simple,197,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:1054,Usability,clear,clearly,1054,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:157,Safety,avoid,avoid,157,"// If it is already predicated but we couldn't analyze its terminator, the; // latter might fallthrough, but we can't determine where to.; // Conservatively avoid if-converting again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Testability,Test,Test,3,// Test predicate subsumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Usability,Simpl,Simple,3,"// Simple (split, no rejoin):; // EBB; // | \_; // | |; // | TBB---> exit; // |; // FBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:24,Safety,avoid,avoid,24,"// Check isSuccessor to avoid case where the next block is empty, but; // it's not a successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:58,Availability,mask,mask,58,// First handle regmasks. They clobber any entries in the mask which; // means that we need a def for those registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:131,Energy Efficiency,allocate,allocated,131,"// We also need to add an implicit def of this register for the later; // use to read from.; // For the register allocator to have allocated a register clobbered; // by the call which is used later, it must be the case that; // the call doesn't return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:17,Usability,simpl,simple,17,"/// If convert a simple (split, no rejoin) sub-CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if BB's address is taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:16,Deployability,update,updated,16,// Keep the CFG updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:245,Availability,avail,available,245,"// Now ifcvt'd block will look like this:; // BB:; // ...; // t, f = cmp; // if t op; // b BBf; //; // We cannot further ifcvt this block because the unconditional branch; // will have to be predicated on the new condition, that will not be; // available if cmp executes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info. BB can be iteratively if-converted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if BB's address is taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:16,Deployability,update,updated,16,// Keep the CFG updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,"// Update the edge probability for both CvtBBI->FalseBB and NextBBI.; // NewNext = New_Prob(BBI.BB, NextMBB) =; // Prob(BBI.BB, NextMBB) +; // Prob(BBI.BB, CvtMBB) * Prob(CvtMBB, NextMBB); // NewFalse = New_Prob(BBI.BB, CvtBBI->FalseBB) =; // Prob(BBI.BB, CvtMBB) * Prob(CvtMBB, CvtBBI->FalseBB)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info. BB can be iteratively if-converted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate these blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if either BB has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:50,Deployability,update,update,50,"// Since this instruction is going to be deleted, update call; // site info state if the instruction is call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:53,Safety,safe,safe,53,"// The branches have been checked to match, so it is safe to remove the; // branch in BB1 and rely on the copy in BB2. The complication is that; // the blocks may end with a return instruction, which may or may not; // be marked as ""branch"". If it's not, then it could be included in; // ""dups1"", leaving the blocks potentially empty after moving the common; // duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:50,Deployability,update,update,50,"// Since this instruction is going to be deleted, update call; // site info state if the instruction is call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,"// Removing branches from both blocks is safe, because we have already; // determined that both blocks have the same branch instructions. The branch; // will be added back at the end, unpredicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:116,Deployability,update,update,116,// We need to remove the edges to the true and false blocks manually since; // we didn't let IfConvertDiamondCommon update the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:69,Deployability,update,update,69,"// If we're about to splice an INLINEASM_BR from FromBBI, we need to update; // ToBBI's successor list accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:138,Availability,down,down,138,// Remove the old edge but remember the edge probability so we can calculate; // the correct weights on the new edges being added further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:53,Deployability,update,update,53,"// If the edge from ToBBI.BB to Succ already exists, update the; // probability of this edge by adding NewProb to it. An example is shown; // below, in which A is ToBBI.BB and B is FromMBB. In this case we; // don't have to set C as A's successor as it already is. We only need to; // update the edge probability on A->C. Note that B will not be; // immediately removed from A's successors. It is possible that B->D is; // not removed either if D is a fallthrough of B. Later the edge A->D; // (generated here) and B->D will be combined into one edge. To maintain; // correct edge probability of this combined edge, we need to set the edge; // probability of A->B to zero, which is already done above. The edge; // probability on A->D is calculated by scaling the original probability; // on A->B by the probability of B->D.; //; // Before ifcvt: After ifcvt (assume B->D is kept):; //; // A A; // /| /|\; // / B / B|; // | /| | ||; // |/ | | |/; // C D C D; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:285,Deployability,update,update,285,"// If the edge from ToBBI.BB to Succ already exists, update the; // probability of this edge by adding NewProb to it. An example is shown; // below, in which A is ToBBI.BB and B is FromMBB. In this case we; // don't have to set C as A's successor as it already is. We only need to; // update the edge probability on A->C. Note that B will not be; // immediately removed from A's successors. It is possible that B->D is; // not removed either if D is a fallthrough of B. Later the edge A->D; // (generated here) and B->D will be combined into one edge. To maintain; // correct edge probability of this combined edge, we need to set the edge; // probability of A->B to zero, which is already done above. The edge; // probability on A->D is calculated by scaling the original probability; // on A->B by the probability of B->D.; //; // Before ifcvt: After ifcvt (assume B->D is kept):; //; // A A; // /| /|\; // / B / B|; // | /| | ||; // |/ | | |/; // C D C D; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:748,Availability,fault,fault,748,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:769,Performance,Load,LoadStore,769,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:61,Security,access,accesses,61,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:440,Testability,test,test,440,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:96,Integrability,depend,dependences,96,"/// Helper function for \c computeDependence. Return true if \p A; /// and \p B do not have any dependences between them, and can be; /// re-ordered without changing program semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:194,Integrability,depend,dependency,194,/// A data type for representing the result computed by \c; /// computeDependence. States whether it is okay to reorder the; /// instruction passed to \c computeDependence with at most one; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:48,Integrability,depend,dependency,48,"// If this is non-null, then MemOperation has a dependency on this; // instruction; and it needs to be hoisted to execute before MemOperation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Integrability,Depend,DependenceMI,23,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:179,Integrability,Depend,DependenceMI,179,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:207,Safety,safe,safely,207,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,Availability,Fault,FaultingMI,22,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:125,Integrability,Depend,Dependence,125,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:206,Integrability,depend,dependency,206,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,Integrability,depend,dependency,22,"// Found one possible dependency, keep track of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:16,Integrability,depend,dependencies,16,"// We found two dependencies, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:60,Integrability,depend,dependencies,60,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:165,Integrability,depend,dependencies,165,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:154,Performance,load,load-store,154,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Security,access,access,23,"// If it is not memory access, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:3,Performance,Load,Load-Load,3,// Load-Load may alias,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:101,Testability,test,test,101,// Implementation restriction for faulting_op insertion; // TODO: This could be relaxed if we find a test case which warrants it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:101,Performance,perform,performed,101,// We need the base of the memory instruction to be same as the register; // where the null check is performed (i.e. PointerReg).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:78,Integrability,depend,depending,78,// Returns true if RegUsedInAddr is used for calculating the displacement; // depending on addressing mode. Also calculates the Displacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Integrability,depend,depends,23,"// Sign of the product depends on the sign of the ImmVal, since Multiplier; // is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:285,Availability,fault,faulting,285,"// The register which is not null checked should be part of the Displacement; // calculation, otherwise we do not know whether the Displacement is made up; // by some symbolic values.; // This matters because we do not want to incorrectly assume that load from; // falls in the zeroth faulting page in the ""sane offset check"" below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:251,Performance,load,load,251,"// The register which is not null checked should be part of the Displacement; // calculation, otherwise we do not know whether the Displacement is made up; // by some symbolic values.; // This matters because we do not want to incorrectly assume that load from; // falls in the zeroth faulting page in the ""sane offset check"" below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:123,Availability,reliab,reliably,123,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:137,Availability,fault,faults,137,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:19,Security,access,access,19,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:116,Security,access,access,116,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:45,Security,access,access,45,"// Finally, check whether the current memory access aliases with previous one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:413,Availability,fault,faulting,413,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:621,Availability,fault,faults,621,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:85,Integrability,Depend,Dependency,85,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:203,Integrability,depend,dependencies,203,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:422,Performance,load,load,422,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:464,Performance,load,loaded,464,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:501,Performance,load,load,501,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:583,Performance,load,load,583,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:596,Performance,load,loading,596,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:702,Performance,load,load,702,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:172,Safety,safe,safe,172,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:286,Testability,test,test,286,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:7,Integrability,depend,dependence,7,// The dependence does not clobber live-ins in NullSucc block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:272,Availability,Fault,FaultingMI,272,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:297,Availability,fault,faulting,297,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:45,Performance,load,loads,45,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:17,Usability,simpl,simplest,17,// We handle the simplest case for now. We can potentially do better by using; // the machine dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:91,Testability,test,test,91,"// To prevent the invalid transformation of the following code:; //; // mov %rax, %rcx; // test %rax, %rax; // %rax = ...; // je throw_npe; // mov(%rcx), %r9; // mov(%rax), %r10; //; // into:; //; // mov %rax, %rcx; // %rax = ....; // faulting_load_op(""movl (%rax), %r10"", throw_npe); // mov(%rcx), %r9; //; // we must ensure that there are no instructions between the 'test' and; // conditional jump that modify %rax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:370,Testability,test,test,370,"// To prevent the invalid transformation of the following code:; //; // mov %rax, %rcx; // test %rax, %rax; // %rax = ...; // je throw_npe; // mov(%rcx), %r9; // mov(%rax), %r10; //; // into:; //; // mov %rax, %rcx; // %rax = ....; // faulting_load_op(""movl (%rax), %r10"", throw_npe); // mov(%rcx), %r9; //; // we must ensure that there are no instructions between the 'test' and; // conditional jump that modify %rax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:274,Availability,Fault,FaultingLoad,274,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:691,Availability,fault,fault,691,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:769,Availability,fault,fault,769,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:811,Availability,fault,faulted,811,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1369,Integrability,depend,dependent,1369,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:934,Modifiability,extend,extended,934,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:194,Performance,Load,Load,194,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:619,Performance,load,load,619,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:757,Performance,load,load,757,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:797,Performance,load,load,797,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1224,Performance,load,load,1224,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1477,Performance,load,loaded,1477,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1341,Safety,safe,safety,1341,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:47,Testability,test,test,47,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:43,Availability,FAULT,FAULTING,43,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:82,Availability,FAULT,FAULTING,82,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:219,Availability,fault,faults,219,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:231,Availability,FAULT,FAULTING,231,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:4,Integrability,Wrap,Wrap,4,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:117,Performance,load,load,117,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:207,Security,access,access,207,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the null checks in NullCheckList into implicit null checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:33,Integrability,depend,dependent,33,// Remove the conditional branch dependent on the null check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:12,Availability,fault,faulting,12,"// Insert a faulting instruction where the conditional branch was; // originally. We check earlier ensures that this bit of code motion; // is legal. We do not touch the successors list for any basic block; // since we haven't changed control flow, we've just made it implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:47,Modifiability,rewrite,rewrite,47,// Build a list of indirectbrs that we want to rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:121,Availability,avail,available,121,// Handle the degenerate case of no successors by replacing the indirectbr; // with unreachable as there is no successor available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:196,Modifiability,rewrite,rewrite,196,// If we need to replace any indirectbrs we need to establish integer; // constants that will correspond to each of the basic blocks in the function; // whose address escapes. We do that here and rewrite all the blockaddress; // constants to just be those integer constants cast to a pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:74,Modifiability,rewrite,rewrite,74,// Skip blocks that aren't successors to an indirectbr we're going to; // rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:7,Modifiability,rewrite,rewrite,7,"// Now rewrite the blockaddress to an integer constant based on the index.; // FIXME: This part doesn't properly recognize other uses of blockaddress; // expressions, for instance, where they are used to pass labels to; // asm-goto. This part of the pass needs a rework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Modifiability,Variab,Variables,3,"// Variables that are valid during spill(), but used by multiple methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:542,Performance,load,load,542,"//===----------------------------------------------------------------------===//; // Snippets; //===----------------------------------------------------------------------===//; // When spilling a virtual register, we also spill any snippets it is connected; // to. The snippets are small live ranges that only have a single real use,; // leftovers from live range splitting. Spilling them enables memory operand; // folding or tightens the live range around the single use.; //; // This minimizes register pressure and maximizes the store-to-load distance for; // spill slots which can be important in tight loops.; /// isFullCopyOf - If MI is a COPY to or from Reg, return the other register,; /// otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Performance,load,loads,20,// Allow stack slot loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:18,Modifiability,extend,extend,18,// Conservatively extend the stack slot range to the range of the original; // value. We may be able to do better with stack slot coloring by being more; // careful here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:62,Usability,clear,clear,62,"// We are going to spill SrcVNI immediately after its def, so clear out; // any later spills of the same value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,Availability,redundant,redundant,84,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,Safety,redund,redundant,84,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,Availability,down,down,25,// Follow sibling copies down the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:86,Performance,load,load,86,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:118,Safety,avoid,avoids,118,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new register for the remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:192,Performance,load,load,192,"//===----------------------------------------------------------------------===//; // Spilling; //===----------------------------------------------------------------------===//; /// If MI is a load or store of StackSlot, it can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:19,Security,access,access,19,// We have a stack access. Is it the right register and slot?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:175,Performance,Load,LoadMI,175,/// foldMemoryOperand - Try folding stack slot references in Ops into their; /// instructions.; ///; /// @param Ops Operand indices from AnalyzeVirtRegInBundle().; /// @param LoadMI Load instruction to use instead of stack slot when non-null.; /// @return True on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:182,Performance,Load,Load,182,/// foldMemoryOperand - Try folding stack slot references in Ops into their; /// instructions.; ///; /// @param Ops Operand indices from AnalyzeVirtRegInBundle().; /// @param LoadMI Load instruction to use instead of stack slot when non-null.; /// @return True on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:77,Performance,load,load,77,// TII::foldMemoryOperand will do what we need here for statepoint; // (fold load into use and remove corresponding def). We will replace; // uses of removed def with loads (spillAroundUses).; // For that to work we need to untie def and use to pass it through; // foldMemoryOperand and signal foldPatchpoint that it is allowed to; // fold them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:167,Performance,load,loads,167,// TII::foldMemoryOperand will do what we need here for statepoint; // (fold load into use and remove corresponding def). We will replace; // uses of removed def with loads (spillAroundUses).; // For that to work we need to untie def and use to pass it through; // foldMemoryOperand and signal foldPatchpoint that it is allowed to; // fold them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:91,Deployability,patch,patchpoint,91,// Spill subregs if the target allows it.; // We always want to spill subregs for stackmap/patchpoint pseudos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Performance,load,load,20,// We cannot fold a load instruction into a def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:119,Testability,assert,assert,119,"// If we only have implicit uses, we won't be able to fold that.; // Moreover, TargetInstrInfo::foldMemoryOperand will assert if we try!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:158,Usability,simpl,simple,158,"// If we've folded a store into an instruction labelled with debug-info,; // record a substitution from the old operand to the memory operand. Handle; // the simple common case where operand 0 is the one being folded, plus when; // the destination operand is also a tied def. More values could be; // substituted / preserved with more analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:127,Performance,load,load,127,"// This is a debug-labelled instruction, but the operand being folded isn't; // at operand zero. Most likely this means it's a load being folded in.; // Substitute any register defs from operand zero up to the one being; // folded -- past that point, we don't know what the new operand indexes; // will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:14,Security,access,accesses,14,// Stack slot accesses may coalesce away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:52,Availability,down,downstream,52,// This is a reload for a sib-reg copy. Drop spills downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Deployability,Update,Update,3,// Update LiveStacks now that we are committed to spilling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:4,Performance,Optimiz,Optimizations,4,/// Optimizations after all the reg selections and spills are done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:97,Usability,clear,cleared,97,// save a copy of LiveInterval in StackSlotToOrigLI because the original; // LiveInterval may be cleared after all its references are spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:47,Availability,alive,alive,47,// TODO: We could be better here. If LI is not alive in landing pad; // we could hoist spill after LIP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:55,Availability,redundant,redundant,55,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,Safety,redund,redundant,11,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:55,Safety,redund,redundant,55,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:37,Availability,down,down,37,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:154,Availability,Redundant,Redundant,154,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:154,Safety,Redund,Redundant,154,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,Availability,redundant,redundant,75,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,Safety,redund,redundant,75,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,Availability,redundant,redundant,235,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:357,Availability,redundant,redundant,357,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,Safety,redund,redundant,235,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:357,Safety,redund,redundant,357,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,Availability,redundant,redundant,92,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,Safety,redund,redundant,92,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:36,Availability,down,down,36,// Sort the nodes in WorkSet in top-down order and save the nodes; // in Orders. Orders will be used for hoisting in runHoistSpills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:40,Usability,simpl,simply,40,"// If Block contains an original spill, simply continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,Usability,simpl,simply,25,"// No spills in subtree, simply continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,Availability,redundant,redundant,41,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:377,Availability,redundant,redundant,377,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,Safety,redund,redundant,41,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:377,Safety,redund,redundant,377,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Deployability,update,update,20,// Stack live range update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,Availability,redundant,redundant,10,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,Safety,redund,redundant,10,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:435,Performance,Cache,CacheEntries,435,"// Initializes PhysRegEntries (instead of a SmallVector, PhysRegEntries is a; // buffer of size NumPhysRegs to speed up alloc/clear for targets with large; // reg files). Calloced memory is used for good form, and quites tools like; // Valgrind too, but zero initialized memory is not required by the algorithm:; // this is because PhysRegEntries works like a SparseSet and its entries are; // only valid when there is a corresponding CacheEntries assignment. There is; // also support for when pass managers are reused for targets with different; // numbers of PhysRegs: in this case PhysRegEntries is freed and reinitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:126,Usability,clear,clear,126,"// Initializes PhysRegEntries (instead of a SmallVector, PhysRegEntries is a; // buffer of size NumPhysRegs to speed up alloc/clear for targets with large; // reg files). Calloced memory is used for good form, and quites tools like; // Valgrind too, but zero initialized memory is not required by the algorithm:; // this is because PhysRegEntries works like a SparseSet and its entries are; // only valid when there is a corresponding CacheEntries assignment. There is; // also support for when pass managers are reused for targets with different; // numbers of PhysRegs: in this case PhysRegEntries is freed and reinitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:44,Deployability,update,update,44,"/// revalidate - LIU contents have changed, update tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:29,Performance,cache,cache,29,"// LIU's changed, invalidate cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:27,Availability,mask,mask,27,// Also check for register mask interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,Availability,mask,mask,12,// Register mask i clobbers PhysReg before the LIU interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:27,Availability,mask,mask,27,// Also check for register mask interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,Availability,mask,mask,12,// Register mask i-1 clobbers PhysReg after the LIU interference.; // Model the regmask clobber as a dead def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:504,Availability,mask,masks,504,"//===- InterferenceCache.h - Caching per-block interference ----*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InterferenceCache remembers per-block interference from LiveIntervalUnions,; // fixed RegUnit interference, and register masks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:14,Performance,cache,cache,14,/// Entry - A cache entry containing interference information for all aliases; /// of PhysReg in all basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:10,Performance,Cache,Cache,10,/// Tag - Cache tag is changed when any of the underlying LiveIntervalUnions; /// change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:38,Availability,mask,mask,38,/// LIS - Used for accessing register mask interference maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Security,access,accessing,19,/// LIS - Used for accessing register mask interference maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:4,Deployability,update,update,4,/// update - Recompute Blocks[MBBNum],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Performance,cache,cache,19,"// We don't keep a cache entry for every physical register, that would use too; // much memory. Instead, a fixed number of cache entries are used in a round-; // robin manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:123,Performance,cache,cache,123,"// We don't keep a cache entry for every physical register, that would use too; // much memory. Instead, a fixed number of cache entries are used in a round-; // robin manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:14,Performance,cache,cache,14,// The actual cache entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Performance,cache,cache,19,/// init - Prepare cache for a new function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:49,Performance,concurren,concurrent,49,/// getMaxCursors - Return the maximum number of concurrent cursors that can; /// be supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:31,Integrability,interface,interface,31,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:68,Performance,cache,cache,68,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:3,Deployability,Update,Update,3,"// Update reference counts. Nothing happens when RefCount reaches 0, so; // we don't have to check for E == CacheEntry etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:108,Performance,Cache,CacheEntry,108,"// Update reference counts. Nothing happens when RefCount reaches 0, so; // we don't have to check for E == CacheEntry etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:3,Deployability,Release,Release,3,// Release reference before getting a new one. That guarantees we can; // actually have CacheEntries live cursors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:88,Performance,Cache,CacheEntries,88,// Release reference before getting a new one. That guarantees we can; // actually have CacheEntries live cursors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:562,Performance,load,load,562,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1116,Performance,load,load,1116,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1151,Performance,load,load,1151,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1471,Performance,optimiz,optimized,1471,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1515,Performance,load,loads,1515,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1536,Performance,optimiz,optimized,1536,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1942,Performance,optimiz,optimized,1942,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:420,Security,Access,Access,420,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:473,Security,access,accesses,473,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:783,Security,access,accesses,783,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:29,Performance,load,load,29,/// Transform an interleaved load into target specific intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:16,Performance,load,load,16,/// Transform a load and a deinterleave intrinsic into target specific; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:47,Performance,load,load,47,"/// Returns true if the uses of an interleaved load by the; /// extractelement instructions in \p Extracts can be replaced by uses of the; /// shufflevector instructions in \p Shuffles instead. If so, the necessary; /// replacements are also performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:242,Performance,perform,performed,242,"/// Returns true if the uses of an interleaved load by the; /// extractelement instructions in \p Extracts can be replaced by uses of the; /// shufflevector instructions in \p Shuffles instead. If so, the necessary; /// replacements are also performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:162,Performance,load,load,162,"/// Given a number of shuffles of the form shuffle(binop(x,y)), convert them; /// to binop(shuffle(x), shuffle(y)) to allow the formation of an; /// interleaving load. Any newly created shuffles that operate on \p LI will; /// be added to \p Shuffles. Returns true, if any changes to the IR have been; /// made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask is a DE-interleave mask of the given factor; /// \p Factor like:; /// <Index, Index+Factor, ..., Index+(NumElts-1)*Factor>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:41,Availability,mask,mask,41,"/// Check if the mask is a DE-interleave mask of the given factor; /// \p Factor like:; /// <Index, Index+Factor, ..., Index+(NumElts-1)*Factor>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:41,Availability,mask,mask,41,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:100,Availability,mask,masks,100,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:148,Availability,mask,mask,148,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:209,Availability,mask,mask,209,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:65,Performance,load,load,65,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:32,Performance,load,load,32,// Make sure we don't produce a load wider than the input load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:58,Performance,load,load,58,// Make sure we don't produce a load wider than the input load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:128,Availability,mask,mask,128,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:473,Availability,mask,mask,473,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:30,Performance,load,load,30,"// Check if all users of this load are shufflevectors. If we encounter any; // users that are extractelement instructions or binary operators, we save; // them to later check if they can be modified to extract from one of the; // shufflevectors instead of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:260,Performance,load,load,260,"// Check if all users of this load are shufflevectors. If we encounter any; // users that are extractelement instructions or binary operators, we save; // them to later check if they can be modified to extract from one of the; // shufflevectors instead of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:102,Performance,load,load,102,// BinOpShuffles need to be handled a single time in case both operands of the; // binop are the same load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:31,Performance,load,load,31,// Try and modify users of the load that are extractelement instructions to; // use the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:130,Performance,load,load,130,// Try and modify users of the load that are extractelement instructions to; // use the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:59,Performance,load,load,59,// Try to create target specific intrinsics to replace the load and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:134,Performance,load,load,134,// Look for a suitable shufflevector instruction. The goal is to modify the; // extractelement instruction (which uses an interleaved load) to use one; // of the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:204,Performance,load,load,204,// Look for a suitable shufflevector instruction. The goal is to modify the; // extractelement instruction (which uses an interleaved load) to use one; // of the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:12,Performance,perform,perform,12,"// Finally, perform the replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:33,Performance,load,load,33,"// We now have a target-specific load, so delete the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,Performance,Load,Loads,56,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:431,Performance,load,load-combine,431,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:527,Performance,load,loads,527,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:589,Performance,load,load,589,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:644,Safety,detect,detectable,644,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:875,Safety,detect,detected,875,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:38,Performance,load,load,38,/// Scan the function for interleaved load candidates and execute the; /// replacement if applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:24,Performance,load,load,24,/// Replace interleaved load candidates. It does additional; /// analyses if this makes sense. Returns true on success and false; /// of nothing has been changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:138,Performance,load,load,138,"/// Given a set of VectorInfo containing candidates for a given interleave; /// factor, find a set that represents a 'factor' interleaved load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:192,Availability,error,error,192,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1431,Availability,error,error,1431,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:348,Performance,optimiz,optimization,348,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:370,Performance,load,loads,370,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:426,Performance,load,loads,426,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:539,Performance,load,loaded,539,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1012,Performance,load,load,1012,"mbine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1192,Performance,load,load,1192,"mbine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1276,Performance,load,loads,1276,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1282,Performance,load,load,1282,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:14,Availability,Error,Error,14,/// Number of Error Bits e,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:103,Availability,Error,Error,103,"// Note: Addition is associative in two's complement even when in case of; // signed overflow.; //; // Error bits can only propagate into higher significant bits. As these are; // already regarded as undefined, there is no change.; //; // Theorem: Adding a constant to a polynomial does not change the error; // term.; //; // Proof:; //; // Since the addition is associative and commutes:; //; // (B + A + E*2^(n-e)) + C = B + (A + C) + E*2^(n-e); // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:302,Availability,error,error,302,"// Note: Addition is associative in two's complement even when in case of; // signed overflow.; //; // Error bits can only propagate into higher significant bits. As these are; // already regarded as undefined, there is no change.; //; // Theorem: Adding a constant to a polynomial does not change the error; // term.; //; // Proof:; //; // Since the addition is associative and commutes:; //; // (B + A + E*2^(n-e)) + C = B + (A + C) + E*2^(n-e); // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:420,Availability,error,errors,420,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:553,Availability,error,errors,553,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:615,Availability,down,down,615,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1285,Availability,error,error,1285,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1447,Availability,error,error,1447,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1473,Availability,error,error,1473,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:12,Testability,log,logical,12,/// Apply a logical shift right on the polynomial,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:2640,Availability,error,error,2640,"+ E * 2^(n-e') =; //; // Compute Y by applying distributivity first; //; // Y = (B >> 1) + (A >> 1) + E*2^(n-e') =; // = (b_h * 2^(n-1) + b_m * 2 + b_l) >> 1 +; // + (a_h * 2^(n-1) + a_m * 2) >> 1 +; // + E * 2^(n-e) >> 1 =; //; // Again, the shift is computed by dividing the terms by 2 and by cutting; // off b_l.; //; // = b_h * 2^(n-2) + b_m +; // + a_h * 2^(n-2) + a_m +; // + E * 2^(n-(e+1)) =; //; // Again, the sum is built by putting the overflow of [a_m + b+n] into; // the term 2^(n-1). But this time there is room for a second bit in the; // term 2^(n-2) we add this bit to a new term and denote it o_h in a; // second step.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) tran",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3339,Availability,error,error,3339,"e there is room for a second bit in the; // term 2^(n-2) we add this bit to a new term and denote it o_h in a; // second step.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) transforms to (the pre-condition on A can also be; // dropped); //; // Theorem(2): (B + A + E) >> 1 => (B >> 1) + (A >> 1) + E'; // where; // A, B, E, E' are two's complement numbers with the same bit; // width; //; // Let A + B + E = X; // Let (B >> 1) + (A >> 1) = Y; //; // Therefore we need to show that for every X and Y there is an E' which; // makes the equation; //; // X = Y + E'; //; // hold. This is trivially the case for E' = X - Y.; //; // [qed]; //; // Remark: Distributing lshr with and arbitrary n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4201,Availability,error,error,4201,"+ a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) transforms to (the pre-condition on A can also be; // dropped); //; // Theorem(2): (B + A + E) >> 1 => (B >> 1) + (A >> 1) + E'; // where; // A, B, E, E' are two's complement numbers with the same bit; // width; //; // Let A + B + E = X; // Let (B >> 1) + (A >> 1) = Y; //; // Therefore we need to show that for every X and Y there is an E' which; // makes the equation; //; // X = Y + E'; //; // hold. This is trivially the case for E' = X - Y.; //; // [qed]; //; // Remark: Distributing lshr with and arbitrary number n can be expressed as; // ((((B + A) lshr 1) lshr 1) ... ) {n times}.; // This construction induces n additional error bits at the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:312,Testability,log,logical,312,"// Theorem(1): (B + A + E*2^(n-e)) >> 1 => (B >> 1) + (A >> 1) + E'*2^(n-e'); // where; // e' = e + 1,; // E is a e-bit number,; // E' is a e'-bit number,; // holds under the following precondition:; // pre(1): A % 2 = 0; // pre(2): e < n, (see Theorem(2) for the trivial case with e=n); // where >> expresses a logical shift to the right, with adding zeros.; //; // We need to show that for every, E there is a E'; //; // B = b_h * 2^(n-1) + b_m * 2 + b_l; // A = a_h * 2^(n-1) + a_m * 2 (pre(1)); //; // where a_h, b_h, b_l are single bits, and a_m, b_m are (n-2) bit numbers; //; // Let X = (B + A + E*2^(n-e)) >> 1; // Let Y = (B >> 1) + (A >> 1) + E*2^(n-e) >> 1; //; // X = [B + A + E*2^(n-e)] >> 1 =; // = [ b_h * 2^(n-1) + b_m * 2 + b_l +; // + a_h * 2^(n-1) + a_m * 2 +; // + E * 2^(n-e) ] >> 1 =; //; // The sum is built by putting the overflow of [a_m + b+n] into the term; // 2^(n-1). As there are no more bits beyond 2^(n-1) the overflow within; // this bit is discarded. This is expressed by % 2.; //; // The bit in position 0 cannot overflow into the term (b_m + a_m).; //; // = [ ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-1) +; // + ((b_m + a_m) % 2^(n-2)) * 2 +; // + b_l + E * 2^(n-e) ] >> 1 =; //; // The shift is computed by dividing the terms by 2 and by cutting off; // b_l.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // by the definition in the Theorem e+1 = e'; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Compute Y by applying distributivity first; //; // Y = (B >> 1) + (A >> 1) + E*2^(n-e') =; // = (b_h * 2^(n-1) + b_m * 2 + b_l) >> 1 +; // + (a_h * 2^(n-1) + a_m * 2) >> 1 +; // + E * 2^(n-e) >> 1 =; //; // Again, the shift is computed by dividing the terms by 2 and by cutting; // off b_l.; //; // = b_h * 2^(n-2) + b_m +; // + a_h * 2^(n-2) + a_m +; // + E * 2^(n-(e+1)) =; //; // Again, the sum is buil",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,// Test if the result will be zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:162,Availability,error,error,162,// The proof that shiftAmt LSBs are zero for at least one summand is only; // possible for the constant number.; //; // If this can be proven add shiftAmt to the error counter; // `ErrorMSBs`. Otherwise set all bits as undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:181,Availability,Error,ErrorMSBs,181,// The proof that shiftAmt LSBs are zero for at least one summand is only; // possible for the constant number.; //; // If this can be proven add shiftAmt to the error counter; // `ErrorMSBs`. Otherwise set all bits as undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:17,Modifiability,extend,extend,17,/// Apply a sign-extend or truncate operation on the polynomial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:13,Usability,Clear,Clearly,13,// Truncate: Clearly undefined Bits on the MSB side are removed; // if there are any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Modifiability,Extend,Extend,3,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:19,Modifiability,extend,extending,19,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:89,Modifiability,extend,extending,89,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:112,Modifiability,extend,extended,112,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:11,Usability,Clear,Clearly,11,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test if there is a coefficient B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test coefficient B of two Polynomials are equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:13,Modifiability,variab,variable,13,// The index variable is different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:33,Testability,test,test,33,// Subtract both polynomials and test if it is fully defined and zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:119,Performance,load,loaded,119,"/// VectorInfo stores abstract the following information for each vector; /// element:; ///; /// 1) The memory address loaded into the element as Polynomial; /// 2) a set of load instruction necessary to construct the vector,; /// 3) a set of all other instructions that are necessary to create the vector and; /// 4) a pointer value that can be used as relative base for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:174,Performance,load,load,174,"/// VectorInfo stores abstract the following information for each vector; /// element:; ///; /// 1) The memory address loaded into the element as Polynomial; /// 2) a set of load instruction necessary to construct the vector,; /// 3) a set of all other instructions that are necessary to create the vector and; /// 4) a pointer value that can be used as relative base for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:8,Performance,Load,Load,8,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:33,Performance,Load,Load,33,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:87,Performance,load,load,87,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,load,load,20,/// Basic-block the load instructions are within,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:39,Performance,load,load,39,/// Pointer value of all participation load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:18,Performance,load,load,18,/// Participating load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:57,Performance,load,load,57,/// Test if the VectorInfo can be part of an interleaved load with the; /// specified factor.; ///; /// \param Factor of the interleave; /// \param DL Targets Datalayout; ///; /// \returns true if this is possible and false if not,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test if the VectorInfo can be part of an interleaved load with the; /// specified factor.; ///; /// \param Factor of the interleave; /// \param DL Targets Datalayout; ///; /// \returns true if this is possible and false if not,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:363,Performance,load,loads,363,/// ShuffleVectorInst specialization to compute vector information.; ///; /// \param SVI ShuffleVectorInst to operate on; /// \param Result Result of the computation; ///; /// Compute the left and the right side vector information and merge them by; /// applying the shuffle operation. This function also ensures that the left; /// and right side have compatible loads. This means that all loads are with; /// in the same basic block and are based on the same pointer.; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:390,Performance,load,loads,390,/// ShuffleVectorInst specialization to compute vector information.; ///; /// \param SVI ShuffleVectorInst to operate on; /// \param Result Result of the computation; ///; /// Compute the left and the right side vector information and merge them by; /// applying the shuffle operation. This function also ensures that the left; /// and right side have compatible loads. This means that all loads are with; /// in the same basic block and are based on the same pointer.; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Performance,Load,LoadInst,4,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:150,Performance,Load,LoadInst,150,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:96,Safety,abort,abort,96,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:69,Modifiability,variab,variable,69,"// Compute base offset from zero based index, excluding the last; // variable operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:30,Performance,load,load,30,// Try to find an interleaved load using the front of Worklist as first line,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:30,Performance,Load,LoadInst,30,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:45,Performance,load,loads,45,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:129,Performance,load,load,129,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:87,Testability,test,tests,87,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,// Test if the offset is computed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:25,Performance,load,load,25,// Generate a set of all load instructions to be combined,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:53,Performance,load,load,53,// Generate a set of all instructions taking part in load; // interleaved. This list excludes the instructions necessary for the; // polynomial construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:121,Performance,perform,performance,121,"// Test if all participating instruction will be dead after the; // transformation. If intermediate results are used, no performance gain can; // be expected. Also sum the cost of the Instructions beeing left dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,"// Test if all participating instruction will be dead after the; // transformation. If intermediate results are used, no performance gain can; // be expected. Also sum the cost of the Instructions beeing left dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:59,Safety,abort,abort,59,"// If there are users outside the set to be eliminated, we abort the; // transformation. No gain can be expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,Load,LoadInst,20,// We know that all LoadInst are within the same BB. This guarantees that; // either everything or nothing is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:110,Performance,load,loaded,110,// We know that all LoadInst are within the same BB. This guarantees that; // either everything or nothing is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:23,Performance,load,loads,23,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:63,Performance,load,loads,63,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:210,Performance,load,loads,210,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:9,Safety,safe,safe,9,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:114,Security,access,access,114,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:73,Testability,test,test,73,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:41,Safety,detect,detectable,41,// All checks are done. Add instructions detectable by InterleavedAccessPass; // The old instruction will are left dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:28,Deployability,update,update,28,// Create the wide load and update the MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:19,Performance,load,load,19,// Create the wide load and update the MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:36,Safety,avoid,avoid,36,// Start with the highest factor to avoid combining and recombining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,scalab,scalable,20,// We don't support scalable vectors in this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:47,Performance,Load,Load,47,// Remove the first element of the Interleaved Load but put the others; // back on the list and continue searching,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:35,Performance,load,loads,35,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,Safety,detect,detectable,56,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out prefetches on unsupported architectures,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out pcmarker on unsupported architectures,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out debugging intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the amount to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:20,Usability,simpl,simple,20,// Verify this is a simple bswap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:658,Availability,error,error,658,"//===- JMCInstrumenter.cpp - JMC Instrumentation --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // JMCInstrumenter pass:; // - instrument each function with a call to __CheckForDebuggerJustMyCode. The; // sole argument should be defined in .msvcjmc. Each flag is 1 byte initilized; // to 1.; // - create the dummy COMDAT function __JustMyCode_Default to prevent linking; // error if __CheckForDebuggerJustMyCode is not available.; // - For MSVC:; // add ""/alternatename:__CheckForDebuggerJustMyCode=__JustMyCode_Default"" to; // ""llvm.linker.options""; // For ELF:; // Rename __JustMyCode_Default to __CheckForDebuggerJustMyCode and mark it as; // weak symbol.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:703,Availability,avail,available,703,"//===- JMCInstrumenter.cpp - JMC Instrumentation --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // JMCInstrumenter pass:; // - instrument each function with a call to __CheckForDebuggerJustMyCode. The; // sole argument should be defined in .msvcjmc. Each flag is 1 byte initilized; // to 1.; // - create the dummy COMDAT function __JustMyCode_Default to prevent linking; // error if __CheckForDebuggerJustMyCode is not available.; // - For MSVC:; // add ""/alternatename:__CheckForDebuggerJustMyCode=__JustMyCode_Default"" to; // ""llvm.linker.options""; // For ELF:; // Rename __JustMyCode_Default to __CheckForDebuggerJustMyCode and mark it as; // weak symbol.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:250,Security,hash,hash,250,"// Best effort path normalization. This is to guarantee an unique flag symbol; // is produced for the same directory. Some builds may want to use relative; // paths, or paths with a specific prefix (see the -fdebug-compilation-dir; // flag), so only hash paths in debuginfo. Don't expand them to absolute; // paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:49,Security,hash,hash,49,// The naming convention for the flag name is __<hash>_<file name> with '.' in; // <file name> replaced with '@'. For example C:\file.any.c would have a flag; // __D032E919_file@any@c. The naming convention match MSVC's format however; // the match is not required to make JMC work. The hashing function used here; // is different from MSVC's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:287,Security,hash,hashing,287,// The naming convention for the flag name is __<hash>_<file name> with '.' in; // <file name> replaced with '@'. For example C:\file.any.c would have a flag; // __D032E919_file@any@c. The naming convention match MSVC's format however; // the match is not required to make JMC work. The hashing function used here; // is different from MSVC's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:38,Energy Efficiency,schedul,scheduling,38,"// FIXME: it would be nice to make CI scheduling boundary, although in; // practice it does not matter much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:52,Security,Integrity,Integrity,52,"//===---- KCFI.cpp - Implements Kernel Control-Flow Integrity (KCFI) ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements Kernel Control-Flow Integrity (KCFI) indirect call; // check lowering. For each call instruction with a cfi-type attribute, it; // emits an arch-specific check before the call, and bundles the check and; // the call to prevent unintentional modifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:424,Security,Integrity,Integrity,424,"//===---- KCFI.cpp - Implements Kernel Control-Flow Integrity (KCFI) ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements Kernel Control-Flow Integrity (KCFI) indirect call; // check lowering. For each call instruction with a cfi-type attribute, it; // emits an arch-specific check before the call, and bundles the check and; // the call to prevent unintentional modifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:64,Safety,safe,safely,64,"// If the call instruction is bundled, we can only emit a check safely if; // it's the first instruction in the bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:3,Usability,Clear,Clear,3,// Clear the original call's CFI type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:451,Energy Efficiency,Schedul,SchedulingPriorityQueue,451,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:480,Energy Efficiency,schedul,schedules,480,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:523,Energy Efficiency,reduce,reduce,523,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:10,Performance,Latency,LatencyPriorityQueue,10,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:39,Performance,latency,latency-oriented,39,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:65,Performance,queue,queue,65,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:408,Performance,Latency,LatencyPriorityQueue,408,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:496,Performance,latency,latency,496,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:176,Availability,down,down,176,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:133,Energy Efficiency,schedul,scheduled,133,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:181,Energy Efficiency,schedul,schedule,181,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:45,Integrability,wrap,wraparound,45,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:56,Integrability,depend,dependencies,56,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:35,Energy Efficiency,schedul,scheduling,35,// The most important heuristic is scheduling the critical path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, predecessor. If it's the; // only one we have found, keep track of it... otherwise give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, predecessor. If it's the; // only one we have found, keep track of it... otherwise give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:240,Availability,avail,available,240,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:3,Energy Efficiency,schedul,scheduledNode,3,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:32,Energy Efficiency,schedul,scheduled,32,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:203,Energy Efficiency,schedul,scheduling,203,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:114,Availability,avail,available,114,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:339,Availability,avail,available,339,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:439,Availability,avail,available,439,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:83,Energy Efficiency,schedul,scheduled,83,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:192,Energy Efficiency,schedul,scheduled,192,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:309,Energy Efficiency,schedul,scheduled,309,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:13,Energy Efficiency,schedul,scheduled,13,// All preds scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:47,Availability,avail,available,47,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:93,Availability,avail,available,93,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:66,Energy Efficiency,schedul,scheduled,66,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:131,Performance,queue,queue,131,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:39,Performance,queue,queue,39,"// Reinsert the node into the priority queue, which recomputes its; // NumNodesSolelyBlocking value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:85,Availability,avail,available,85,/// getOrCreateLexicalScope - Find lexical scope for the given DebugLoc. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:178,Performance,Cache,Cache,178,"// Fetch all the blocks in DLs scope. Because the range / block list also; // contain any subscopes, any instruction that DL dominates can be found in; // the block set.; //; // Cache the set of fetched blocks to avoid repeatedly recomputing the set in; // the LiveDebugValues pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:213,Safety,avoid,avoid,213,"// Fetch all the blocks in DLs scope. Because the range / block list also; // contain any subscopes, any instruction that DL dominates can be found in; // the block set.; //; // Cache the set of fetched blocks to avoid repeatedly recomputing the set in; // the LiveDebugValues pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:683,Deployability,update,updated,683,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:52,Modifiability,variab,variables,52,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:577,Modifiability,variab,variables,577,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:22,Modifiability,variab,variable,22,/// Describes a debug variable value by location number and expression along; /// with some flags about the original usage of the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:107,Performance,perform,performance,107,"// FIXME: Debug values referencing 64+ unique machine locations are rare and; // currently unsupported for performance reasons. If we can verify that; // performance is acceptable for such debug values, we can increase the; // bit-width of LocNoCount to 14 to enable up to 16384 unique machine; // locations. We will also need to verify that this does not cause issues; // with LiveDebugVariables' use of IntervalMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:154,Performance,perform,performance,154,"// FIXME: Debug values referencing 64+ unique machine locations are rare and; // currently unsupported for performance reasons. If we can verify that; // performance is acceptable for such debug values, we can increase the; // bit-width of LocNoCount to 14 to enable up to 16384 unique machine; // locations. We will also need to verify that this does not cause issues; // with LiveDebugVariables' use of IntervalMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:60,Usability,simpl,simplest,60,"// Turn this into an undef debug value list; right now, the simplest form; // of this is an expression with one arg, and an undef debug operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:174,Integrability,wrap,wrapper,174,"// IntervalMap requires the value object to be very small, to the extent; // that we do not have enough room for an std::vector. Using a C-style array; // (with a unique_ptr wrapper for convenience) allows us to optimize for this; // specific case by packing the array size into only 6 bits (it is highly; // unlikely that any debug value will need 64+ locations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:212,Performance,optimiz,optimize,212,"// IntervalMap requires the value object to be very small, to the extent; // that we do not have enough room for an std::vector. Using a C-style array; // (with a unique_ptr wrapper for convenience) allows us to optimize for this; // specific case by packing the array size into only 6 bits (it is highly; // unlikely that any debug value will need 64+ locations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Performance,Cache,Cache,4,/// Cache to save the location where it can be used as the starting; /// position as input for calling MachineBasicBlock::SkipPHIsLabelsAndDebug.; /// This is to prevent MachineBasicBlock::SkipPHIsLabelsAndDebug from; /// repeatedly searching the same set of PHIs/Labels/Debug instructions; /// if it is called many times for the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:48,Modifiability,variab,variable,48,/// A user value is a part of a debug info user variable.; ///; /// A DBG_VALUE instruction notes that (a sub-register of) a virtual register; /// holds part of a user variable. The part is identified by a byte offset.; ///; /// UserValues are grouped into equivalence classes for easier searching. Two; /// user values are related if they are held by the same virtual register. The; /// equivalence class is the transitive closure of that relation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:168,Modifiability,variab,variable,168,/// A user value is a part of a debug info user variable.; ///; /// A DBG_VALUE instruction notes that (a sub-register of) a virtual register; /// holds part of a user variable. The part is identified by a byte offset.; ///; /// UserValues are grouped into equivalence classes for easier searching. Two; /// user values are related if they are held by the same virtual register. The; /// equivalence class is the transitive closure of that relation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:20,Modifiability,variab,variable,20,///< The debug info variable we are part of.; /// The part of the variable we describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:66,Modifiability,variab,variable,66,///< The debug info variable we are part of.; /// The part of the variable we describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:32,Modifiability,variab,variable,32,///< The debug location for the variable. This is; ///< used by dwarf writer to find lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:53,Availability,down,down,53,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Modifiability,Extend,Extend,4,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:275,Performance,perform,performs,275,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:94,Availability,avail,available,94,"/// The value in LI may be copies to other registers. Determine if; /// any of the copies are available at the kill points, and add defs if; /// possible.; ///; /// \param DbgValue Location number of LI->reg, and DIExpression.; /// \param LocIntervals Scan for copies of the value for each location in the; /// corresponding LiveInterval->reg.; /// \param KilledAt The point where the range of DbgValue could be extended.; /// \param [in,out] NewDefs Append (Idx, DbgValue) of inserted defs here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:412,Modifiability,extend,extended,412,"/// The value in LI may be copies to other registers. Determine if; /// any of the copies are available at the kill points, and add defs if; /// possible.; ///; /// \param DbgValue Location number of LI->reg, and DIExpression.; /// \param LocIntervals Scan for copies of the value for each location in the; /// corresponding LiveInterval->reg.; /// \param KilledAt The point where the range of DbgValue could be extended.; /// \param [in,out] NewDefs Append (Idx, DbgValue) of inserted defs here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite virtual register locations according to the provided virtual; /// register map. Record the stack slot offsets for the locations that; /// were spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,Energy Efficiency,allocate,allocated,8,/// All allocated UserValue instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,Energy Efficiency,allocate,allocated,8,/// All allocated UserLabel instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:155,Deployability,update,updated,155,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:10,Modifiability,variab,variable,10,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:359,Safety,avoid,avoid,359,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Deployability,Release,Release,4,/// Release all memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:26,Modifiability,variab,variable,26,"// DBG_VALUE loc, offset, variable, expr; // DBG_VALUE_LIST variable, expr, locs...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:60,Modifiability,variab,variable,60,"// DBG_VALUE loc, offset, variable, expr; // DBG_VALUE_LIST variable, expr, locs...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Safety,Detect,Detect,3,"// Detect invalid DBG_VALUE instructions, with a debug-use of a virtual; // register that hasn't been defined yet. If we do not remove those here, then; // the re-insertion of the DBG_VALUE instruction after register allocation; // will be incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:36,Modifiability,variab,variable,36,"// Get or create the UserValue for (variable,offset) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:56,Modifiability,extend,extended,56,// Stop when meeting a different location or an already extended interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:39,Availability,avail,available,39,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Usability,Clear,Clear,3,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:39,Availability,avail,available,39,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Usability,Clear,Clear,3,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:16,Modifiability,extend,extended,16,"// Is the value extended to reach this copy? If not, another def may be; // blocking it, or we are looking at a wrong value of LI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:76,Modifiability,extend,extend,76,"// If there are any killed locations we can't find a copy for, we can't; // extend the variable value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:87,Modifiability,variab,variable,87,"// If there are any killed locations we can't find a copy for, we can't; // extend the variable value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:26,Modifiability,extend,extended,26,// Collect all defs to be extended (Skipping undefs).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Extend,Extend,3,"// Extend all defs, and possibly add new ones along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:480,Usability,simpl,simply,480,"// FIXME: Handle sub-registers in addDefsFromCopies. The problem is that; // if the original location for example is %vreg0:sub_hi, and we find a; // full register copy in addDefsFromCopies (at the moment it only; // handles full register copies), then we must add the sub1 sub-register; // index to the new location. However, that is only possible if the new; // virtual register is of the same regclass (or if there is an; // equivalent sub-register in that regclass). For now, simply skip; // handling copies if a sub-register is involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:210,Modifiability,extend,extend,210,"// For physregs, we only mark the start slot idx. DwarfDebug will see it; // as if the DBG_VALUE is valid up until the end of the basic block, or; // the next def of the physical register. So we do not need to extend the; // range. It might actually happen that the DBG_VALUE is the last use of; // the physical register (e.g. if this is an unused input argument to a; // function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:30,Modifiability,extend,extend,30,"// The computed intervals may extend beyond the range of the debug; // location's lexical scope. In this case, splitting of an interval; // can result in an interval outside of the scope being created,; // causing extra unnecessary DBG_VALUEs to be emitted. To prevent; // this, trim the intervals to the lexical scope in the case of inlined; // variables, since heavy inlining may cause production of dramatically big; // number of DBG_VALUEs to be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:346,Modifiability,variab,variables,346,"// The computed intervals may extend beyond the range of the debug; // location's lexical scope. In this case, splitting of an interval; // can result in an interval outside of the scope being created,; // causing extra unnecessary DBG_VALUEs to be emitted. To prevent; // this, trim the intervals to the lexical scope in the case of inlined; // variables, since heavy inlining may cause production of dramatically big; // number of DBG_VALUEs to be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Variab,Variable,3,"// Variable locations at the first instruction of a block should be; // based on the block's SlotIndex, not the first instruction's index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:31,Modifiability,variab,variable,31,// Have we been asked to track variable locations using instruction; // referencing?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:9,Energy Efficiency,allocate,allocate,9,// Don't allocate the new LocNo until it is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:33,Energy Efficiency,Allocate,Allocate,33,// Overlapping correct location. Allocate NewLocNo now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:16,Availability,down,down,16,// Trim LocMapI down to the LII overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:247,Modifiability,rewrite,rewriteLocations,247,"// Finally, remove OldLocNo unless it is still used by some interval in the; // locInts map. One case when OldLocNo still is in use is when the register; // has been spilled. In such situations the spilled register is kept as a; // location until rewriteLocations is called (VirtRegMap is mapping the old; // register to the spill slot). So for a while we can have locations that map; // to virtual registers that have been removed from both the MachineFunction; // and from LiveIntervals.; //; // We may also just be using the location for a value with a different; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:83,Safety,safe,safely,83,// Split locations referring to OldReg. Iterate backwards so splitLocation can; // safely erase unused locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:241,Performance,optimiz,optimized,241,"// If we do not find a new register covering this PHI, then register; // allocation has dropped its location, for example because it's not live.; // The old VReg will not be mapped to a physreg, and the instruction; // number will have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:478,Modifiability,variab,variables,478,"// Build a set of new locations with new numbers so we can coalesce our; // IntervalMap if two vreg intervals collapse to the same physical location.; // Use MapVector instead of SetVector because MapVector::insert returns the; // position of the previously or newly inserted element. The boolean value; // tracks if the location was produced by a spill.; // FIXME: This will be problematic if we ever support direct and indirect; // frame index locations, i.e. expressing both variables in memory and; // 'int x, *px = &x'. The ""spilled"" bit must become part of the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:95,Availability,avail,available,95,"// This can create a %noreg operand in rare cases when the sub-register; // index is no longer available. That means the user value is in a; // non-existent sub-register, and %noreg is exactly what we want.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the locations and record the stack slot offsets for spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Deployability,Update,Update,3,"// Update the interval map, but only coalesce left, since intervals to the; // right use the old location numbers. This should merge two contiguous; // DBG_VALUE intervals with different vregs that were allocated to the same; // physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:203,Energy Efficiency,allocate,allocated,203,"// Update the interval map, but only coalesce left, since intervals to the; // right use the old location numbers. This should merge two contiguous; // DBG_VALUE intervals with different vregs that were allocated to the same; // physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Testability,Test,Test,3,"// Test whether this location is legal with the given subreg. If the; // subregister has a nonzero offset, drop this location, it's too complex; // to describe. (TODO: future work).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:94,Modifiability,variab,variables,94,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:48,Performance,optimiz,optimized,48,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:133,Performance,optimiz,optimized,133,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:89,Safety,safe,safe,89,"// We have reached the end of the block and didn't find anywhere to; // insert! It's not safe to discard any debug instructions; place them; // in front of the first terminator, or in front of end().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:593,Deployability,update,updated,593,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:406,Integrability,interface,interface,406,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:50,Modifiability,variab,variables,50,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:551,Modifiability,variab,variables,551,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:747,Modifiability,variab,variables,747,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:34,Modifiability,variab,variables,34,/// splitRegister - Move any user variables in OldReg to the live ranges in; /// NewRegs where they are live. Mark the values as unavailable where no new; /// register is live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:481,Safety,avoid,avoid,481,"//===----------------------------------------------------------------------===//; // Implementation of various methods necessary for calculation of live ranges.; // The implementation of the methods abstracts from the concrete type of the; // segment collection.; //; // Implementation of the class follows the Template design pattern. The base; // class contains generic algorithms that call collection-specific methods,; // which are provided in concrete subclasses. In order to avoid virtual calls; // these methods are provided by means of C++ template instantiation.; // The base class calls the methods of the subclass through method impl(),; // which casts 'this' pointer to the type of the subclass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:196,Energy Efficiency,allocate,allocated,196,"/// A counterpart of LiveRange::createDeadDef: Make sure the range has a; /// value defined at @p Def.; /// If @p ForVNI is null, and there is no value defined at @p Def, a new; /// value will be allocated using @p VNInfoAllocator.; /// If @p ForVNI is null, the return value is the value defined at @p Def,; /// either a pre-existing one, or the one newly created.; /// If @p ForVNI is not null, then @p Def should be the location where; /// @p ForVNI is defined. If the range does not have a value defined at; /// @p Def, the value @p ForVNI will be used instead of allocating a new; /// one. If the range already has a value defined at @p Def, it must be; /// same as @p ForVNI. In either case, @p ForVNI will be the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:40,Modifiability,extend,extend,40,"/// This method is used when we want to extend the segment specified; /// by I to end at the specified endpoint. To do this, we should; /// merge and eliminate all segments that this will overlap; /// with. The iterator is not invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:40,Modifiability,extend,extend,40,"/// This method is used when we want to extend the segment specified; /// by I to start at the specified endpoint. To do this, we should; /// merge and eliminate all segments that this will overlap with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:77,Modifiability,extend,extend,77,"// If we start in the middle of another segment, just delete a range and; // extend that segment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:14,Modifiability,extend,extend,14,"// Otherwise, extend the segment right after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:97,Modifiability,extend,extend,97,"// If the inserted segment starts in the middle or right at the end of; // another segment, just extend that segment to contain the segment of S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:24,Safety,abort,abort,24,// Get next segment and abort if it was not adjacent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:82,Safety,avoid,avoid,82,"// Determine if any of our values are mapped. This is uncommon, so we want; // to avoid the range scan if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:63,Modifiability,rewrite,rewrite,63,"// If we have to apply a mapping to our base range assignment, rewrite it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite Other values before changing the VNInfo ids.; // This can leave Other in an invalid state because we're not coalescing; // touching segments that now have identical values. That's OK since Other is; // not supposed to be valid after calling join();,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Deployability,Update,Update,3,// Update val# info. Renumber them and make sure they all belong to this; // LiveRange now. Also remove dead val#'s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:108,Modifiability,extend,extend,108,"// Not a V1 Segment.; // Okay, we found a V1 live range. If it had a previous, touching, V2 live; // range, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:14,Energy Efficiency,allocate,allocated,14,// Memory was allocated with BumpPtr allocator and is not freed here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:84,Availability,mask,mask,84,"/// For each VNI in \p SR, check whether or not that value defines part; /// of the mask describe by \p LaneMask and if not, remove that value; /// from \p SR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:70,Testability,assert,assert,70,"// If the subrange is empty at this point, the MIR is invalid. Do not assert; // and let the verifier catch this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:76,Energy Efficiency,Reduce,Reduce,76,// We have to split the subrange into a matching and non-matching part.; // Reduce lanemask of existing lane to non-matching part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:65,Availability,mask,masks,65,// Subrange lanemask should be disjunct to any previous subrange masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:12,Availability,mask,mask,12,// subrange mask should not contained in maximum lane mask for the vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:54,Availability,mask,mask,54,// subrange mask should not contained in maximum lane mask for the vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Performance,Perform,Perform,3,// Perform a backwards merge of Spills and [SpillI;WriteI).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Usability,Clear,Clear,3,// Clear the dirty state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:11,Modifiability,Extend,Extend,11,"// Step 2: Extend live segments to all uses, constructing SSA form as; // necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:3,Usability,Clear,Clear,3,// Clear all kill flags. They will be reinserted after register allocation; // by LiveIntervals::addKillFlags().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:116,Modifiability,extend,extend,116,"// MI is reading Reg. We may have visited MI before if it happens to be; // reading Reg multiple times. That is OK, extend() is idempotent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Deployability,Release,Release,3,"// Release VNInfo memory regions, VNInfo objects don't need to be dtor'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for all virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:14,Testability,test,testing,14,"// For stress testing, precompute live ranges of all physical register; // units, including reserved registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:50,Availability,mask,masks,50,"// Some block starts, such as EH funclets, create masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:52,Availability,mask,masks,52,"// Some block ends, such as funclet returns, create masks. Put the mask on; // the last instruction of the block, because MBB slot index intervals are; // half-open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:67,Availability,mask,mask,67,"// Some block ends, such as funclet returns, create masks. Put the mask on; // the last instruction of the block, because MBB slot index intervals are; // half-open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:34,Availability,mask,mask,34,// Compute the number of register mask instructions in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:113,Modifiability,extend,extending,113,"// The physregs aliasing Unit are the roots and their super-registers.; // Create all values as dead defs before extending to uses. Note that roots; // may share super-registers. That's OK because createDeadDefs() is; // idempotent. It is very rare for a register unit to have multiple roots, so; // uniquing super-registers is probably not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:7,Modifiability,extend,extend,7,// Now extend LR to reach all uses.; // Ignore uses of reserved registers. We only track defs of those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:37,Energy Efficiency,allocate,allocated,37,// Keep track of the live range sets allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend intervals to reach all uses in WorkList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend the live range for VNI to be live at Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:23,Energy Efficiency,allocate,allocated,23,// Target may have not allocated this yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:13,Availability,mask,mask,13,// Compute a mask of lanes that are defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:94,Availability,mask,mask,94,//===----------------------------------------------------------------------===//; // Register mask functions; //===----------------------------------------------------------------------===//; /// Check whether use of reg in MI is live-through. Live-through means that; /// the value is alive on exit from Machine instruction. The example of such; /// use is a deopt value in statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:286,Availability,alive,alive,286,//===----------------------------------------------------------------------===//; // Register mask functions; //===----------------------------------------------------------------------===//; /// Check whether use of reg in MI is live-through. Live-through means that; /// the value is alive on exit from Machine instruction. The example of such; /// use is a deopt value in statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:46,Availability,mask,mask,46,// We are going to enumerate all the register mask slots contained in LI.; // Start with a binary search of RegMaskSlots to find a starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:41,Usability,Usab,UsableRegs,41,// This is the first overlap. Initialize UsableRegs to all ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:45,Availability,mask,mask,45,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:10,Usability,usab,usable,10,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:31,Availability,mask,mask,31,// *SlotI overlaps LI. Collect mask bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:232,Modifiability,extend,extend,232,//===----------------------------------------------------------------------===//; // IntervalUpdate class.; //===----------------------------------------------------------------------===//; /// Toolkit used by handleMove to trim or extend live intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:10,Deployability,Update,UpdateFlags,10,"// FIXME: UpdateFlags is a workaround that creates live intervals for all; // physregs, even those that aren't needed for regalloc, in order to update; // kill flags. This is wasteful. Eventually, LiveVariables will strip all kill; // flags, and postRA passes will use a live register utility instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:144,Deployability,update,update,144,"// FIXME: UpdateFlags is a workaround that creates live intervals for all; // physregs, even those that aren't needed for regalloc, in order to update; // kill flags. This is wasteful. Eventually, LiveVariables will strip all kill; // flags, and postRA passes will use a live register utility instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,"/// Update all live ranges touched by MI, assuming a move from OldIdx to; /// NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:16,Usability,clear,clear,16,// Aggressively clear all kill flags.; // They are reinserted by VirtRegRewriter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:81,Deployability,update,updateRange,81,"// If main range has a hole and we are moving a subrange use across; // the hole updateRange() cannot properly handle it since it only; // gets the LiveRange and not the whole LiveInterval. As a result; // we may end up with a main range not covering all subranges.; // This is extremely rare case, so let's check and reconstruct the; // main range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:22,Deployability,update,update,22,"// For physregs, only update the regunits that actually have a; // precomputed live range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,"/// Update a single live range, assuming an instruction has been moved from; /// OldIdx to NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:55,Availability,down,downwards,55,/// Update LR to reflect an instruction has been moved downwards from OldIdx; /// to NewIdx (OldIdx < NewIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,/// Update LR to reflect an instruction has been moved downwards from OldIdx; /// to NewIdx (OldIdx < NewIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:32,Modifiability,extend,extends,32,"// If the live-in value already extends to NewIdx, there is nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:96,Modifiability,extend,extends,96,// If we are here then OldIdx was just a use but not a def. We only have; // to ensure liveness extends to NewIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend the segment before NewIdx if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend OldIdxIn.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:24,Modifiability,extend,extends,24,"// If the defined value extends beyond NewIdx, just move the beginning; // of the segment to NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:41,Modifiability,extend,extend,41,"// If NewIdx is behind the last segment, extend that and append a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,/// Update LR to reflect an instruction has been moved upwards from OldIdx; /// to NewIdx (NewIdx < OldIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Usability,Simpl,Simply,3,// Simply remove the dead def at OldIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:140,Modifiability,Extend,Extend,140,"// If the segment before OldIdx read a value defined earlier than; // NewIdx, the moved instruction also reads and forwards that; // value. Extend the lifetime of the new def point.; // Extend to where the previous range started, unless there is; // another redef first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:186,Modifiability,Extend,Extend,186,"// If the segment before OldIdx read a value defined earlier than; // NewIdx, the moved instruction also reads and forwards that; // value. Extend the lifetime of the new def point.; // Extend to where the previous range started, unless there is; // another redef first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:97,Availability,down,down,97,"// OldIdxIn and OldIdxVNI are now undef and can be overridden.; // We Slide [NewIdxIn, OldIdxIn) down one position.; // |- X0/NewIdxIn -| ... |- Xn-1 -||- Xn/OldIdxIn -||- OldIdxOut -|; // => |- undef/NexIdxIn -| |- X0 -| ... |- Xn-1 -| |- Xn/OldIdxOut -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:339,Availability,down,down,339,"// OldIdxVNI is a dead def that has been moved into the middle of; // another value in LR. That can happen when LR is a whole register,; // but the dead def is a write to a subreg that is dead at NewIdx.; // The dead def may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- X0/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:149,Availability,down,down,149,"// OldIdxVNI is a dead def. It may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- undef/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:107,Availability,repair,repair,107,// FIXME: This doesn't currently handle early-clobber or multiple removed; // defs inside of the region to repair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:19,Availability,repair,repair,19,// Don't bother to repair a freshly calculated live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp:3,Safety,Detect,Detect,3,"// Detect overlap, handle above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:78,Availability,mask,mask,78,/// Remove all registers from the set that get clobbered by the register; /// mask.; /// The clobbers set will be the list of live registers clobbered; /// by the regmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:153,Integrability,depend,depends,153,"/// Simulates liveness when stepping forward over an instruction(bundle): Remove; /// killed-uses, add defs. This is the not recommended way, because it depends; /// on accurate kill flags. If possible use stepBackward() instead of this; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:27,Usability,simpl,simply,27,// To get the live-outs we simply merge the live-ins of all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:30,Deployability,update,update,30,"// The value is live-through, update LiveOut as well.; // Defer the Domtree lookup until it is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:41,Modifiability,extend,extend,41,// Is there a def in the same MBB we can extend?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:176,Performance,Perform,Perform,176,"// Find the single reaching def, or determine if Use is jointly dominated by; // multiple values, and we may need to create even more phi-defs to preserve; // VNInfo SSA form. Perform a search for all predecessor blocks where we; // know the dominating VNInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:150,Availability,avail,available,150,"// This function is called by a client after using the low-level API to add; // live-out and live-in blocks. The unique value optimization is not; // available, SplitEditor::transferValues handles that case directly anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:126,Performance,optimiz,optimization,126,"// This function is called by a client after using the low-level API to add; // live-out and live-in blocks. The unique value optimization is not; // available, SplitEditor::transferValues handles that case directly anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:32,Performance,perform,perform,32,"// Using Seen as a visited set, perform a BFS for all reaching defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:8,Deployability,update,updateSSA,8,"// Both updateSSA() and LiveRangeUpdater benefit from ordered blocks, but; // neither require it. Skip the sorting overhead for small updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:134,Deployability,update,updates,134,"// Both updateSSA() and LiveRangeUpdater benefit from ordered blocks, but; // neither require it. Skip the sorting overhead for small updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:87,Deployability,Update,UpdateSSA,87,"// Multiple values were found, so transfer the work list to the LiveIn array; // where UpdateSSA will use it as a work list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:29,Availability,down,down,29,"// Propagate live-out values down the dominator tree, inserting phi-defs; // when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:3,Performance,Cache,Cache,3,// Cache the DomTree node that defined the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:3,Performance,Cache,Cache,3,// Cache the DomTree node that defined the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:96,Modifiability,extend,extendRange,96,"// The value may be live-through even if Kill is set, as can happen when; // we are called from extendRange. In that case LiveOutSeen is true, and; // LiveOut indicates a foreign or missing value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:22,Deployability,update,updateFromLiveIns,22,// Add liveness since updateFromLiveIns now skips this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:94,Availability,avail,available,94,/// allUsesAvailableAt - Return true if all registers used by OrigMI at; /// OrigIdx are also available with the same value at UseIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:38,Availability,avail,available,38,// Verify that all used registers are available with the same values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:58,Modifiability,extend,extending,58,"// Since we're moving the DefMI load, make sure we're not extending any live; // ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:32,Performance,load,load,32,"// Since we're moving the DefMI load, make sure we're not extending any live; // ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
