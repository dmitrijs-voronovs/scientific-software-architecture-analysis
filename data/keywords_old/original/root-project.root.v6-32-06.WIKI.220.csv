id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/TBasket.html:1568,Availability,error,error,1568,"AdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:1652,Availability,error,error,1652,"rtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::G",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:10207,Availability,error,error,10207,"on of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasket(); Default contructor. TBasket(TDirectory* motherDir); Constructor used during reading. TBasket(const char* name, const char* title, TBranch* branch); Basket normal constructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:11083,Availability,error,error,11083," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The functio",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:12261,Availability,error,error,12261,"e that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; {return fEntryOffset;}. Int_t GetNevBuf() const; {return fNevBuf;}. Int_t GetNevBufSize() const; {return fNevBufSize;}. Int_t GetLast() const; {return fLast;}. void PrepareBasket(Long64_t ); {}. void SetBranch(TBranch* branch); { fBranch = branch; }. void SetNevBufSize(Int_t n); { fNevBufSize=n; }. void Update(Int_t newlast); { Update(newlast,newlast); }. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBasket.h 39642 2011-06-09 17:18:42Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:10624,Performance,cache,cache,10624,"onstructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory a",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:11209,Performance,cache,cache,11209," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The functio",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:11356,Performance,cache,cache,11356," 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The functio",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:11469,Performance,cache,cache,11469,"as been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(con",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasket.html:11591,Testability,log,logical,11591," cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; ",MatchSource.WIKI,root/html532/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasket.html
https://root.cern/root/html532/TBasketSQL.html:1757,Availability,error,error,1757,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeyl",MatchSource.WIKI,root/html532/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasketSQL.html
https://root.cern/root/html532/TBasketSQL.html:1841,Availability,error,error,1841,"r(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tTBasket::GetLast() const; TDirectory*TKey::GetMotherDir() const; vi",MatchSource.WIKI,root/html532/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBasketSQL.html
https://root.cern/root/html532/TBenchmark.html:1406,Availability,error,error,1406," TBenchmark(); virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObje",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:1490,Availability,error,error,1490,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msg",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:327,Testability,benchmark,benchmarking,327,". TBenchmark. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBenchmark. class TBenchmark: public TNamed. This class is a ROOT utility to help benchmarking applications. Examples of use of this class are given in the tutorials macros. Function Members (Methods); public:. TBenchmark(); virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObje",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:5844,Testability,benchmark,benchmarks,5844," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TBenchmark(const TBenchmark&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TBenchmark&operator=(const TBenchmark&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor*-*-*-; *-* =============================. TBenchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* =========",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:5885,Testability,benchmark,benchmarks,5885," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TBenchmark(const TBenchmark&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TBenchmark&operator=(const TBenchmark&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor*-*-*-; *-* =============================. TBenchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* =========",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:5925,Testability,benchmark,benchmarks,5925," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TBenchmark(const TBenchmark&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TBenchmark&operator=(const TBenchmark&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_t*fCpuTime[fNbench] Cpu Time; TStringTNamed::fNameobject identifier; TString*fNames[fNbench] Names of benchmarks; Int_tfNbenchNumber of active benchmarks; Int_tfNmaxMaximum number of benchmarks initialized; Float_t*fRealTime[fNbench] Real Time; TStopwatch*fTimerTimers; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBenchmark(); Benchmark default constructor*-*-*-; *-* =============================. TBenchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* =========",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7274,Testability,benchmark,benchmark,7274,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7312,Testability,benchmark,benchmarks,7312,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7467,Testability,benchmark,benchmark,7467,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7532,Testability,benchmark,benchmark,7532,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7596,Testability,benchmark,benchmarks,7596,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBenchmark.html:7816,Testability,benchmark,benchmarks,7816,"enchmark(const TBenchmark& ); copy constructor. TBenchmark& operator=(const TBenchmark& ); assignment operator. ~TBenchmark(); Benchmark default destructor*-*-*-; *-* ============================. Int_t GetBench(const char* name) const; -*-*-*Returns index of Benchmark name; *-* ===============================. Float_t GetCpuTime(const char* name); -*-*-*Returns Cpu time used by Benchmark name; *-* =======================================. Float_t GetRealTime(const char* name); -*-*-*Returns Realtime used by Benchmark name; *-* =======================================. void Print(Option_t* name = """") const; -*Prints parameters of Benchmark name; *-* ===================================. void Reset(); -*Reset all Benchmarks; *-* ====================. void Show(const char* name); Stops Benchmark name and Prints results*-; *-* =======================================. void Start(const char* name); -*-*-*-*-*Starts Benchmark name; *-* =====================; -; *-* An independent timer (see class TStopwatch) is started.; *-* the name of the benchmark is entered into the list of benchmarks.; *-* Benchmark can be stopped via TBenchmark::Stop; *-* Results can be printed via TBenchmark::Print; *-* TBenchmark::Show can be used to stop benchmark and print results.; *-* If name is an already existing benchmark, existing parameters are reset.; *-* A summary of all benchmarks can be seen via TBenchmark::Summary.; -; *. void Stop(const char* name); Terminates Benchmark name*-; *-* =========================. void Summary(Float_t& rt, Float_t& cp); -*-*-*-*-*-*Prints a summary of all benchmarks; *-* ==================================. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBenchmark.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBenchmark.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:631,Availability,avail,available,631,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:777,Availability,error,error,777,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:825,Availability,avail,available,825,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:1437,Availability,avail,available,1437,"ision of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:1549,Availability,error,errors,1549,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:2860,Availability,reliab,reliable,2860,"is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status == 0) {; // if the fit was successful, display bin-by-bin efficiencies; // as well as the result of the fit; numerator->Sumw2();; TH1* hEff = dynamic_cast<TH1*>(numerator->Clone(""heff""));; hEff->Divide(hEff, denominator, 1.0, 1.0, ""B"");; hEff->Draw(""E"");; eff->Draw(""same"");; }; }. Note that this method cannot be expected to yield reliable results when using; weighted histograms (because the likelihood computation will be incorrect). Function Members (Methods); public:. TBinomialEfficiencyFitter(); TBinomialEfficiencyFitter(const TBinomialEfficiencyFitter&); TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); virtual~TBinomialEfficiencyFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeFCN(Int_t& npar, Double_t*, Double_t& f, Double_t* par, Int_t flag); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """")",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:4194,Availability,error,error,4194,"r(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeFCN(Int_t& npar, Double_t*, Double_t& f, Double_t* par, Int_t flag); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TVirtualFitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* ",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:4278,Availability,error,error,4278,"endPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeFCN(Int_t& npar, Double_t*, Double_t& f, Double_t* par, Int_t flag); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(TF1* f1, Option_t* option = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TVirtualFitter*GetFitter(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vir",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:10044,Availability,error,error,10044,"itter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Int_t& npar, Double_t* , Double_t& f, Double_t* par, Int_t flag); Compute the likelihood. TBinomialEfficiencyFitter(). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TBinomialEfficiencyFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:10229,Availability,reliab,reliability,10229,"et of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Int_t& npar, Double_t* , Double_t& f, Double_t* par, Int_t flag); Compute the likelihood. TBinomialEfficiencyFitter(). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TBinomialEfficiencyFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:10463,Availability,error,errors,10463,"et of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Int_t& npar, Double_t* , Double_t& f, Double_t* par, Int_t flag); Compute the likelihood. TBinomialEfficiencyFitter(). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TBinomialEfficiencyFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:8307,Deployability,integrat,integration,8307,"Bit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be usefu",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:9219,Deployability,integrat,integration,9219,"e bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will b",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:8307,Integrability,integrat,integration,8307,"Bit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be usefu",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:9219,Integrability,integrat,integration,9219,"e bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will b",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:682,Modifiability,variab,variable,682,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:9308,Security,access,access,9308,"on integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:1473,Usability,simpl,simply,1473,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBinomialEfficiencyFitter.html:9679,Usability,simpl,simply,9679,"Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(",MatchSource.WIKI,root/html532/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBinomialEfficiencyFitter.html
https://root.cern/root/html532/TBits.html:1782,Availability,error,error,1782,"t TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static B",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:1866,Availability,error,error,1866,"irtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual ",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:577,Energy Efficiency,reduce,reduce,577,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:521,Modifiability,extend,extended,521,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:375,Testability,test,tested,375,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:566,Testability,test,tested,566,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBits.html:324,Usability,simpl,simple,324,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html532/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBits.html
https://root.cern/root/html532/TBonjourBrowser.html:4288,Availability,error,error,4288,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:4372,Availability,error,error,4372,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQ",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:9987,Availability,error,error,9987,"oid*GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fBonjourRecords; TFileHandler*fBonjourSocketHandler; TStringfBrowsingType; unsigned longfDNSRef. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBonjourBrowser(); Default ctor. ~TBonjourBrowser(); Cleanup. Int_t BrowseForServiceType(const char* serviceType); Tell Bonjour to start browsing for a specific type of service.; Returns -1 in case of error, 0 otherwise. void CurrentBonjourRecordsChanged(TList* bonjourRecords); Emit CurrentBonjourRecordsChanged signal. void BonjourSocketReadyRead(); The Bonjour socket is ready for reading. Tell Bonjour to process the; information on the socket, this will invoke the BonjourBrowseReply; callback. This is a private slot, used in BrowseForServiceType. void BonjourBrowseReply(unsigned long , unsigned int , Int_t , int , const char* , const char* , const char* , void* ); Static Bonjour browser callback function. void * GetSender(); { return this; }. TList * CurrentRecords() const; { return fBonjourRecords; }. const char * ServiceType() const; { return fBrowsingType; }. » Author: Fons Rademakers 29/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/bonjour:$Id: TBonjourBrowser.h 29385 2009-07-07 15:27:23Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:726,Deployability,install,install,726,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:839,Deployability,install,install,839,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:916,Deployability,install,installation,916,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourBrowser.html:467,Integrability,wrap,wraps,467,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html532/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourBrowser.html
https://root.cern/root/html532/TBonjourRecord.html:1652,Availability,error,error,1652,"rd(); voidTObject::AbstractMethod(const char* method) const; voidAddTXTRecord(const char* record); voidAddTXTRecord(const TString& record); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetRegisteredType() const; const char*GetReplyDomain() const; const char*GetServiceName() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecords() const; Int_tGetTXTRecordsLength() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html532/TBonjourRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRecord.html
https://root.cern/root/html532/TBonjourRecord.html:1736,Availability,error,error,1736,"char* record); voidAddTXTRecord(const TString& record); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetRegisteredType() const; const char*GetReplyDomain() const; const char*GetServiceName() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecords() const; Int_tGetTXTRecordsLength() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html532/TBonjourRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRecord.html
https://root.cern/root/html532/TBonjourRegistrar.html:472,Availability,alive,alive,472,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:4216,Availability,error,error,4216,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:4300,Availability,error,error,4300,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQ",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:10019,Availability,error,error,10019,"onst char*, const char*, const char*, void*); virtual void*GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TFileHandler*fBonjourSocketHandler; unsigned longfDNSRef; TBonjourRecordfFinalRecord. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBonjourRegistrar(); Default ctor. ~TBonjourRegistrar(); Cleanup. Int_t RegisterService(const TBonjourRecord& record, UShort_t servicePort); Register Bonjour service.; Return -1 in case or error, 0 otherwise. void ServiceRegistered(TBonjourRecord* record); Emit ServiceRegistered signal. void BonjourSocketReadyRead(); The Bonjour socket is ready for reading. Tell Bonjour to process the; information on the socket, this will invoke the BonjourRegisterService; callback. This is a private slot, used in RegisterService. void BonjourRegisterService(unsigned long , unsigned int , int , const char* , const char* , const char* , void* ); Static Bonjour register callback function. void * GetSender(); { return this; }. TBonjourRecord RegisteredRecord() const; { return fFinalRecord; }. » Author: Fons Rademakers 29/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/bonjour:$Id: TBonjourRegistrar.h 29385 2009-07-07 15:27:23Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:796,Deployability,install,install,796,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:909,Deployability,install,install,909,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:986,Deployability,install,installation,986,"urRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourRegistrar.html:532,Integrability,wrap,wraps,532,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html532/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourRegistrar.html
https://root.cern/root/html532/TBonjourResolver.html:3883,Availability,error,error,3883,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecord() const; virtual UInt_tTObject::GetUniqueID() const",MatchSource.WIKI,root/html532/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourResolver.html
https://root.cern/root/html532/TBonjourResolver.html:3967,Availability,error,error,3967,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecord() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConn",MatchSource.WIKI,root/html532/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourResolver.html
https://root.cern/root/html532/TBonjourResolver.html:9793,Availability,error,error,9793,"GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TFileHandler*fBonjourSocketHandler; unsigned longfDNSRef; TInetAddressfHostAddress; Int_tfPort; TStringfTXTRecord. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBonjourResolver(); Default ctor. ~TBonjourResolver(); Cleanup. Int_t ResolveBonjourRecord(const TBonjourRecord& record); Resolve Bonjour service to IP address and port.; Returns -1 in case of error, 0 otherwise. void RecordResolved(const TInetAddress* hostInfo, Int_t port); Emit RecordResolved signal. void BonjourSocketReadyRead(); The Bonjour socket is ready for reading. Tell Bonjour to process the; information on the socket, this will invoke the BonjourResolveReply; callback. This is a private slot, used in ResolveBonjourRecord. void BonjourResolveReply(unsigned long , unsigned int , UInt_t , int , const char* , const char* , UShort_t , UShort_t , const char* , void* ); Static Bonjour resolver callback function. void * GetSender(); { return this; }. TInetAddress GetInetAddress() const; { return fHostAddress; }. Int_t GetPort() const; { return fPort; }. const char * GetTXTRecord() const; { return fTXTRecord; }. » Author: Fons Rademakers 29/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/bonjour:$Id: TBonjourResolver.h 34481 2010-07-19 14:51:45Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. ",MatchSource.WIKI,root/html532/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourResolver.html
https://root.cern/root/html532/TBonjourResolver.html:510,Integrability,wrap,wraps,510,". TBonjourResolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourResolver. class TBonjourResolver: public TObject, public TQObject. TBonjourResolver. This class consists of one main member function,; ResolveBonjourRecord(), that resolves the service to an actual; IP address and port number. The rest of the class wraps the various; bits of Bonjour service resolver. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Function Members (Methods); public:. TBonjourResolver(); virtual~TBonjourResolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual void",MatchSource.WIKI,root/html532/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBonjourResolver.html
https://root.cern/root/html532/TBox.html:1702,Availability,error,error,1702,"dTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const",MatchSource.WIKI,root/html532/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBox.html
https://root.cern/root/html532/TBox.html:1786,Availability,error,error,1786,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2",MatchSource.WIKI,root/html532/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBox.html
https://root.cern/root/html532/TBox.html:9349,Integrability,depend,depending,9349,"to be drawn, specify option ""l"". TBox * DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this box with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a BOX/WBOX/PAD object is clicked. If the mouse is clicked in one of the 4 corners of the box (pA,pB,pC,pD); the box is resized with the rubber rectangle. If the mouse is clicked inside the box, the box is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the box is; rescaled parallel to this edge (same as Motif window manager). pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function is duplicated on purpose by TPad::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TPad::ExecuteEvent. void HideToolTip(Int_t event); Hide tool tip depending on the event type. Typically tool tips; are hidden when event is not a kMouseEnter and not a kMouseMotion; event. Int_t IsInside(Double_t x, Double_t y) const; Function which returns 1 if point x,y lies inside the box, 0 otherwise. void ls(Option_t* option = """") const; List this box with its attributes. void Paint(Option_t* option = """"); Paint this box with its current attributes. void PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t* option = """"); Draw this box with new coordinates. void Print(Option_t* option = """") const; Dump this box with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this box. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void Streamer(TBuffer& b); Stream an object of class TBox. Bool_t IsBeingResized(",MatchSource.WIKI,root/html532/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBox.html
https://root.cern/root/html532/TBranch.html:2052,Availability,error,error,2052," virtual voidAddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClassName() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; TDirec",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:2136,Availability,error,error,2136,"on_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClassName() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static L",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:17161,Availability,error,error,17161,"e associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option contains ""all"", drop all baskets including; read- and write-baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. The function returns the number of bytes committed to the memory basket.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because e.g. the branch is disabled,; the number of bytes returned is 0. Int_t FillEntryBuffer(TBasket* basket, TBuffer* buf, Int_t& lnew); Copy the data from fEntryBuffer into the current basket. TBranch* FindBranch(const char* name); -- Find the immediate sub-branch with passed name. TLeaf* FindLeaf(const char* name); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:17765,Availability,error,error,17765,"baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. The function returns the number of bytes committed to the memory basket.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because e.g. the branch is disabled,; the number of bytes returned is 0. Int_t FillEntryBuffer(TBasket* basket, TBuffer* buf, Int_t& lnew); Copy the data from fEntryBuffer into the current basket. TBranch* FindBranch(const char* name); -- Find the immediate sub-branch with passed name. TLeaf* FindLeaf(const char* name); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry""",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:19128,Availability,error,error,19128,"sket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket(); Return a fresh basket by either resusing an existing basket that needs; to be drop (according to TTree::MemoryFull) or create a new one. TLeaf* GetLeaf(const char* name) const; Retur",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:19710,Availability,failure,failure,19710,"depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TFile* GetFile(Int_t mode = 0); Return pointer to the file where branch buffers reside, returns 0; in case branch buffers reside in the same file as tree header.; If mode is 1 the branch buffer file is recreated. TBasket* GetFreshBasket(); Return a fresh basket by either resusing an existing basket that needs; to be drop (according to TTree::MemoryFull) or create a new one. TLeaf* GetLeaf(const char* name) const; Return pointer to the 1st Leaf named name in thisBranch. TString GetRealFileName() const. Int_t GetRow(Int_t row); Return all elements of one row unpacked in internal array fValues; [Actually just returns 1 (?)]. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). TBranch* GetMother() const; Get our top-level parent branch in the tree. TB",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:7499,Deployability,update,updateSubBranches,7499,"etAttFill(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); static voidResetCount(); virtual voidResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBufferAddress(TBuffer* entryBuffer); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t entries); virtual voidSetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidSetFile(TFile* file = 0); virtual voidSetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset = 0); virtual voidSetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(con",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:24089,Deployability,update,updateSubBranches,24089,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:24252,Deployability,update,updateExisting,24252,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:24281,Deployability,update,update,24281,"ide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::Ge",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:25250,Deployability,update,update,25250,"pdate all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:26199,Deployability,update,update,26199,"To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& b); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file. void SetFirstEntry(Long64_t entry); set the first entry number (case of TBranchSTL). void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branc",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:27280,Deployability,update,update,27280,"_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& b); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file. void SetFirstEntry(Long64_t entry); set the first entry number (case of TBranchSTL). void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. void SetSkipZip(Bool_t skip = kTRUE); { fSkipZip = skip; }. TBranch(const TBranch& ). TBranch& operator=(const TBranch& ). char * GetAddress() const; {return fAddress;}. Int_t * GetBasketBytes() const; {return fBasketBytes;}. Long64_t * GetBasketEntry() const; {return fBasketEntry;}. Int_t GetBasketSize() const; {return fBasketSize;}. TDirectory * GetDirectory() const; {return fDirectory;}. Int_t GetEntryOffsetLen() const; { return fEntryOffsetLen; }. Int_t GetEvent(Long64_t entry = 0); {return GetEntry(entry);}. const char * GetFileName() const; {return fFileName.Data();}. Int_t GetOffset() const; {return fOffset;}. Int_t GetReadBasket() const; {return fReadBasket;}. Long64_t GetReadEntry() const; {return fReadEntry;}. Int_t GetWriteBasket() const; {return fWriteBasket;}. Long64_t GetEntryNumber() const; {return fEntryNumber;}. Long64_t GetFirstEntry() const;",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:15702,Integrability,rout,routine,15702,"ting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option c",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:16025,Integrability,interface,interface,16025," A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option contains ""all"", drop all baskets including; read- and write-baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fi",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:18565,Integrability,depend,depending,18565,"me); -- Find the leaf corresponding to the name 'searchname'. Int_t FlushBaskets(); Flush to disk all the baskets of this branch and any of subbranches.; Return the number of bytes written or -1 in case of write error. Int_t FlushOneBasket(UInt_t which); If we have a write basket in memory and it contains some entries and; has not yet been written to disk, we write it and delete it from memory.; Return the number of bytes written;. TBasket* GetBasket(Int_t basket); Return pointer to basket basketnumber in this Branch. Long64_t GetBasketSeek(Int_t basket) const; Return address of basket in the file. TList* GetBrowsables(); Returns (and, if 0, creates) browsable objects for this branch; See TVirtualBranchBrowsable::FillListOfBrowsables. const char * GetClassName() const; Return the name of the user class whose content is stored in this branch,; if any. If this branch was created using the 'leaflist' technique, this; function returns an empty string. const char* GetIconName() const; Return icon name depending on type of branch. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all leaves of entry and return total number of bytes read. The input argument ""entry"" is the entry number in the current tree.; In case of a TChain, the entry number in the current Tree must be found; before calling this function. For example:. TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);. The function returns the number of bytes read from the input buffer.; If entry does not exist, the function returns 0.; If an I/O error occurs, the function returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray* list, Int_t n); Read all leaves of an entry and export buffers to real objects in a TClonesArray list. Returns total number of bytes read. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:10010,Modifiability,variab,variable,10010,"::MakeZombie(); voidReadLeaves0Impl(TBuffer& b); voidReadLeaves1Impl(TBuffer& b); voidReadLeaves2Impl(TBuffer& b); voidReadLeavesImpl(TBuffer& b); voidSetSkipZip(Bool_t skip = kTRUE); Int_tWriteBasket(TBasket* basket, Int_t where). private:. TBranch(const TBranch&); Int_tFillEntryBuffer(TBasket* basket, TBuffer* buf, Int_t& lnew); TBranch&operator=(const TBranch&). Data Members; public:. enum EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fAddress! Address of 1st leaf (variable or object); Int_t*fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tfBasketSizeInitial Size of Basket Buffer; TObjArrayfBaskets-> List of baskets of this branch; TObjArrayfBranches-> List of Branches of this branch; TList*fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tfCompressCompression level and algorithm; TBasket*fCurrentBasket! Pointer to the current basket.; TDirectory*fDirectory! Pointer to directory where this branch buffers are stored; Long64_tfEntriesNumber of entries; TBuffer*fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tfEntryNumberCurrent entry number (last one filled in this branch); Int_tfEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringfFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncfFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAttFill::fFillStylefill area style; Long64_tfFirstBasketEntry! First entry in the current basket.; Long64_tfFirstEntryNumber of the firs",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:12802,Modifiability,variab,variable,12802,"_p2memfuncfReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tfSkipZip! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:12866,Modifiability,variab,variable,12866,"_p2memfuncfReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tfSkipZip! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:12888,Modifiability,variab,variable,12888,"_p2memfuncfReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tfSkipZip! After being read, the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:12937,Modifiability,variab,variable,12937," the buffer will not be unziped.; Int_tfSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all leaves before compression; TTree*fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], w",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:13125,Modifiability,variab,variable,13125,"fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; I",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:13177,Modifiability,variab,variable,13177,"fTree! Pointer to Tree header; Int_tfWriteBasketLast basket number written; Long64_tfZipBytesTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; I",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:13200,Modifiability,variab,variable,13200,"esTotal number of bytes in all leaves after compression; static Int_tfgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranch(); Default constructor. Used for I/O by default. TBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of a Tree. * address is the address of the first item of a structure; or the address of a pointer to an object (see example in TTree.cxx).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is us",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:14029,Modifiability,variab,variable,14029,"acter. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integers) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is ",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:21918,Performance,load,load,21918," current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the ad",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:23842,Safety,avoid,avoid,23842,"ergeInfo* ); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; b",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:15067,Security,access,access,15067,"ize of the array,; otherwise return 0.; The leaf referred to by nelem **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integers, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integers) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:21840,Security,access,access,21840,"er). Long64_t GetTotBytes(Option_t* option = """") const; Return total number of bytes in the branch (excluding current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Read zero leaves without the overhead of a loop. void ReadLeaves1Impl(TBuffer& b); Read one leaf without the overhead of a loop. void ReadLeaves2Impl(TBuffer& b); Read two leaves without the overhead of a loop. void FillLeavesImpl(TBuffer& b); Loop on all leaves of this branch to fill Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Rese",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:24946,Security,access,access,24946,". void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access t",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranch.html:25895,Security,access,access,25895,"e can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& b); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file",MatchSource.WIKI,root/html532/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranch.html
https://root.cern/root/html532/TBranchClones.html:1876,Availability,error,error,1876,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html532/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchClones.html
https://root.cern/root/html532/TBranchClones.html:1960,Availability,error,error,1960,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html532/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchClones.html
https://root.cern/root/html532/TBranchClones.html:7965,Deployability,update,updateSubBranches,7965,"anch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer",MatchSource.WIKI,root/html532/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchClones.html
https://root.cern/root/html532/TBranchClones.html:15189,Deployability,update,update,15189,"= 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. TBranchClones(TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); -- Constructor. void Init(TTree* tree, TBranch* parent, const char* name, void* clonesaddress, Int_t basketsize = 32000, Int_t compress = -1, Int_t splitlevel = 1); Initialization (non-virtual, to be called from constructor). ~TBranchClones(); -- Destructor. void Browse(TBrowser* b); -- Browse this branch. Int_t Fill(); -- Loop on all branches and fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches and return total number of bytes read. void Print(Option_t* option = """") const; -- Print branch parameters. void Reset(Option_t* option = """"); -- Reset branch. Existing buffers are deleted; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); -- Reset branch after a merge. Existing buffers are deleted; Entries, max and min are reset. void SetAddress(void* add); -- Set address of this branch. void SetBasketSize(Int_t buffsize); -- Reset basket size for all sub-branches. void Streamer(TBuffer& b); -- Serialize/Deserialize from a buffer. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. const char* GetClassName() const; { return fClassName; }. Int_t GetN() const; {return fN;}. TClonesArray * GetList() const; {return fList;}. Bool_t IsFolder() const; {return kTRUE;}. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchClones.h 41347 2011-10-12 07:03:27Z axel $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchClones.html
https://root.cern/root/html532/TBranchClones.html:10611,Modifiability,variab,variable,10611,"ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TBranch*fBranchCountBranch with clones count; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNamename of the class of the objets in the ClonesArray; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves impl",MatchSource.WIKI,root/html532/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchClones.html
https://root.cern/root/html532/TBranchElement.html:2494,Availability,error,error,2494,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; TBranchElement*GetBranchCount() const; TBranchElement*GetBranchCount2() const; Int_t*GetBranchOffset() const; virtu",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:2578,Availability,error,error,2578,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; TBranchElement*GetBranchCount() const; TBranchElement*GetBranchCount2() const; Int_t*GetBranchOffset() const; virtual TList*TBranch::GetBrowsables(); UInt_tGetCheckSum(); virtual TClass*GetClass() co",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:22110,Availability,error,error,22110,"= 32000, Int_t splitlevel = 0, Int_t compress = -1); -- Constructor when the branch object is an STL collection. If splitlevel > 0 this branch in turn is split into sub branches. void Init(TTree* tree, TBranch* parent, const char* name, TVirtualCollectionProxy* cont, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1); -- Init when the branch object is an STL collection. If splitlevel > 0 this branch in turn is split into sub branches. ~TBranchElement(); -- Destructor. TStreamerInfo* GetInfoImp() const; -- Get streamer info for the branch class. TStreamerInfo* GetInfo() const; -- Get streamer info for the branch class. void Browse(TBrowser* b); -- Browse the branch content. void BuildTitle(const char* name); -- Set branch and leaf name and title in the case of a container sub-branch. Int_t Fill(); -- Loop on all leaves of this branch to fill the basket buffer. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of; bytes returned is -1. If no data are written, because, e.g.,; the branch is disabled, the number of bytes returned is 0. Note: We not not use any member functions from TLeafElement!. void FillLeavesMakeClass(TBuffer& b); -- Write leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void FillLeavesCollection(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void FillLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesCollectionSplitPtrMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesCollectionMember(TBuffer& b); -- Write leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void FillLeavesClones(TBuffer& b); -",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:25418,Availability,error,error,25418," Get the branch address. If we are *not* owned by a MakeClass() tree:. If we are a top-level branch, return a pointer; to the pointer to our object. If we are *not* a top-level branch, return a pointer; to our object. If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; -- Returns the bran",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:25788,Availability,failure,failure,25788,". If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; -- Returns the branch value. If the leaf is an array, j is the index in the array. If leaf is an array inside a TClonesArray, len should be the length; of the array. If subarr is true, then len is actually the index within the sub-arra",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:9298,Deployability,update,updateSubBranches,9298,"::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchFolder(); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); virtual voidSetClassName(const char* name); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset); voidSetParentClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidS",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:37158,Deployability,update,update,37158,"oes *not* increase, the base class is elided) and for; TClonesArray or STL container data members (which have one; additional level of sub-branches). The only other way the; depth increases is when the top-level branch has a split; class data member, in that case the constructor will create; a sub-branch for it. In other words, the interior nodes of; the branch tree are all either: base class nodes; split; class nodes which are direct sub-branches of top-level nodes; (created by TClass::Bronch usually); or TClonesArray or STL; container master nodes. Note: The exception to the above is for the top-level branches,; Tree::Bronch creates nodes for everything in that case,; except for a TObject base class of a class which has the; can ignore tobject streamer flag set. void UpdateFile(); Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); with the current value of fTree->GetCurrentFile unless this branch has been; redirected to a different file. Also update the sub-branches. void SetParentClass(TClass* clparent). void ValidateAddress() const; Check to see if the user changed the object pointer without telling us. TBranchElement(const TBranchElement& ); Not implemented. TBranchElement& operator=(const TBranchElement& ). void SetBranchCount2(TBranchElement* bre); { fBranchCount2 = bre; }. TBranchElement * GetBranchCount() const; { return fBranchCount; }. TBranchElement * GetBranchCount2() const; { return fBranchCount2; }. Int_t * GetBranchOffset() const; { return fBranchOffset; }. UInt_t GetCheckSum(); { return fCheckSum; }. const char * GetClassName() const; { return fClassName.Data(); }. TClass * GetClass() const; { return fBranchClass; }. const char * GetClonesName() const; { return fClonesName.Data(); }. Int_t GetID() const; { return fID; }. const char * GetParentName() const; { return fParentName.Data(); }. Int_t GetNdata() const; { return fNdata; }. Int_t GetType() const; { return fType; }. Int_t GetStreamerType() const; { return fStrea",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:30312,Energy Efficiency,allocate,allocated,30312," within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObje",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:30651,Energy Efficiency,allocate,allocated,30651,"s into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:30723,Energy Efficiency,allocate,allocated,30723,"ch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:30828,Energy Efficiency,allocate,allocated,30828,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31055,Energy Efficiency,allocate,allocate,31055,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31127,Energy Efficiency,allocate,allocated,31127,"/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31401,Energy Efficiency,allocate,allocate,31401,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31470,Energy Efficiency,allocate,allocated,31470,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31509,Energy Efficiency,allocate,allocated,31509,"erge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 =",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:31785,Energy Efficiency,allocate,allocated,31785," added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branc",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:32221,Energy Efficiency,allocate,allocated,32221,"branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate""",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:32582,Energy Efficiency,allocate,allocated,32582,"eeded. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted a",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:33128,Energy Efficiency,allocate,allocated,33128," as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set ",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:15285,Integrability,interface,interface,15285,"tected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Int_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TClassReffCurrentClass! Reference to current (transient) class definition; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed to",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:25850,Integrability,depend,depending,25850,"volution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; -- Returns the branch value. If the leaf is an array, j is the index in the array. If leaf is an array inside a TClonesArray, len should be the length; of the array. If subarr is true, then len is actually the index within the sub-array. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class ",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:30753,Integrability,interface,interface,30753,"counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:32149,Integrability,rout,routines,32149,"the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An exam",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:14145,Modifiability,variab,variable,14145,"teAddress() const; Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). private:. TBranchElement(const TBranchElement&); TBranchElement&operator=(const TBranchElement&); static voidSwitchContainer(TObjArray*). Data Members; public:. enum { kBranchFolder; kDeleteObject; kCache; kOwnOnfileObj; kAddressSet; kMakeClass; kDecomposedObj; };; enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Int_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TCl",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:17002,Modifiability,variab,variable,17002,"d ("""" if in same file as Tree header); TStreamerInfoActions::TActionSequence*fFillActionSequence! Set of actions to be executed to write the data to the basket.; Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the current basket.; Long64_tTBranch::fFirstEntryNumber of the first entry in this branch; Int_tfIDelement serial number in fInfo; vector<Int_t>fIDs! List of the serial number of all the StreamerInfo to be used.; TStreamerInfo*fInfo! Pointer to StreamerInfo; Bool_tfInit! Initialization flag for branch assignment; Bool_tfInitOffsets! Initialization flag to not endlessly recalculate offsets; TVirtualCollectionIterators*fIterators! holds the iterators when the branch is of fType==4.; TObjArrayTBranch::fLeaves-> List of leaves of this branch; Int_tTBranch::fMaxBasketsMaximum number of Baskets so far; Int_tfMaximumMaximum entries for a TClonesArray or variable array; TBranch*TBranch::fMother! Pointer to top-level parent branch in the tree.; Int_tTBranch::fNBaskets! Number of baskets in memory; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of data in this branch; Long64_tTBranch::fNextBasketEntry! Next entry that will requires us to go to the next basket; Int_tTBranch::fNleaves! Number of leaves; char*fObject! Pointer to object at *fAddress; Int_tTBranch::fOffsetOffset of this branch; TVirtualArray*fOnfileObject! Place holder for the onfile representation of data members.; TBranch*TBranch::fParent! Pointer to parent branch.; TClassReffParentClass! Reference to class definition in fParentName; TStringfParentNameName of parent class; TVirtualCollectionPtrIterators*fPtrIterators! holds the iterators when the branch is of fType==4 and it is a split collection of pointers.; TStreamerInfoActions::TActionSequence*fReadActionSequence! Set of actions to be executed to extract the data from",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:34815,Performance,load,loaded,34815,"anch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetFillActionSequence(); Set the sequence of actions needed to write the data out from the buffer. void SetFillLeavesPtr(); Set the FillLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void SetupAddressesImpl(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& b); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:27984,Safety,detect,detect,27984,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:32705,Testability,test,test,32705,"ent = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSiz",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchElement.html:33244,Testability,test,test,33244,"ocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to whi",MatchSource.WIKI,root/html532/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchElement.html
https://root.cern/root/html532/TBranchObject.html:1946,Availability,error,error,1946,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:2030,Availability,error,error,2030,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:14709,Availability,error,error,14709,"reate a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new ",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:15045,Availability,failure,failure,15045,"ool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() const; Return TRUE if more than one leaf or if fBrowsables, FALSE otherwise. void Print(Option_t* option = """") const; Print TBranch parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer call",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:8001,Deployability,update,updateSubBranches,8001,"oidTBranch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:16304,Energy Efficiency,efficient,efficient,16304,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 39611 2011-06-08 19:35:17Z pcanal $ » Last generated: 2011-11-",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:14128,Integrability,rout,routine,14128,"leobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() co",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchObject.html:10672,Modifiability,variab,variable,10672," voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum { kWarn; };; enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNameClass name of referenced object; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAtt",MatchSource.WIKI,root/html532/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchObject.html
https://root.cern/root/html532/TBranchRef.html:2369,Availability,error,error,2369,"tBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:2453,Availability,error,error,2453," virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel()",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:8468,Deployability,update,updateSubBranches,8468,"; virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTBranch::SetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses();",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:11139,Modifiability,variab,variable,11139,"eaflist, Int_t compress); voidTObject::MakeZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAttFill::fFillStylefill area",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:362,Performance,load,loads,362,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. TBranchRef(); TBranchRef(TTree* tree); virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option =",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:516,Performance,load,load,516,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. TBranchRef(); TBranchRef(TTree* tree); virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option =",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:993,Performance,load,loading,993,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. TBranchRef(); TBranchRef(TTree* tree); virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option =",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:14845,Usability,clear,cleared,14845,"Total number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 40872 2011-09-13 21:33:33Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchRef.html:14983,Usability,clear,cleared,14983,"Total number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 40872 2011-09-13 21:33:33Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchRef.html
https://root.cern/root/html532/TBranchSTL.html:1920,Availability,error,error,1920,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTB",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:2004,Availability,error,error,2004,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual const char*GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() const; Int_tTBranch::GetCompressionLevel() const; I",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:14701,Availability,failure,failure,14701," proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. TStreamerInfo* GetInfo() const. Check if we don't have the streamer info. Bool_t IsFolder() const; branch declared folder if at least one entry. void Print(Option_t* ) const; Print the branch parameters. void ReadLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void FillLeavesImpl(TBuffer& b); TO BE DOCUMENTED. void SetAddress(void* addr). We are the top level branch. const char * GetClassName() const; { return fClassName.Data(); }. » Last changed: root/tree:$Id: TBranchSTL.h 40872 2011-09-13 21:33:33Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:7998,Deployability,update,updateSubBranches,7998,"tCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addr); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:10572,Modifiability,variab,variable,10572,"eZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). private:. voidFillLeavesImpl(TBuffer& b); voidReadLeavesImpl(TBuffer& b). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAttFill::fFillStylefill area",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:365,Performance,queue,queues,365,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. TBranchSTL(); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBranchSTL.html:13239,Security,checksum,checksum,13239,"s branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill ex",MatchSource.WIKI,root/html532/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBranchSTL.html
https://root.cern/root/html532/TBRIK.html:1765,Availability,error,error,1765,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_t",MatchSource.WIKI,root/html532/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBRIK.html
https://root.cern/root/html532/TBRIK.html:1849,Availability,error,error,1849,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) c",MatchSource.WIKI,root/html532/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBRIK.html
https://root.cern/root/html532/TBrowser.html:3263,Availability,error,error,3263,"bject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTOb",MatchSource.WIKI,root/html532/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowser.html
https://root.cern/root/html532/TBrowser.html:3347,Availability,error,error,3347,"c TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIconify()",MatchSource.WIKI,root/html532/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowser.html
https://root.cern/root/html532/TBrowser.html:8501,Integrability,depend,depending,8501,"tor=(const TBrowser&). Data Members; public:. enum { kNoHidden; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """,MatchSource.WIKI,root/html532/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowser.html
https://root.cern/root/html532/TBrowserImp.html:345,Integrability,protocol,protocol,345,". TBrowserImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBrowserImp. class TBrowserImp. TBrowserImp. ABC describing GUI independent browser implementation protocol. Function Members (Methods); public:. TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); virtual~TBrowserImp(); virtual voidAdd(TObject*, const char*, Int_t); virtual voidAddCheckBox(TObject*, Bool_t = kFALSE); virtual voidBrowseObj(TObject*); TBrowser*Browser() const; virtual voidCheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual voidCloseTabs(); virtual Long_tExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidExecuteDefaultAction(TObject*); virtual TBrowser*GetBrowser() const; virtual Option_t*GetDrawOption() const; virtual TGMainFrame*GetMainFrame() const; virtual voidIconify(); virtual TClass*IsA() const; virtual voidRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TBrowserImp(const TBrowserImp& br); TBrowserImp&operator=(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation",MatchSource.WIKI,root/html532/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowserImp.html
https://root.cern/root/html532/TBrowserPlugin.html:1466,Availability,error,error,1466,"e, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html532/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowserPlugin.html
https://root.cern/root/html532/TBrowserPlugin.html:1550,Availability,error,error,1550,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html532/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowserPlugin.html
https://root.cern/root/html532/TBrowserPlugin.html:320,Modifiability,plugin,plugins,320,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TBrowserPlugin. class TBrowserPlugin: public TNamed. TBrowserPlugin. Helper class used to manage plugins (command or macro to be executed). Function Members (Methods); public:. TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName(",MatchSource.WIKI,root/html532/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBrowserPlugin.html
https://root.cern/root/html532/TBtree.html:9293,Availability,error,error,9293,"; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const;",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:9377,Availability,error,error,9377,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() ",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:504,Energy Efficiency,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:3813,Energy Efficiency,allocate,allocated,3813,"d here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (ea",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:4435,Energy Efficiency,allocate,allocate,4435,"efore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array of pointers and keys is allocated as ORDER+1; pairs of keys and nodes, meaning that one key field (key[0]) is not used; and therefore wasted. Given that the number of interior nodes is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; P",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:315,Modifiability,inherit,inherits,315,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:504,Modifiability,adapt,adapt,504,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:636,Modifiability,enhance,enhancement,636,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:990,Modifiability,enhance,enhancement,990,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Or",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:4908,Modifiability,variab,variable,4908,"des is; small, that this waste allows fewer cases of special code, and that it; is useful in certain of the methods, it was felt to be a worthwhile waste. The size of the exterior nodes (leaf nodes) does not need to be related to; the size of the interior nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element h",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:5037,Modifiability,variab,variable,5037," nodes at all. Since leaf nodes contain only; keys, they may be as large or small as we like independent of the size; of the interior nodes. For no particular reason other than it seems like; a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they; will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage; of keeping the size of the leaf and interior arrays the same, so that if we; find allocation and de-allocation of these arrays expensive, we can modify; their allocation to use a garbage ring, or something. Both of these numbers will be run-time constants associated with each tree; (each tree at run-time can be of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:5862,Performance,perform,perform,5862,"e of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - mo",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:2774,Security,access,access,2774,"ains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1. If the tree is only filled, then all the nodes will be at least 2/3 full.; They will almost all be exactly 2/3 full if the elements are added to the; tree in order (either increasing or decreasing). [Knuth says McCreight's; experiments showed almost 100% memory utilization. I don't see how that; can be given the algorithms that Knuth gives. McCreight must have used; a different scheme for balancing. [No, he used a different scheme for; splitting: he did a two-way split instead of the three way split as we do; here. Which means that McCreight does better on insertion of ordered data,; but we should do better on insertion of random data.]]. It must also be noted that B-trees were designed for DISK access algorithms,; not necessarily in-memory sorting, as we intend it to be used here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:7205,Security,access,access,7205,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. TBtree(Int_t ordern = 3); virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCo",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:16253,Security,access,access,16253,"& obj); voidIncrNofKeys(); voidTObject::MakeZombie(); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. voidInit(Int_t i); voidRootIsEmpty(); voidRootIsFull(). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(Int_t ordern = 3); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetN",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBtree.html:7198,Testability,log,log,7198,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. TBtree(Int_t ordern = 3); virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCo",MatchSource.WIKI,root/html532/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBtree.html
https://root.cern/root/html532/TBuffer.html:473,Availability,avail,available,473,". TBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer. class TBuffer: public TObject. TBuffer. Buffer base class used for serializing objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TBuffer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject:",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:2398,Availability,error,error,2398,"c TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObjec",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:2482,Availability,error,error,2482,"dClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tGetBufferVersion() const; static TClass*GetClass(const type_info& typeinfo); static TClass*GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtual voidGetMappedObject(UInt_t tag, void*& ptr, TClass*& ClassPtr) const; virtual const char*TObject::GetN",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:17477,Availability,error,error,17477,"ction documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the curre",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:17447,Integrability,rout,routine,17447,"ction documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the curre",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:16329,Modifiability,extend,extending,16329,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same si",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:16105,Performance,cache,cache,16105,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same si",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:18605,Performance,cache,cache,18605,"ize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() cons",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:18761,Performance,cache,cache,18761,"etParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { fBuffer = 0; }. Int_t Length() const; { return (Int_t)(fBufCur - fBuffer); }. Bool_t CheckObject(const",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:18918,Performance,cache,cache,18918," const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() const; { return fBufSize; }. void DetachBuffer(); { fBuffer = 0; }. Int_t Length() const; { return (Int_t)(fBufCur - fBuffer); }. Bool_t CheckObject(const TObject* obj). Bool_t CheckObject(const void* obj, const TClass* ptrClass). Int_t ReadBuf(void* buf, Int_t max). void WriteBuf(const void* buf, Int_t max). ",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer.html:16733,Safety,avoid,avoiding,16733,"nCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root/html532/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer.html
https://root.cern/root/html532/TBuffer3D.html:10207,Availability,error,error,10207,"city = 0); virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearSectionsValid(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static UInt_tDecCSLevel(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:10291,Availability,error,error,10291,"t; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearSectionsValid(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static UInt_tDecCSLevel(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classnam",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:10948,Availability,mask,mask,10948,"tual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; UInt_tNbPnts() const; UInt_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:12834,Availability,mask,mask,12834,"gs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Writ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:13349,Availability,mask,mask,13349,"dTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tType() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17045,Availability,mask,mask,17045,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17091,Availability,mask,mask,17091,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17135,Availability,mask,mask,17135,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17179,Availability,mask,mask,17179,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17188,Availability,mask,mask,17188,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17224,Availability,mask,mask,17224,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:17268,Availability,mask,mask,17268,"; Inherited Members; Includes; Libraries. Function documentation; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Destructor; Construct from supplied shape type and raw sizes. ~TBuffer3D(); Destructor. void Init(); Initialise buffer. void ClearSectionsValid(); Clear any sections marked valid. void SetLocalMasterIdentity(); Set kRaw tesselation section of buffer with supplied sizes; Set fLocalMaster in section kCore to identity. void SetAABoundingBox(const Double_t* origin, const Double_t* halfLengths); Set fBBVertex in kBoundingBox section to a axis aligned (local) BB; using supplied origin and box half lengths. 7-------6; /| /|; 3-------2 |; | 4-----|-5; |/ |; 0-------1. Bool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); Set kRaw tesselation section of buffer with supplied sizes. UInt_t GetCSLevel(); return CS level. void IncCSLevel(); increment CS level. UInt_t DecCSLevel(); decrement CS level. TBuffer3D(const TBuffer3D& ); Non-copyable class. const TBuffer3D & operator=(const TBuffer3D& ). void SetSectionsValid(UInt_t mask); Section validity flags. { fSections |= mask & kAll; }. Bool_t SectionsValid(UInt_t mask) const; { return (Bool_t) (GetSections(mask) == mask); }. UInt_t GetSections(UInt_t mask) const; { return (UInt_t) (fSections & mask); }. UInt_t NbPnts() const; { return fNbPnts; }. UInt_t NbSegs() const; { return fNbSegs; }. UInt_t NbPols() const; { return fNbPols; }. Int_t Type() const; SECTION: kCore. { return fType; }. » Author: Olivier Couet 05/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBuffer3D.h,v 1.00 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:8261,Energy Efficiency,efficient,efficient,8261,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacit",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:464,Integrability,interface,interface,464,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5699,Integrability,interface,interface,5699,"is object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicatin",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:821,Performance,perform,performance,821,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:1627,Performance,perform,performance,1627,"ire a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNone. You must; fill the buffer and mark these sections valid, and pass the buffer again. A; typical code snippet would be:; TBuffer3DSphere sphereBuffer;; Fill out kCore...; Fill out kBoundingBox...; Fill out kShapeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5315,Performance,cache,cached,5315,"er (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5414,Performance,perform,perform,5414,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5469,Performance,perform,performance,5469,"n matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:6544,Performance,cache,cached,6544,"ly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publish",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:8283,Performance,cache,cache,8283,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:7726,Safety,detect,detect,7726," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:1169,Testability,test,test,1169,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:4884,Testability,log,logical,4884,"tated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For v",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5071,Testability,log,logical,5071,"o provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalM",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5193,Testability,log,logical,5193,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5221,Testability,log,logical,5221,"on of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be cap",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5536,Testability,log,logical,5536,"d contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; s",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5907,Testability,log,logical,5907,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:5984,Testability,log,logical,5984,"re we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can; also perform internal GL specific caching with considerable performance gains; in these cases.; For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:7146,Testability,log,logical,7146,"s, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(T",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:8033,Testability,log,logical,8033," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:8294,Testability,log,logical,8294,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:1178,Usability,clear,clear,1178,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:3422,Usability,clear,clear,3422,"apeSpecific for TBuffer3DSphere; Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSections & TBuffer3D::kRawSizes) {; Fill out kRawSizes...; }; if (reqSections & TBuffer3D::kRaw) {; Fill out kRaw...; }; Add second time to viewer - ignore return cannot do more; viewer->AddObject(buffer);; }; }>; ShapeSpecific: If the viewer can directly display the buffer without; filling of the kRaw/kRawSizes section it will not need to request client side; tessellation.; Currently we provide the following various shape specific classes, which the; OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a stand",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:4075,Usability,simpl,simpler,4075,"ge of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively fe",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:6755,Usability,simpl,simply,6755,"you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualVie",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBuffer3D.html:8005,Usability,simpl,simple,8005," viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free",MatchSource.WIKI,root/html532/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBuffer3D.html
https://root.cern/root/html532/TBufferFile.html:2559,Availability,error,error,2559,"Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:2643,Availability,error,error,2643,"(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*GetLastProcessID(TRefTable* reftable) const; virtual Int_tGetMapCount() const; virtu",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:18938,Availability,error,error,18938,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:37135,Availability,failure,failure,37135,"st); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:26976,Energy Efficiency,allocate,allocated,26976,"its. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:27163,Energy Efficiency,allocate,allocated,27163,"ading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:27342,Energy Efficiency,allocate,allocated,27342," (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:27516,Energy Efficiency,allocate,allocated,27516,"d the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for th",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:27693,Energy Efficiency,allocate,allocated,27693,"0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:27883,Energy Efficiency,allocate,allocated,27883,"s from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferF",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:28062,Energy Efficiency,allocate,allocated,28062,"ers from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of ch",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:28245,Energy Efficiency,allocate,allocated,28245,"orts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:28489,Energy Efficiency,allocate,allocated,28489,"ment is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:28795,Energy Efficiency,allocate,allocated,28795," I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long64_t* l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. Int_t ReadStaticArray(Float_t* f); Read array of floats from the I/O buffer. Returns the number of floats; read. Int_t ReadStaticArray(Double_t* d); Read array of doubles from the I/O buffer. Returns the number",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:43008,Energy Efficiency,allocate,allocated,43008,"e benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVir",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:18908,Integrability,rout,routine,18908,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:22397,Integrability,depend,depending,22397,"d; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16(). void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32(). void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer.; The following cases are supported for streaming a Float16_t type; depending on the range declaration in the comment field of the data member:; A- Float16_t fNormal;; B- Float16_t fTemperature; //[0,100]; C- Float16_t fCharge; //[-1,1,2]; D- Float16_t fVertex[3]; //[-30,30,10]; E- Float16_t fChi2; //[0,0,6]; F- Int_t fNsp;; Float16_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Float_t to a Float_t with mantissa truncated to 12 bits; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specifie",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:24687,Integrability,depend,depending,24687,"t the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B- Double32_t fTemperature; //[0,100]; C- Double32_t fCharge; //[-1,1,2]; D- Double32_t fVertex[3]; //[-30,30,10]; E- Double32_t fChi2; //[0,0,6]; F- Int_t fNsp;; Double32_t* fPointValue; //[fNsp][0,3]. In case A fNormal is converted from a Double_t to a Float_t; In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbi",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:17883,Modifiability,extend,extending,17883,"write; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>fInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the ne",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:23724,Modifiability,variab,variable,23724," In case B fTemperature is converted to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>16 it is set to 16; if (xmin==0 and xmax==0 and nbits <=14) the float word will have; its mantissa truncated to nbits significative bits. IMPORTANT NOTE. --NOTE 1; Lets assume an original variable float x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a float to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Float16_t data type in tutorial double32.C. /*; ; */. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer.; The following cases are supported for streaming a Double32_t type; depending on the range declaration in the comment field of the data member:; A- Double32_t fNormal;; B",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:26020,Modifiability,variab,variable,26020,"ed to a 32 bit unsigned integer; In case C fCharge is converted to a 2 bits unsigned integer; In case D the array elements of fVertex are converted to an unsigned 10 bits integer; In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits; In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer; Note that the range specifier must follow the dimension specifier.; the case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8]; if nbits is not specified, or nbits <2 or nbits>32 it is set to 32; if (xmin==0 and xmax==0 and nbits <=14) the double word will be converted; to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns th",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:35818,Modifiability,inherit,inherit,35818,"ent* ele = 0); Write array of n doubles (as float) into the I/O buffer.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Write an array of object starting at the address 'start' and of length 'n'; the objects in the array are assumed to be of class 'cl'. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Write an array of object starting at the address '*start' and of length 'n'; the objects in the array are of class 'cl'; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object o",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:36398,Modifiability,inherit,inheritance,36398,"; 'isPreAlloc' indicates whether the data member is marked with '->'; Return:; 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TObject * ReadObject(const TClass* cl); Read object from I/O buffer. clReq is NOT used.; The value returned is the address of the actual start in memory of; the object. Note that if the actual class of the object does not; inherit first from TObject, the type of the pointer is NOT 'TObject*'.; [More accurately, the class needs to start with the TObject part, for; the pointer to be a real TObject*].; We recommend using ReadObjectAny instead of ReadObject. void SkipObjectAny(); Skip any kind of object from buffer. void * ReadObjectAny(const TClass* cast); Read object from I/O buffer.; A typical use for this function is:; MyClass *ptr = (MyClass*)b.ReadObjectAny(MyClass::Class());; I.e. clCast should point to a TClass object describing the class pointed; to by your pointer.; In case of multiple inheritance, the return value might not be the; real beginning of the object in memory. You will need to use a; dynamic_cast later if you need to retrieve it. void WriteObject(const TObject* obj); Write object to I/O buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to I/O buffer.; This function assumes that the value of 'actualObjectStart' is the actual start of; the object of class 'actualClass'. Int_t WriteObjectAny(const void* obj, const TClass* ptrClass); Write object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:38802,Modifiability,inherit,inheriting,38802,"(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< kMaxMapCount) when writing. UInt_t CheckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); Check for object in the read map. If the object is 0 it still has to be; read. Try to read it from the buffer starting at location offset. If the; object is -1 then it really does not exist and we return 0. If the object; exists just return the offset. Bool_t CheckObject(const TObject* obj); Check if the specified object is already in the buffer.; Returns kTRUE if object already in the buffer, kFALSE otherwise; (also if obj is 0 or TBuffer not in writing mode). Bool_t CheckObject(const void* obj, const TClass* ptrClass); Check if the specified object of the specified class is already in; the buffer. Returns kTRUE if object already in the buffer,; kFALSE otherwise (also if obj is 0 ). void SetPidOffset(UShort_t offset); This offset is used when a key (or basket) is t",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:17134,Performance,cache,cache,17134,"lass). Data Members; public:. enum { kMapSize; kStreamedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>fInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:42217,Performance,perform,performance,42217,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:42244,Performance,perform,performance,42244," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:44160,Performance,optimiz,optimized,44160,"to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcessID(TRefTable* reftable) const; Return the last TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the nu",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:44304,Performance,optimiz,optimized,44304,"ast TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserial",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:47452,Performance,perform,performance,47452," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLon",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:47479,Performance,perform,performance,47479,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLong64(Long64_t& ll). void ReadULong64(ULong64_t& ll). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:37983,Safety,safe,safely,37983,"te object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< k",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:41868,Security,hash,hashtable,41868,"1); Add object to the fMap container.; If obj is not 0 add object to the map (in read mode also add 0 objects to; the map). This method may only be called outside this class just before; calling obj->Streamer() to prevent self reference of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:42053,Security,hash,hashtable,42053,"erence of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 c",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:42256,Security,hash,hashsize,42256," Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max); Read string from I/O buffer. String is read till 0 character is; found or till max-1 characters are read (i.e. string s has max; bytes allocated). If max = -1 no check on number of character is; made, reading continues till 0 character is found. void WriteString(const char* s); Write string to I/O buffer. Writes string upto and including the; terminating 0. TProcessID * GetLastProcess",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:47103,Security,hash,hashtable,47103,"Actions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* ",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:47288,Security,hash,hashtable,47288," pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLon",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferFile.html:47491,Security,hash,hashsize,47491,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLong64(Long64_t& ll). void ReadULong64(ULong64_t& ll). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t",MatchSource.WIKI,root/html532/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferFile.html
https://root.cern/root/html532/TBufferSQL.html:2808,Availability,error,error,2808,"Class*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html532/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL.html
https://root.cern/root/html532/TBufferSQL.html:2892,Availability,error,error,2892,"oidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessID*TBuffe",MatchSource.WIKI,root/html532/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL.html
https://root.cern/root/html532/TBufferSQL.html:19683,Modifiability,extend,extending,19683,"MaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int,allocator<int> >::iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Oper",MatchSource.WIKI,root/html532/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL.html
https://root.cern/root/html532/TBufferSQL.html:18830,Performance,cache,cache,18830,"amedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int,allocator<int> >::iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString",MatchSource.WIKI,root/html532/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL.html
https://root.cern/root/html532/TBufferSQL2.html:2870,Availability,error,error,2870,"const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::Get",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:2954,Availability,error,error,2954,"ssMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtua",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:21811,Modifiability,extend,extending,21811,"ng64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names ; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key ; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be ",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:26812,Modifiability,inherit,inherited,26812,"o correctly; convert class data to/from ""normal"" sql tables with meaningfull names; and correct datatypes. Without that functions data from custom streamer; will be saved as ""raw"" data in special _streamer_ table one value after another; Such MUST be used when object is written with standard ROOT streaming; procedure, but should be read back in custom streamer.; For example, custom streamer of TNamed class may look like:. void ClassEnd(const TClass* ); Method indicates end of streaming of classdata in custom streamer.; See ClassBegin() method for more details. void ClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); Method indicates name and typename of class memeber,; which should be now streamed in custom streamer; Following combinations are supported:; 1. name = ""ClassName"", typeName = 0 or typename==ClassName; This is a case, when data of parent class ""ClassName"" should be streamed.; For instance, if class directly inherited from TObject, custom; streamer should include following code:; b.ClassMember(""TObject"");; TObject::Streamer(b);; 2. Basic data type; b.ClassMember(""fInt"",""Int_t"");; b >> fInt;; 3. Array of basic data types; b.ClassMember(""fArr"",""Int_t"", 5);; b.ReadFastArray(fArr, 5);; 4. Object as data member; b.ClassMemeber(""fName"",""TString"");; fName.Streamer(b);; 5. Pointer on object as datamember; b.ClassMemeber(""fObj"",""TObject*"");; b.StreamObject(b);; arrsize1 and arrsize2 arguments (when specified) indicate first and; second dimension of array. Can be used for array of basic types.; For more details see ClassBegin() method description. void WorkWithClass(const char* classname, Version_t classversion); This function is a part of IncrementLevel method.; Also used in StartClass method. void WorkWithElement(TStreamerElement* elem, Int_t number); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray method",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:28700,Modifiability,variab,variable,28700,"lement(TStreamerElement* elem, Int_t number); This function is a part of SetStreamerElementNumber method.; It is introduced for reading of data for specified data memeber of class.; Used also in ReadFastArray methods to resolve problem of compressed data,; when several data memebers of the same basic type streamed with single ...FastArray call. TClass* ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); suppressed function of TBuffer. void WriteClass(const TClass* cl); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); suppressed function of TBuffer. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); suppressed function of TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); suppressed function of TBuffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer; actually version is normally defined by table name; and kept in intermediate variable fReadVersionBuffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have b",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:43907,Modifiability,variab,variable,43907,"value from table and convert it to Bool_t value. void SqlReadBasic(UChar_t& value); read current value from table and convert it to UChar_t value. void SqlReadBasic(UShort_t& value); read current value from table and convert it to UShort_t value. void SqlReadBasic(UInt_t& value); read current value from table and convert it to UInt_t value. void SqlReadBasic(ULong_t& value); read current value from table and convert it to ULong_t value. void SqlReadBasic(ULong64_t& value); read current value from table and convert it to ULong64_t value. const char* SqlReadValue(const char* tname); read string value from current stack node. const char* SqlReadCharStarValue(); read CharStar value, if it has special code, request it from large table. TSQLStructure* PushStack(); Push stack with structurual information about streamed object. TSQLStructure* PopStack(); Pop stack. TSQLStructure* Stack(Int_t depth = 0); returns head of stack. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e""; changes global TSQLServer variable. const char* GetFloatFormat(); return current printf format for float/double members, default ""%e""; return format, hold by TSQLServer. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. TBufferSQL2(const TBufferSQL2& ); TBufferSQL2 objects",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:20282,Performance,cache,cache,20282,"; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData! ; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value ; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names ; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key ; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buff",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:29736,Performance,optimiz,optimize,29736,"t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:30004,Performance,optimiz,optimize,30004,"ect from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t ",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:30297,Performance,optimiz,optimize,30297,"y used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& ",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:30569,Performance,optimiz,optimize,30569,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t ReadArray(Double_t*& d); R",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:24130,Safety,avoid,avoid,24130," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:417,Usability,simpl,simple,417,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeN",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:441,Usability,simpl,simple,441,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeN",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferSQL2.html:23687,Usability,simpl,simple,23687,"le.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferSQL2(); destroy sql buffer. TSQLStructure* SqlWriteAny(const void* obj, const TClass* cl, Long64_t objid); Convert object of any class to sql structures; Return pointer on created TSQLStructure; TSQLStructure object will be owned by TBufferSQL2. void* SqlReadAny(Long64_t keyid, Long64_t objid, TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name a",MatchSource.WIKI,root/html532/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferSQL2.html
https://root.cern/root/html532/TBufferXML.html:3409,Availability,error,error,3409,"E); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:3493,Availability,error,error,3493,"yout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25625,Deployability,configurat,configuration,25625,"ument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const voi",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25851,Deployability,configurat,configuration,25851,"rs; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to re",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:38687,Integrability,message,message,38687,"er. void ReadFastArray(UShort_t* h, Int_t n); read array of UShort_t from buffer. void ReadFastArray(Int_t* i, Int_t n); read array of Int_t from buffer. void ReadFastArray(UInt_t* i, Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:38886,Integrability,message,message,38886,"Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:41699,Integrability,message,message,41699,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:41873,Integrability,message,message,41873," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:24080,Modifiability,extend,extending,24080," reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode,",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25567,Modifiability,inherit,inherited,25567,"ument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const voi",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25625,Modifiability,config,configuration,25625,"ument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const voi",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25851,Modifiability,config,configuration,25851,"rs; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to re",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:26095,Modifiability,inherit,inherit,26095,"ize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:22821,Performance,cache,cache,22821,"; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TXMLSetup::EXMLLayout { kSpecialized; kGeneralized; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass()",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:34056,Performance,optimiz,optimize,34056," cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to xml; Version will be written with next I/O operation or; will be added as attribute of class tag, created by IncrementLevel call. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElem",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:34324,Performance,optimiz,optimize,34324," from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer; Actually skip only one node on current level of xml structure. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h)",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:34617,Performance,optimiz,optimize,34617,"adFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. In",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:34889,Performance,optimiz,optimize,34889,"the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& l); Read array of ULong_t from buffer. Int_t ReadArray(Long64_t*& l); Read array of Long64_t from buffer. Int_t ReadArray(ULong64_t*& l); Read array of ULong64_t from buffer. Int_t ReadArray(Float_t*& f); Read array of Float_t from buffer. Int_t Re",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:27040,Safety,avoid,avoid,27040,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negativ",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:38673,Safety,avoid,avoid,38673,"er. void ReadFastArray(UShort_t* h, Int_t n); read array of UShort_t from buffer. void ReadFastArray(Int_t* i, Int_t n); read array of Int_t from buffer. void ReadFastArray(UInt_t* i, Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:38872,Safety,avoid,avoid,38872,"Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:41681,Safety,avoid,avoid,41681,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:41855,Safety,avoid,avoid,41855," Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from buffer. void ReadUInt(UInt_t& i); Reads UInt_t value from buffer. void ReadLong(Long_t& l); Reads Long_t value from buffer. void ReadULong(ULong_t& l); Reads U",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:25372,Security,access,access,25372,"Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertT",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:422,Usability,simpl,simple,422,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. TBufferXML(TBuffer::EMode mode); TBufferXML(TBuffer::EMode mode, TXMLFile* file); virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassM",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:446,Usability,simpl,simple,446,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. TBufferXML(TBuffer::EMode mode); TBufferXML(TBuffer::EMode mode, TXMLFile* file); virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassM",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:19137,Usability,simpl,simple,19137,"heckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidTBufferFile::operator=(const TBufferFile&); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElement(TStreamerEle",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TBufferXML.html:27120,Usability,simpl,simple,27120,"ct class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates",MatchSource.WIKI,root/html532/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TBufferXML.html
https://root.cern/root/html532/TButton.html:7673,Availability,error,error,7673,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() con",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:7757,Availability,error,error,7757,"oidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:26611,Availability,down,down,26611,,MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:325,Integrability,interface,interface,325,". TButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TButton. class TButton: public TPad, public TAttText. A TButton object is a user interface object.; A TButton has a name and an associated action.; When the button is clicked with the left mouse button, the corresponding; action is executed.; A TButton can be created by direct invocation of the constructors; or via the graphics editor.; The action can be set via TButton::SetMethod.; The action can be any command. Examples of actions:; ""34+78"" When the button is clicked, the result of addition is printed.; "".x macro.C"" . Clicking the button executes the macro macro.C; The action can be modified at any time via TButton::SetMethod. To modify the layout/size/contents of one or several buttons; in a canvas, you must set the canvas editable via TCanvas::SetEditable.; By default a TCanvas is editable.; By default a TDialogCanvas is not editable.; TButtons are in general placed in a TDialogCanvas. A TButton being a TPad, one can draw graphics primitives in it; when the TCanvas/TDialogCanvas is editable. Example of a macro creating a dialogcanvas with buttons; void but() {; example of a dialogcanvas with a few buttons. TDialogCanvas *dialog = new TDialogCanvas(""dialog"","""",200,300);. Create first button. Clicking on this button will execute 34+56; TButton *but1 = new TButton(""button1"",""34+56"",.05,.8,.45,.88);; but1->Draw();. Create second button. Clicking on this button will create a new canvas; TButton *but2 = new TButton(""canvas"",""c2 = new TCanvas(\""c2\"")"",.55,.8,.95,.88);; but2->Draw();. Create third button. Clicking on this button will invoke the browser; but3 = new TButton(""Browser"",""br = new TBrowser(\""br\"")"",0.25,0.54,0.75,0.64);; but3->SetFillColor(42);; but3->Draw();. Create last button with no name. Instead a graph is draw insi",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:28191,Testability,log,log,28191,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarg",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:28248,Testability,log,log,28248,"2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TButton.html:28305,Testability,log,log,28305,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Short_tTAttText::fTextAlignT",MatchSource.WIKI,root/html532/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TButton.html
https://root.cern/root/html532/TCanvas.html:1862,Availability,avail,available,1862,"*************** *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * Pad 1 * * Pad 2 * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * ************************************ ************************* *; * *; ***********************************************************************. This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; moved, grown, shrinked using the normal rules of the Display manager. The image below shows a canvas with 4 pads:. Once objects have been drawn in a canvas, they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, the canvas size defines the size of the canvas window; (including the window manager's decoration). To define precisely the graphics; area size of a canvas, the following four lines of code should be used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. . Function Members (Methods); public:. TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:8179,Availability,error,error,8179,"har* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; TVirtualPad",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:8263,Availability,error,error,8263,"voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; TVirtualPadPainter*GetCanvasPainter(); virtual voidGetCanvasPar(Int_t& wtopx, Int_t& wtopy, UIn",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:28490,Availability,down,down,28490,,MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:37721,Availability,failure,failure,37721,"itle, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of th",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:40378,Availability,down,down,40378,"anvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Res",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:44036,Energy Efficiency,allocate,allocated,44036,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TC",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:39478,Integrability,depend,depending,39478,":; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = ",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:42358,Modifiability,variab,variable,42358,"cessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canv",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:44908,Modifiability,plugin,plugin,44908," case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelect",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:40863,Performance,response time,response time,40863,"dle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. v",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:41759,Performance,response time,response time,41759,"s drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:44888,Performance,load,loaded,44888," case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {return fSelectedX;}. Int_t GetSelectedY() const; {return fSelect",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:30767,Testability,log,log,30767,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:30824,Testability,log,log,30824,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:30881,Testability,log,log,30881,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:37905,Usability,clear,cleared,37905," ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu i",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCanvas.html:39974,Usability,feedback,feedback,39974,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root/html532/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCanvas.html
https://root.cern/root/html532/TCastorFile.html:1415,Availability,avail,available,1415,"ile path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:4272,Availability,error,error,4272,"e); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTNetFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOp",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:4356,Availability,error,error,4356," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTNetFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::G",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:25305,Availability,error,error,25305,"ue (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfAuthProtoUsed to specific the auth protocol; TStringfDiskServerCASTOR remote disk server; TStringfInternalPathCASTOR internal path; Bool_tfIsCastortrue if internal path is valid; Bool_tfWrittenTotrue if data has been written to file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TCastorFile. A TCastorFile is like a normal TNetFile except; that it obtains the remote node (disk server) via the CASTOR API, once; the disk server and the local file path are determined, the file will; be accessed via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root.; The other arguments are the same as for TNetFile and TFile. void FindServerAndPath(); Find the CASTOR disk server and internal file path. Int_t SysClose(Int_t fd); Close currently open file. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server on CASTOR disk server. TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); { fIsCastor = fWrittenTo = kFALSE; }. virtual ~TCastorFile(); { }. » Author: Fons Rademakers 17/09/2003 + Giulia Taurelli 29/06/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/castor:$Id: TCastorFile.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:1212,Integrability,protocol,protocol,1212,"members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncO",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:1405,Integrability,protocol,protocol,1405,"ile path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:1425,Integrability,protocol,protocols,1425,"ile path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:22001,Integrability,protocol,protocol,22001,e if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tTNetFile::fNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTNetFile::fProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*TNetFile::fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringTNetFile::fUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writabl,MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:24243,Integrability,protocol,protocol,24243," Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfAuthProtoUsed to specific the auth protocol; TStringfDiskServerCASTOR remote disk server; TStringfInternalPathCASTOR internal path; Bool_tfIsCastortrue if internal path is valid; Bool_tfWrittenTotrue if data has been written to file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TCastorFile. A TCastorFile is like a normal TNetFile except; that it obtains the remote node (disk server) via the CASTOR API, once; the disk server and the local file path are determined, the file will; be accessed via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root.; The other arguments are the same as for TNetFile and TFile. void FindServerAndPath(); Find the CASTOR disk server and internal file path. Int_t SysClose(Int_t fd); Close currently open file. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. void Con",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:12959,Performance,cache,cacheDir,12959,"al Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTNetFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:13086,Performance,cache,cache,13086," virtual Int_tTNetFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:13144,Performance,cache,cache,13144,"idTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:19786,Performance,cache,cache,19786,,MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:19858,Performance,cache,cache,19858,,MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:21750,Performance,cache,cache,21750,"ue if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tTNetFile::fNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTNetFile::fProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*TNetFile::fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirec",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:22079,Performance,cache,cache,22079,r of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tTNetFile::fNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTNetFile::fProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*TNetFile::fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringTNetFile::fUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirec,MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:23552,Performance,cache,cache,23552,"eekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*TNetFile::fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringTNetFile::fUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:23582,Performance,cache,cached,23582,"eekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*TNetFile::fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringTNetFile::fUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:14101,Safety,timeout,timeout,14101,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:501,Security,access,accessed,501,". TCastorFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Appen",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:1197,Security,authenticat,authentication,1197,"members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncO",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TCastorFile.html:24865,Security,access,accessed,24865,"file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfAuthProtoUsed to specific the auth protocol; TStringfDiskServerCASTOR remote disk server; TStringfInternalPathCASTOR internal path; Bool_tfIsCastortrue if internal path is valid; Bool_tfWrittenTotrue if data has been written to file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TCastorFile. A TCastorFile is like a normal TNetFile except; that it obtains the remote node (disk server) via the CASTOR API, once; the disk server and the local file path are determined, the file will; be accessed via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root.; The other arguments are the same as for TNetFile and TFile. void FindServerAndPath(); Find the CASTOR disk server and internal file path. Int_t SysClose(Int_t fd); Close currently open file. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server on CASTOR disk server. TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); { fIsCastor = fWrittenTo = kFALSE; }. virtual ~TCastorFile(); { }. » Author: Fons Rademakers 17/09/2003 + Giulia Taurelli 29/06/2006 » Copyright (C) 1995-2006, Rene Brun and Fo",MatchSource.WIKI,root/html532/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCastorFile.html
https://root.cern/root/html532/TChain.html:5203,Availability,error,error,5203,"p1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const;",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:5287,Availability,error,error,5287,"tive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tTTree::Get",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:35890,Availability,error,error,35890," closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator ",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:36327,Availability,error,error,36327,"being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the of",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:37593,Availability,failure,failure,37593,"t; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the curren",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:38773,Availability,failure,failure,38773,"try list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadT",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:39984,Availability,error,error,39984,"t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:45732,Availability,error,error,45732," check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in general the automatic file overflow described; above may happen during the merge.; If only the current file is produced (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(void* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made usi",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:46010,Availability,error,error,46010," (the file passed as first argument),; one can instruct Merge to not close and delete the file by specifying; the option ""keep"". The function returns the total number of files produced.; To check that all files have been merged use something like:; if (newchain->GetEntries()!=oldchain->GetEntries()) {; ... not all the file have been copied ...; }. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(void* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more detai",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:48972,Availability,error,error,48972,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:50103,Availability,error,error,50103,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:16681,Deployability,update,updateExisting,16681,"00); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerC",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:24521,Energy Efficiency,allocate,allocated,24521,"entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; In",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:29151,Energy Efficiency,efficient,efficient,29151,"name are optional. If tree_name is missing,; the chain name will be assumed.; In the file name part (but not in preceding directories) wildcarding; notation may be used, eg. specifying ""xxx*.root"" adds all files starting; with xxx in the current file system directory.; NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:31481,Energy Efficiency,efficient,efficient,31481," return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. If tname is specified, the chain will load the tree named tname; from the file, otherwise the original treename specified in the; TChain constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that if one calls GetEntriesFast() after having created; a chain with this default, GetEntriesFast() will return kBigNumber!; Using the GetEntries() function instead will force all of the tree; headers in the chain to be read to read the number of entries in; each tree. D. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns 1 if the file is successfully",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:38717,Integrability,rout,routine,38717,"set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and ",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:40358,Integrability,rout,routine,40358," tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.M",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:41106,Integrability,rout,routine,41106,"e requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So in a case where we have:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will have not subdirectory. To recreate; the directory structure do:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is s",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:42601,Integrability,rout,routine,42601,"nfo); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _l",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:48978,Integrability,message,message,48978,"c of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); -- Set branch status to Process or DoNotProcess. bname is the name of a branch. if bname=""*"", apply to all branches.; status = 1 branch will be processed; = 0 branch will not be processed; See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of ent",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:26083,Modifiability,variab,variables,26083,"hen going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:27296,Modifiability,variab,variable,27296,"weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(""f3.root"");; ch.Draw(""x"");; The Draw function above will process the variable ""x"" in Tree ""T""; reading sequentially the 3 files in the chain ch. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. ~TChain(); -- Destructor. Int_t Add(TChain* chain); -- Add all files referenced by the passed chain to this chain.; The function returns the total number of files connected. Int_t Add(const char* name, Long64_t nentries = kBigNumber); -- Add a new file to this chain. Argument name may have the following format:; //machine/file_name.root/subdir/tree_name; machine, subdir and tree_name are optional. If tree_name is missing,; the chain name will be assumed.; In the file name part (but not in preceding directories) wildcarding; not",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:33578,Modifiability,variab,variable,33578," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:33809,Modifiability,variab,variable,33809,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:33858,Modifiability,variab,variable,33858,"dElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the c",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:33968,Modifiability,variab,variable,33968,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:34008,Modifiability,variab,variable,34008,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:34040,Modifiability,variab,variable,34040,"iend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* chainname, TFile* dummy); -- Add the whole chain or tree as a friend of this chain. TFriendElement* AddFriend(TTree* chain, const char* alias = """", Bool_t warn = kFALSE); -- Add the whole chain or tree as a friend of this chain. void Browse(TBrowser* ); -- Browse the contents of the chain. void CanDeleteRefs(Bool_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" i",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:16393,Performance,cache,cachesize,16393,"st char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribut",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:25006,Performance,load,loading,25006,"e_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryL",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:30724,Performance,load,load,30724,"ame of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. If tname is specified, the chain will load the tree named tname; from the file, otherwise the original treename specified in the; TChain constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that i",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:37823,Performance,load,loads,37823," branchname) const; -- See TTree::GetReadEntry(). TTree::TClusterIterator GetClusterIterator(Long64_t firstentry); Return an iterator over the cluster of baskets starting at firstentry. This iterator is not yet supported for TChain object. Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The input parameter entry is the entry number in; the current tree of this chain. Long64_t GetEntries() const; -- Return the total number of entries in the chain.; In case the number of entries in each tree is not yet known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 o",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:38352,Performance,load,loaded,38352,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. ",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:39628,Performance,load,load,39628,"t of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:43697,Performance,optimiz,optimize,43697,"ure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only don",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:43893,Performance,perform,performance,43893,"'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only done in between each; input file. IMPORTANT Note 2: The output file is automatically closed and deleted. This is required because in genera",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:46908,Performance,load,loads,46908," return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comm",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:49979,Performance,load,loads,49979,"nown branch'; is suppressed. void SetDirectory(TDirectory* dir); Remove reference to this chain from current directory and add; reference to new directory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned b",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:50178,Performance,load,loaded,50178,"irectory dir. dir can be 0 in which case the chain; does not belong to any directory. void SetEntryList(TEntryList* elist, Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list); This function finds correspondance between the sub-lists of the TEntryList; and the trees of the TChain; By default (opt=""""), both the file names of the chain elements and; the file names of the TEntryList sublists are expanded to full path name.; If opt = ""ne"", the file names are taken as they are and not expanded. void SetEntryListFile(const char* filename = """", Option_t* opt = """"); Set the input entry list (processing the entries of the chain will then be; limited to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() functi",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:50797,Performance,load,loads,50797,"to the entries in the list). This function creates a special kind; of entry list (TEntryListFromFile object) that loads lists, corresponding; to the chain elements, one by one, so that only one list is in memory at a time. If there is an error opening one of the files, this file is skipped and the; next file is loaded. File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken. It is assumed, that there are as many list files, as there are elements in; the chain and they are in the same order. void SetEventList(TEventList* evlist); This function transfroms the given TEventList into a TEntryList. NOTE, that this function loads all tree headers, because the entry numbers; in the TEventList are global and have to be recomputed, taking into account; the number of entries in each tree. The new TEntryList is owned by the TChain and gets deleted when the chain; is deleted. This TEntryList is returned by GetEntryList() function, and after; GetEntryList() function is called, the TEntryList is not owned by the chain; any more and will not be deleted with it. void SetPacketSize(Int_t size = 100); -- Set number of entries per packet for parallel root. void SetProof(Bool_t on = kTRUE, Bool_t refresh = kFALSE, Bool_t gettreeheader = kFALSE); Enable/Disable PROOF processing on the current default Proof (gProof). ""Draw"" and ""Processed"" commands will be handled by PROOF.; The refresh and gettreeheader are meaningfull only if on == kTRUE.; If refresh is kTRUE the underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used wit",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:52610,Performance,cache,cache,52610,"nderlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& b); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}. » Author: Rene Brun 03/02/97 » Copyright",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:33564,Security,access,access,33564," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:42342,Testability,test,test,42342,"E"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are wri",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChain.html:3699,Usability,undo,undo,3699,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root/html532/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChain.html
https://root.cern/root/html532/TChainElement.html:1465,Availability,error,error,1465,"itle, const char* filename); virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const",MatchSource.WIKI,root/html532/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainElement.html
https://root.cern/root/html532/TChainElement.html:1549,Availability,error,error,1549,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const; virtual Int_tGetPacketSize() const; virtual Int_tGetStatus() const; virtual const ",MatchSource.WIKI,root/html532/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainElement.html
https://root.cern/root/html532/TChainElement.html:6586,Deployability,update,updated,6586,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kHasBeenLookedUp; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassN",MatchSource.WIKI,root/html532/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainElement.html
https://root.cern/root/html532/TChainElement.html:6599,Performance,load,loading,6599,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kHasBeenLookedUp; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassN",MatchSource.WIKI,root/html532/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainElement.html
https://root.cern/root/html532/TChainIndex.html:1487,Availability,error,error,1487,"ChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual ",MatchSource.WIKI,root/html532/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainIndex.html
https://root.cern/root/html532/TChainIndex.html:1571,Availability,error,error,1571,"end(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, In",MatchSource.WIKI,root/html532/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainIndex.html
https://root.cern/root/html532/TChainIndex.html:7945,Deployability,release,released,7945,"ainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Int_t major, Int_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const ",MatchSource.WIKI,root/html532/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChainIndex.html
https://root.cern/root/html532/TChair.html:2135,Availability,error,error,2135,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; v",MatchSource.WIKI,root/html532/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChair.html
https://root.cern/root/html532/TChair.html:2219,Availability,error,error,2219,"onst; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChair.html
https://root.cern/root/html532/TChair.html:327,Integrability,interface,interface,327,". TChair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TChair. class TChair: public TDataSet. TChair. It is a base class to create a custom interface for TTable objects. Function Members (Methods); public:. TChair(TTable* table); TChair(const TChair& org); virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObj",MatchSource.WIKI,root/html532/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChair.html
https://root.cern/root/html532/TChair.html:10972,Testability,assert,assert,10972,"ointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() c",MatchSource.WIKI,root/html532/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChair.html
https://root.cern/root/html532/TChair.html:10998,Testability,assert,assert,10998,"fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() const; {return (Char_t *)GetThisTable()->GetArray();}",MatchSource.WIKI,root/html532/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TChair.html
https://root.cern/root/html532/TCint.html:1604,Availability,error,error,1604,"ncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); static intAutoLoadCallback(const char* cls, const char* lib); virtual voidBaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t* info) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void* func) const; virtual voidCallFunc_Exec(CallFunc_t* func, void* address) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t* func, void* address) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t* func) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t* func) const; virtual voidCallFunc_Init(CallFunc_t* func) const; virtual boolCallFunc_IsValid(CallFunc_t* func) const; virtual voidCallFunc_ResetArg(CallFunc_t* func) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Long_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Double_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Long64_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; virtual voidCallFunc_SetArgArray(CallFunc_t*",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:7699,Availability,error,error,7699,"rtual Long_tDataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*Get",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:7802,Availability,error,error,7802,"Size(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:7901,Availability,error,error,7901,"_t* dminfo) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGet",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:8056,Availability,error,error,8056,"U ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:8610,Availability,error,error,8610,"ar* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* method, const char* params); virtual void*GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); virtual const char*GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); virtual TStringGetMangledName(TClass* cl, const char* method, const char* params); virtual TStringGetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto); virtual TEnv*GetMapfile() const; virtual Int_tGetMore() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) cons",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:11202,Availability,error,error,11202,"Named::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Int_tInitializeDictionaries(); virtual voidTObject::Inspect() constMENU ; static TInterpreter*&TInterpreter::Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsErrorMessagesEnabled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsLoaded(const char* filename) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsProcessLineLocked() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* filenam, Bool_t system = kFALSE); virtual intLoadFile(const char* path) const; virtual Int_tLoadLibraryMap(const char* rootmapfile = 0); virtual voidLoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidLoadText(const char* text) const; virtual voidTNamed::ls(Option_t* option = """") const; virtual const char*MapCppName(const char*) const; voidTObject::MayNotUse(const char* method) const; virtual const char*MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const; virtual voidMethodArgInfo_Delete(MethodArgInfo_t* marginfo) const; virtual MethodArgInfo_t*MethodArgInfo_Factory() const; virtual MethodArgInfo_t*MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const; virtual boolMethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const; virtual const char*MethodArgInfo_Name(MethodArgInfo_t* marginfo) const; virtual intMethodArgInfo_Next(MethodArgInfo_t* marginfo) const; virtual Long_tMethodArgInfo_Property(MethodArgInfo_t* marginfo) const; virtual const char*MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const; virtual voidMethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; virtual voidMethodInfo_Delete(MethodInfo_t* minfo) const; virtual Me",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:13846,Availability,error,error,13846,"dInfo_Property(MethodInfo_t* minfo) const; virtual const char*MethodInfo_Title(MethodInfo_t* minfo) const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t* minfo) const; virtual const char*MethodInfo_TypeName(MethodInfo_t* minfo) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Long_tProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:13926,Availability,error,error,13926,"ethodInfo_t* minfo) const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t* minfo) const; virtual const char*MethodInfo_TypeName(MethodInfo_t* minfo) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Long_tProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:14013,Availability,error,error,14013,"t; virtual const char*MethodInfo_TypeName(MethodInfo_t* minfo) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Long_tProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetErrmsgcallback(void* p) c",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20826,Availability,error,error,20826,"nterpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20937,Availability,error,error,20937,"tly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from C",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:21249,Availability,error,error,21249,"es when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state s",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:21369,Availability,error,error,21369,"pically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:21525,Availability,error,error,21525,"aded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; th",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:26104,Availability,error,error,26104," will be searched. void * GetInterfaceMethod(TClass* cl, const char* method, const char* params); Return pointer to CINT interface function for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of the currently interpreted file,; included or not. Example to illustrate the difference between; GetCurrentMacroName() and GetTopLevelMacroName():. ; inclfile.h. #include <iostream>; void inclfunc() {; std::cout << ""In inclfile.h"" << std::endl;",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:26249,Availability,error,error,26249,"ion for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of the currently interpreted file,; included or not. Example to illustrate the difference between; GetCurrentMacroName() and GetTopLevelMacroName():. ; inclfile.h. #include <iostream>; void inclfunc() {; std::cout << ""In inclfile.h"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLev",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:26395,Availability,error,error,26395,"e searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of the currently interpreted file,; included or not. Example to illustrate the difference between; GetCurrentMacroName() and GetTopLevelMacroName():. ; inclfile.h. #include <iostream>; void inclfunc() {; std::cout << ""In inclfile.h"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; }. mymacro.C. #include <iostream>; #include ""inclfile.h""; void mymacro() {; std::cout <<",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:26602,Availability,error,error,26602," prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of the currently interpreted file,; included or not. Example to illustrate the difference between; GetCurrentMacroName() and GetTopLevelMacroName():. ; inclfile.h. #include <iostream>; void inclfunc() {; std::cout << ""In inclfile.h"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; }. mymacro.C. #include <iostream>; #include ""inclfile.h""; void mymacro() {; std::cout << ""In mymacro.C"" << std::endl;; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() return",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:28418,Availability,error,error,28418,";; std::cout << "" TCint::GetCurrentMacroName() returns "" <<; TCint::GetCurrentMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char*",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:28841,Availability,error,error,28841,"urns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static funct",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:29041,Availability,error,error,29041,"typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:29508,Availability,error,error,29508," library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared librarie",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:29661,Availability,error,error,29661,"r library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31105,Availability,error,error,31105,"ing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT f",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31171,Availability,failure,failures,31171,"ing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT f",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31265,Availability,error,error,31265,"t char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31331,Availability,failure,failures,31331,"t char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:32105,Availability,error,error,32105," messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* receiver) const; Interface to CINT function. int GetSecurityError() const; Interface to CINT function. int LoadFile(const char* path) const; Interface to CINT function. void LoadText(const char* text) const; Interface to CINT function. const char * MapCppName(const char* ) const; Interface to CINT function. void SetAlloclockfunc(void (*)() ) const; Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int Unl",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:30188,Deployability,update,update,30188," Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:303,Integrability,interface,interface,303,". TCint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TCint. class TCint: public TInterpreter. This class defines an interface to the CINT C/C++ interpreter made; by Masaharu Goto from HP Japan. CINT is an almost full ANSI compliant C/C++ interpreter. Function Members (Methods); public:. TCint(const char* name, const char* title); virtual~TCint(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); static intAutoLoadCallback(const char* cls, const char* lib); virtual voidBaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t* info) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void* func) const; virtual voidCallFunc_Exec(CallFunc_t* func, void* address) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t* func, void* address) const; virtual CallFunc_t*CallFunc_Factory() const; virtual",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19778,Integrability,interface,interface,19778,"itleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, t",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19828,Integrability,interface,interface,19828,"init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter:",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20458,Integrability,synchroniz,synchronize,20458," by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:21703,Integrability,message,message,21703,"ibrary file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:25224,Integrability,interface,interface,25224," for the C++ classes listed in the first; argmument (in a semi-colon separated list).; 'includes' contains a semi-colon separated list of file to; #include in the dictionary.; For example:; gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; or; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. TString GetMangledName(TClass* cl, const char* method, const char* params); Return the CINT mangled name for a method of a class with parameters; params (params is a string of actual arguments, not formal ones). If the; class is 0 the global function list will be searched. TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto); Return the CINT mangled name for a method of a class with a certain; prototype, i.e. ""char*,int,float"". If the class is 0 the global function; list will be searched. void * GetInterfaceMethod(TClass* cl, const char* method, const char* params); Return pointer to CINT interface function for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:25526,Integrability,interface,interface,25526,"""list;vector"");; or; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");. TString GetMangledName(TClass* cl, const char* method, const char* params); Return the CINT mangled name for a method of a class with parameters; params (params is a string of actual arguments, not formal ones). If the; class is 0 the global function list will be searched. TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto); Return the CINT mangled name for a method of a class with a certain; prototype, i.e. ""char*,int,float"". If the class is 0 the global function; list will be searched. void * GetInterfaceMethod(TClass* cl, const char* method, const char* params); Return pointer to CINT interface function for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = arra",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:25921,Integrability,synchroniz,synchronize,25921,"ched. TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto); Return the CINT mangled name for a method of a class with a certain; prototype, i.e. ""char*,int,float"". If the class is 0 the global function; list will be searched. void * GetInterfaceMethod(TClass* cl, const char* method, const char* params); Return pointer to CINT interface function for a method of a class with; parameters params (params is a string of actual arguments, not formal; ones). If the class is 0 the global function list will be searched. void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); Return pointer to CINT interface function for a method of a class with; a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; function list will be searched. const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); The 'name' is known to the interpreter, this function returns; the internal version of this name (usually just resolving typedefs); This is used in particular to synchronize between the name used; by rootcint and by the run-time enviroment (TClass); Return 0 if the name is not known. void Execute(const char* function, const char* params, int* error = 0); Execute a global function with arguments params. void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); Execute a method from class cl with arguments params. void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); Execute a method from class cl with the arguments in array params; (params[0] ... params[n] = array of TObjString parameters). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Execute a CINT macro. const char * GetTopLevelMacroName() const; Return the file name of the current un-included interpreted file.; See the documentation for GetCurrentMacroName(). const char * GetCurrentMacroName() const; Return the file name of t",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:30756,Integrability,depend,depends,30756,"ecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpr",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:30913,Integrability,depend,depends,30913,".; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout,",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31049,Integrability,depend,dependencies,31049,"name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(co",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31111,Integrability,message,messages,31111,"ing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT f",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31192,Integrability,message,messages,31192,"ing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT f",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31271,Integrability,message,messages,31271,"t char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:31352,Integrability,message,messages,31352,"t char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19600,Modifiability,variab,variables,19600," TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; info",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:22997,Modifiability,variab,variables,22997,"ymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers to base class(es) for TClass cl. void CreateListOfDataMembers(TClass* cl); Create list of pointers to data members for TClass cl. void CreateListOfMethods(TClass* cl); Create list of pointers to methods for TClass cl. void UpdateListOfMethods(TClass* cl); Update the list of point",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19327,Performance,load,loaded,19327," TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; info",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19366,Performance,load,load,19366," TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; info",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19385,Performance,load,loading,19385," TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; info",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:19451,Performance,load,loaded,19451," TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; info",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20214,Performance,load,loading,20214,"Prompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20292,Performance,load,loaded,20292,"Prompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:20599,Performance,load,loaded,20599,"pecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an execut",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:28498,Performance,load,load,28498,"ntMacroName() << std::endl;; std::cout << "" TCint::GetTopLevelMacroName() returns "" <<; TCint::GetTopLevelMacroName() << std::endl;; std::cout << "" Now calling inclfunc..."" << std::endl;; inclfunc();; }. Running mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:28698,Performance,load,loaded,28698,"ning mymacro.C will print:. root [0] .x mymacro.C; In mymacro.C; TCint::GetCurrentMacroName() returns ./mymacro.C; TCint::GetTopLevelMacroName() returns ./mymacro.C; Now calling inclfunc...; In inclfile.h; TCint::GetCurrentMacroName() returns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecial",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:28963,Performance,load,loaded,28963,"ns inclfile.h; TCint::GetTopLevelMacroName() returns ./mymacro.C. const char * TypeName(const char* typeDesc); Return the absolute type of typeDesc.; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This funct",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:29163,Performance,load,loaded,29163,"**"", returns ""TNamed"".; You need to use the result immediately before it is being overwritten. Int_t LoadLibraryMap(const char* rootmapfile = 0); Load map between class and library. If rootmapfile is specified a; specific rootmap file can be added (typically used by ACLiC).; In case of error -1 is returned, 0 otherwise.; Cint uses this information to automatically load the shared library; for a class (autoload mechanism).; See also the AutoLoadCallback() method below. Int_t RescanLibraryMap(); Scan again along the dynamic path for library maps. Entries for the loaded; shared libraries are unloaded first. This can be useful after reseting; the dynamic path through TSystem::SetDynamicPath(); In case of error -1 is returned, 0 otherwise. Int_t ReloadAllSharedLibraryMaps(); Reload the library map entries coming from all the loaded shared libraries,; after first unloading the current ones.; In case of error -1 is returned, 0 otherwise. Int_t UnloadAllSharedLibraryMaps(); Unload the library map entries coming from all the loaded shared libraries.; Returns 0 if succesful. Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCint.html:22721,Security,access,accessed,22721,"ction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers ",MatchSource.WIKI,root/html532/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCint.html
https://root.cern/root/html532/TCL.html:945,Integrability,interface,interface,945,". TCL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TCL. class TCL. The set of methods to work with the plain matrix / vector; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f110/top.html; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f112/top.html. Revision 1.7 2006/05/21 18:05:26 brun; Fix more coding conventions violations. Revision 1.6 2006/05/20 14:06:09 brun; Fix a VERY long list of coding conventions violations. Revision 1.5 2003/09/30 09:52:49 brun; Add references to the original CERNLIB packages. Revision 1.4 2003/05/28 15:17:03 brun; From Valeri Fine. A new version of the table package.; It fixes a couple of memory leaks:; class TTableDescriptorm; class TVolumePosition; and provides some clean up; for the TCL class interface. Revision 1.3 2003/04/03 17:39:39 fine; Make merge with ROOT 3.05.03 and add TR package; 122; Revision 1.2 2003/02/04 23:35:20 fine; Clean up. Revision 1.1 2002/04/15 20:23:39 fine; NEw naming schema for RootKErnel classes and a set of classes to back geometry OO. Revision 1.2 2001/05/29 19:08:08 brun; New version of some STAR classes from Valery. Revision 1.2 2001/05/27 02:38:14 fine; New method trsedu to solev Ax=B from Victor. Revision 1.1.1.1 2000/11/27 22:57:14 fisyak. Revision 1.1.1.1 2000/05/16 17:00:48 rdm; Initial import of ROOT into CVS. Function Members (Methods); public:. TCL(); TCL(const TCL&); virtual~TCL(); static TClass*Class(); virtual TClass*IsA() const; static float*mxmad(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad1(const float* a, const float* q, float* c, int i, int j, int k); static double*mxmad1(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad2(con",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:14238,Modifiability,variab,variables,14238,"inal documentation of CERNLIB package F112. double * trasat(const double* a, const double* s, double* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .V",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:14358,Modifiability,variab,variables,14358,"Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(cons",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:15101,Modifiability,variab,variables,15101,"112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation ",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:15588,Modifiability,variab,variables,15588,"age F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see origina",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:15761,Modifiability,variab,variables,15761,"1204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROG",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:15884,Modifiability,variab,variables,15884,"* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .VERSION KERNFOR 2.08 741218; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trata(const double* a, double* r, int m, int n). ; see original documentation of CERNLIB package F112. double * trats(const double* a, const double* s, double* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trchlu(const double* a, double* b, int n); trchlu.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. Local variables. double * trchul(const double* a, double* b, int n). ; see original documentation of CERNLIB package F112. Local variables. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. L",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TCL.html:16891,Modifiability,variab,variables,16891,"s. double * trinv(const double* t, double* s, int n); trinv.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRINV .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trlta(const double* u, const double* a, double* b, int m, int n); trlta.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRLTA .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. double * trqsq(const double* q, const double* s, double* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. double * trsa(const double* s, const double* a, double* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. double * trsat(const double* s, const double* a, double* b, int m, int n); trsat.F -- translated by f2c (version 19970219); CERN PROGLIB# F112 TRSAT .VERSION KERNFOR 4.15 861204; ORIG. 18/12/74 WH. ; see original documentation of CERNLIB package F112. float * trsequ(float* smx, int m = 3, float* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). double * trsequ(double* smx, int m = 3, double* b = 0, int n = 1); Linear Equations, Matrix Inversion; trsequ solves the matrix equation. SMX*x = B. which represents a system of m simultaneous linear equations with n right-hand sides:; SMX is an unpacked symmetric matrix (all elements) (m x m); B is an unpacked matrix of right-hand sides (n x m). float * mxmad(const float* a, const float* b",MatchSource.WIKI,root/html532/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCL.html
https://root.cern/root/html532/TClass.html:3236,Availability,error,error,3236,"t char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:3320,Availability,error,error,3320," virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t lo",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:19816,Availability,error,error,19816,"ect contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:34869,Availability,down,down,34869,"is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:35016,Availability,down,down,35016,"called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its a",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:20986,Deployability,update,updated,20986,"or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:39837,Deployability,install,installs,39837,"one after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written b",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:35114,Energy Efficiency,allocate,allocated,35114,"rom TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:36089,Energy Efficiency,allocate,allocated,36089,"efConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0:",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:36339,Energy Efficiency,allocate,allocated,36339,"ed by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassT",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:36613,Energy Efficiency,allocate,allocated,36613,"otIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should us",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:38913,Energy Efficiency,efficient,efficiently,38913,"fer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:14806,Integrability,interface,interface,14806,"ew; };; enum { kLoading; kDefault; kEmulated; kTObject; kInstrumented; kForeign; kExternal; };; enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtu",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:18143,Integrability,interface,interface,18143,"VirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const c",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27084,Integrability,wrap,wrapper,27084,"nheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncP",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:29113,Integrability,depend,depends,29113,"generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfDataMembers(); Return list containing the TDataMembers of a class. TList * GetListOfMethods(); Return list containing the TMethods of a class. TList * GetListOfAllPublicMethods(); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(); Returns a list of all public data members of this class and its base; c",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:32519,Integrability,interface,interface,32519,"'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod * GetMethodWithPrototype(const char* method, const char* proto); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global varia",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:37248,Integrability,interface,interface,37248,"wType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TOb",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:44854,Integrability,wrap,wrapper,44854,"st TClass* onfile_class) const; Case of TObjects when fIsOffsetStreamerSet is known to have been set. void StreamerTObjectEmulated(void* object, TBuffer& b, const TClass* onfile_class) const; Case of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:44973,Integrability,wrap,wrapper,44973,"t. void StreamerTObjectEmulated(void* object, TBuffer& b, const TClass* onfile_class) const; Case of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find th",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45075,Integrability,wrap,wrapper,45075," of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * Fin",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45161,Integrability,wrap,wrapper,45161,"id* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45248,Integrability,wrap,wrapper,45248,"ass with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45331,Integrability,wrap,wrapper,45331,"onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerI",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45427,Integrability,wrap,wrapper,45427,"; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45521,Integrability,wrap,wrapper,45521,"oid* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45627,Integrability,wrap,wrapper,45627," way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVi",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47207,Integrability,wrap,wrapper,47207,"treamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * Ge",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47296,Integrability,wrap,wrapper,47296,"sion) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() con",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47361,Integrability,wrap,wrapper,47361,"on number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClass",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47444,Integrability,wrap,wrapper,47444,"StreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47522,Integrability,wrap,wrapper,47522,"treamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() c",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47609,Integrability,wrap,wrapper,47609,"s, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFil",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47695,Integrability,wrap,wrapper,47695,"name, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstan",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47785,Integrability,wrap,wrapper,47785,"the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOn",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:22047,Modifiability,inherit,inherited,22047,"eparated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adj",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:22090,Modifiability,inherit,inheritance,22090,"wner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMemb",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:24086,Modifiability,inherit,inheritance,24086,"od of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(void* obj, TMemberInspector& insp, Int_t isATObject = -1) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; ionterpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(void* obj) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:24123,Modifiability,inherit,inherits,24123,"ector& insp, Int_t isATObject = -1) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; ionterpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in class A with a blue line; erasing the corresponding member function. void Dump(void* obj) const; Dump contents of object on stdout.; Using the information in the object dictionary; each data member is interpreted.; If a data member is a pointer, the pointer value is printed; 'obj' is assume to point to an object of the class describe by this TClass. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. char * EscapeChars(const char* text) const; Introduce an escape character (@) in front of a s",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:26096,Modifiability,inherit,inheritance,26096,"(const char* text) const; Introduce an escape character (@) in front of a special chars.; You need to use the result immediately before it is being overwritten. TClass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrappe",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:26259,Modifiability,inherit,inheritance,26259,"lass * GetActualClass(const void* object) const; Return a pointer the the real class of the object.; This is equivalent to object->IsA() when the class has a ClassDef.; It is REQUIRED that object is coming from a proper pointer to the; class represented by 'this'.; Example: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:26532,Modifiability,inherit,inheritance,26532,"e: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; TObject *obj = (TObject*)((void*)myobject)directory->Get(""some object of MyClass"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the ro",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:26711,Modifiability,inherit,inheritance,26711,"ss"");; MyClass::Class()->GetActualClass(obj); // this would be wrong!!!; Also if the class represented by 'this' and NONE of its parents classes; have a virtual ptr table, the result will be 'this' and NOT the actual; class. TClass * GetBaseClass(const char* classname); Return pointer to the base class ""classname"". Returns 0 in case; ""classname"" is not a base class. Takes care of multiple inheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case clas",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:33488,Modifiability,variab,variable,33488,"ook for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:33538,Modifiability,variab,variable,33538,"ook for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:34420,Modifiability,inherit,inherits,34420,"o, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:34614,Modifiability,inherit,inherits,34614,"d IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); /",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:38253,Modifiability,inherit,inherits,38253,"tClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class i",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:38558,Modifiability,inherit,inherit,38558,"ransient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmu",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:38641,Modifiability,inherit,inherits,38641,". void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the st",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:39064,Modifiability,inherit,inherits,39064,"ct and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:39144,Modifiability,inherit,inheritance,39144,"ct and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:39270,Modifiability,inherit,inherits,39270,"ct and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:644,Performance,load,load,644,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); voidAddRef(TClassRef* ref); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t is",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:4225,Performance,load,load,4225,", Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:4321,Performance,load,load,4321,"or = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirector",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:15003,Performance,cache,cached,15003,"nup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; TMethodCall*fIsAMethod!saved info to call a IsA member function; Bool_tfIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; void*fMergepointer to a function implementing Mergin",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:17185,Performance,cache,cached,17185,"amer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; Long_tfProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; TClassRef*fRefStart!List of references to this object; void*fResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; G__p2memfuncfStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; No",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:19785,Performance,load,loaded,19785,"dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; s",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27298,Performance,load,load,27298,"n data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Lo",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27412,Performance,load,load,27412,"d the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27467,Performance,load,loading,27467,"d the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27896,Performance,load,load,27896,"scribinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built.",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:28047,Performance,load,loading,28047,"ny). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in t",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:28169,Performance,load,loading,28169,"ber function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:33290,Performance,load,loaded,33290,"nst char* proto); Find the method with a given prototype. The proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; t",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:33341,Performance,load,loaded,33341,"e proto string must be of the; form: ""char*,int,double"". Returns 0 in case method is not found. TMethod * GetClassMethod(Long_t faddr); Look for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e.",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:33435,Performance,optimiz,optimizes,33435,"ook for a method in this class that has the interface function; address faddr. TMethod * GetClassMethod(const char* name, const char* signature); Look for a method in this class that has the name and; signature. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object doest not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:38991,Performance,cache,cache,38991,"rn true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:49455,Performance,perform,performance,49455,"t_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClass.h 39694 2011-06-13 21:10:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:40438,Safety,safe,safe,40438,"the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetCheckSum(UInt_t code = 0) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is bu",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:3606,Security,checksum,checksum,3606,"ay(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version)",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:3703,Security,checksum,checksum,3703,"tual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) co",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:3889,Security,checksum,checksum,3889,"n_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLi",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:12296,Security,checksum,checksum,12296,"virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp); Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer& b); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; static THashTable*GetClassShortTypedefHash(); voidTObject::MakeZombie(). private:. TClass(const TClass& tc); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* base); TMethod*GetClassMethod(Long_t faddr); TMethod*GetClassMethod(const char* name, const char* signature); static ROOT::TMapTypeToTClass*GetIdMap(); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version); voidStreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; voidStreamerExternal(void* object, TBuffer& b, const TClass* onfile_class) const; voidStreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; voidStreamerStreamerInfo(void* object, TBuffer& b, const TClas",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:18252,Security,access,access,18252,"nfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the fu",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:20024,Security,checksum,checksum,20024,"sion_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separat",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:20267,Security,checksum,checksum,20267,"ss. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimite",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:21246,Security,checksum,checksum,21246,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TCl",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:21285,Security,checksum,checksums,21285,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TCl",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:23046,Security,access,access,23046,"rom TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(void* obj, TMemberInspector& insp, Int_t isATObject = -1) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; ionterpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:27092,Security,access,accessor,27092,"nheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncP",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:30254,Security,access,accessible,30254,") of a class. TList * GetListOfDataMembers(); Return list containing the TDataMembers of a class. TList * GetListOfMethods(); Return list containing the TMethods of a class. TList * GetListOfAllPublicMethods(); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void RemoveRef(TClassRef* ref); Unregister the TClassRef object. void ReplaceWith(TClass* newcl, Bool_t recurse = kTRUE) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, correspondi",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:31113,Security,access,accessible,31113,"ta members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void RemoveRef(TClassRef* ref); Unregister the TClassRef object. void ReplaceWith(TClass* newcl, Bool_t recurse = kTRUE) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMe",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:37578,Security,checksum,checksum,37578,":IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)p",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:41652,Security,checksum,checksum,41652,"tualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetCheckSum(UInt_t code = 0) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Algorithm from Victor Perevovchikov (perev@bnl.gov). if code==1 data members of type enum are not counted in the checksum; if code==2 return the checksum of data members and base classes, not including the ranges and array size found in comments.; This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBuffer(TBuffer& b, void* pointer, Int_t version, UInt_t start, UInt",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:41684,Security,checksum,checksum,41684,"tualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetCheckSum(UInt_t code = 0) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Algorithm from Victor Perevovchikov (perev@bnl.gov). if code==1 data members of type enum are not counted in the checksum; if code==2 return the checksum of data members and base classes, not including the ranges and array size found in comments.; This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBuffer(TBuffer& b, void* pointer, Int_t version, UInt_t start, UInt",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:44862,Security,access,accessor,44862,"st TClass* onfile_class) const; Case of TObjects when fIsOffsetStreamerSet is known to have been set. void StreamerTObjectEmulated(void* object, TBuffer& b, const TClass* onfile_class) const; Case of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:45931,Security,checksum,checksum,45931,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46016,Security,checksum,checksum,46016,"nc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46089,Security,checksum,checksum,46089,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46174,Security,checksum,checksum,46174,"ge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; ",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46697,Security,checksum,checksum,46697,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructo",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46805,Security,checksum,checksum,46805,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructo",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:46920,Security,checksum,checksum,46920,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47033,Security,checksum,checksum,47033,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:47127,Security,access,access,47127,"he TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClas",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClass.html:40218,Testability,test,test,40218,"erits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetChe",MatchSource.WIKI,root/html532/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClass.html
https://root.cern/root/html532/TClassDocInfo.html:1703,Availability,error,error,1703,"onst char* fsimpl = """", const char* decl = 0, const char* impl = 0); virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html532/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocInfo.html
https://root.cern/root/html532/TClassDocInfo.html:1787,Availability,error,error,1787,"ocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html532/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocInfo.html
https://root.cern/root/html532/TClassDocOutput.html:2849,Availability,error,error,2849,"erarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:2933,Availability,error,error,2933,"ndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:11585,Availability,down,down,11585,"ludes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the h",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:14609,Deployability,update,updates,14609,"TML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs). » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TClassDocOutput.h 31111 2009-11-12 09:57:56Z axel $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:751,Integrability,interface,interfaces,751,". TClassDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocOutput. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. TClassDocOutput(const TClassDocOutput&); TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual vo",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:11183,Integrability,depend,dependencies,11183,"; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:11214,Integrability,depend,dependency,11214,"; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:12186,Integrability,depend,dependency,12186,"clude dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxL",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:12359,Integrability,depend,dependency,12359,"int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:13469,Integrability,rout,routine,13469," char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeO",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:11150,Modifiability,inherit,inheritance,11150,"; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:11426,Modifiability,inherit,inherited,11426,"escounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:12012,Modifiability,inherit,inherited,12012," of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartLib(const char* filename); Build the library dependency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .c",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:13410,Modifiability,inherit,inheritance,13410,"endency graph for one class in; GraphViz/Dot format. Input: filename - output dot file incl. path. void CreateClassHierarchy(ostream& out, const char* docFileName); Create the hierarchical class list part for the current class's; base classes. docFileName contains doc for fCurrentClass. Bool_t CreateHierarchyDot(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateSourceOutputStream(ostream& out, const char* extension, TString& filename); Open a Class.cxx.html file, where Class is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write meth",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassDocOutput.html:13979,Modifiability,inherit,inheritance,13979,"lass is defined by classPtr, and .cxx.html by extension; It's created in fHtml->GetOutputDir()/src. If successful, the HTML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs). » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TClassDocOutput.h 31111 2009-11-12 09:57:56Z axel $ » Last generated: 2011-11-03 20:10; This page has been automatically ge",MatchSource.WIKI,root/html532/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassDocOutput.html
https://root.cern/root/html532/TClassEdit.html:889,Testability,test,testAlloc,889,". TClassEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » CORE; » METAUTILS; » TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); stringGetLong64_Name(const string& original); intGetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); intIsSTLCont(const char* type, int testAlloc = 0); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); intSTLKind(const char* type). Data Members. Class Charts; Function documentation; int IsSTLCont(int testAlloc=0). void ShortType(const char* typeDesc, int mode). std::string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). bool IsDefAlloc(const char* alloc, const char* classname). bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname). bool IsDefComp(const char* comp, const char* classname). bool IsSTLBitset(const char* type). bool IsStdClass(const char* type). bool IsVectorBool(const char* name). std::string GetLong64_Name(const string& original). int GetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). int STLKind(const char* type). int STLArgs(int kind). std::string ResolveTypedef(const char* tname, bool resolveAll = false). std::string InsertStd(const char* tname). » Author: Victor Pere",MatchSource.WIKI,root/html532/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassEdit.html
https://root.cern/root/html532/TClassEdit.html:1178,Testability,test,testAlloc,1178,"unction members; data members; class charts. ROOT; » CORE; » METAUTILS; » TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); stringGetLong64_Name(const string& original); intGetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); intIsSTLCont(const char* type, int testAlloc = 0); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); intSTLKind(const char* type). Data Members. Class Charts; Function documentation; int IsSTLCont(int testAlloc=0). void ShortType(const char* typeDesc, int mode). std::string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). bool IsDefAlloc(const char* alloc, const char* classname). bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname). bool IsDefComp(const char* comp, const char* classname). bool IsSTLBitset(const char* type). bool IsStdClass(const char* type). bool IsVectorBool(const char* name). std::string GetLong64_Name(const string& original). int GetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). int STLKind(const char* type). int STLArgs(int kind). std::string ResolveTypedef(const char* tname, bool resolveAll = false). std::string InsertStd(const char* tname). » Author: Victor Perev 10/04/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TClassEdit.h 38309 2011-03-04 17:14:19Z pcanal $ »",MatchSource.WIKI,root/html532/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassEdit.html
https://root.cern/root/html532/TClassGenerator.html:654,Availability,avail,available,654,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:1600,Availability,error,error,1600," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:1684,Availability,error,error,1684," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Han",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:346,Integrability,interface,interface,346,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:2016,Performance,load,load,2016,"virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UIn",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:2081,Performance,load,load,2081,"voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqua",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:2142,Performance,load,load,2142,"::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder(",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:2222,Performance,load,load,2222,"Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() co",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:5800,Performance,load,load,5800,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:5956,Performance,load,load,5956,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:6108,Performance,load,load,6108,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassGenerator.html:6167,Performance,load,load,6167,"j); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id: TClassGenerator.h 30751 2009-10-15 16:45:32Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassGenerator.html
https://root.cern/root/html532/TClassMenuItem.html:2070,Availability,error,error,2070,"s = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); virtual~TClassMenuItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* ",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassMenuItem.html:2154,Availability,error,error,2154," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* ",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassMenuItem.html:5273,Deployability,toggle,toggle,5273,"r* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSelf(Bool_t self); virtual voidSetTitle(const char* title); virtual voidSetToggle(Bool_t toggle = kTRUE); virtual voidSetType(Int_t type); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassMenuItem.html:7012,Deployability,toggle,toggle,7012,"ufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TClassMenuItem(const TClassMenuItem&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TClassMenuItem&operator=(const TClassMenuItem&). Data Members; public:. enum EClassMenuItemType { kPopupUserFunction; kPopupSeparator; kPopupStandardList; };; enum { kIsExternal; kIsSelf; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfArgsarguments type list *** NOT CHECKED ***; TObject*fCalledObjectobject to be called; TStringfFunctionNamename of the function or method to be called; TClass*fParentparent class; Bool_tfSelfflag to indicate that object to be called is the selected one; Int_tfSelfObjectPosrang in argument list corresponding to the object being clicked on; TList*fSubMenulist of submenu items; TStringfTitletitle if not standard; Bool_tfToggleflag toggle method; TClassMenuItem::EClassMenuItemTypefTypetype flag (EClassMenuItemType). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassMenuItem(); Default TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; fType = 0 : external method/function; fType = 1 : separator; fType = 2 : standard methods list. TClassMenuItem(Int_t type, TClass* parent, const char* title = """", const char* functionname = """", TObject* obj = 0, const char* args = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); TClassMenuItem ctor. TClassMenuItems are constructed in TClass; with a standard content but may be customized later; type = 0 : external method/function; type = 1 : separator; type = 2 : standard methods list; self i",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassMenuItem.html:9304,Deployability,toggle,toggle,9304,"rd methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsability of the caller/creator to add to to the; menu list. TClassMenuItem(const TClassMenuItem& ); copy constructor; Note: It is the responsability of the caller/creator to add to to the; menu list. TClassMenuItem& operator=(const TClassMenuItem& ); assignement operator; Note: It is the responsability of the caller/creator to add to to the; menu list. ~TClassMenuItem(); TClassMenuItem dtor. const char * GetTitle() const; { return fTitle; }. const char * GetFunctionName() const; { return fFunctionName; }. const char * GetArgs() const; { return fArgs; }. TObject * GetCalledObject() const; { return fCalledObject; }. Int_t GetType() const; { return fType; }. Int_t GetSelfObjectPos() const; { return fSelfObjectPos; }. Bool_t IsCallSelf() const; { return fSelf; }. Bool_t IsSeparator() const; { return fType==kPopupSeparator ? kTRUE : kFALSE; }. Bool_t IsStandardList() const; { return fType==kPopupStandardList ? kTRUE : kFALSE; }. Bool_t IsToggle() const; { return fToggle; }. void SetType(Int_t type); { fType = (EClassMenuItemType) type; }. void SetTitle(const char* title); { fTitle = title; }. void SetSelf(Bool_t self); { fSelf = self; }. void SetToggle(Bool_t toggle = kTRUE); { fToggle = toggle; }. void SetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0). » Author: Damir Buskulic 23/11/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClassMenuItem.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassMenuItem.html:9333,Deployability,toggle,toggle,9333,"rd methods list; self indicates if the object to be called is the one selected; by the popup menu; selfobjposition, if non zero, indicates the position in the arguments; list of the argument corresponding to the selected (clicked) object.; This argument in the calling method should be a TObject*; Note: It is the responsability of the caller/creator to add to to the; menu list. TClassMenuItem(const TClassMenuItem& ); copy constructor; Note: It is the responsability of the caller/creator to add to to the; menu list. TClassMenuItem& operator=(const TClassMenuItem& ); assignement operator; Note: It is the responsability of the caller/creator to add to to the; menu list. ~TClassMenuItem(); TClassMenuItem dtor. const char * GetTitle() const; { return fTitle; }. const char * GetFunctionName() const; { return fFunctionName; }. const char * GetArgs() const; { return fArgs; }. TObject * GetCalledObject() const; { return fCalledObject; }. Int_t GetType() const; { return fType; }. Int_t GetSelfObjectPos() const; { return fSelfObjectPos; }. Bool_t IsCallSelf() const; { return fSelf; }. Bool_t IsSeparator() const; { return fType==kPopupSeparator ? kTRUE : kFALSE; }. Bool_t IsStandardList() const; { return fType==kPopupStandardList ? kTRUE : kFALSE; }. Bool_t IsToggle() const; { return fToggle; }. void SetType(Int_t type); { fType = (EClassMenuItemType) type; }. void SetTitle(const char* title); { fTitle = title; }. void SetSelf(Bool_t self); { fSelf = self; }. void SetToggle(Bool_t toggle = kTRUE); { fToggle = toggle; }. void SetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0). » Author: Damir Buskulic 23/11/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TClassMenuItem.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassMenuItem.html
https://root.cern/root/html532/TClassStreamer.html:1711,Integrability,rout,routine,1711,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassStreamer.html
https://root.cern/root/html532/TClassStreamer.html:1746,Performance,optimiz,optimize,1746,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassStreamer.html
https://root.cern/root/html532/TClassTable.html:1712,Availability,error,error,1712,"Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(int index); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TT",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:1796,Availability,error,error,1796,"t pragmabits); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(int index); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const ",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:376,Security,hash,hash,376,". TClassTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClassTable. class TClassTable: public TObject. This class registers for all classes their name, id and dictionary; function in a hash table. Classes are automatically added by the; ctor of a special init class when a global of this init class is; initialized when the program starts (see the ClassImp macro). Function Members (Methods); public:. TClassTable(const TClassTable&); virtual~TClassTable(); voidTObject::AbstractMethod(const char* method) const; static voidAdd(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(int index); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* nam",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:7472,Security,hash,hash,7472,"ted in Terminate(). void Print(Option_t* option = """") const; Print the class table. Before printing the table is sorted; alphabetically. Only classes specified in option are listed.; The default is to list all classes.; Standard wilcarding notation supported. char * At(int index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class t",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:7731,Security,hash,hash,7731,"d. char * At(int index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Termi",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:8152,Security,hash,hash,8152,"t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TClassTable.h 33854 2010-06-12 14:09:50Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTable.html:8285,Security,hash,hash,8285,"to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TClassTable.h 33854 2010-06-12 14:09:50Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTable.html
https://root.cern/root/html532/TClassTree.html:749,Availability,down,down,749,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:5671,Availability,error,error,5671,"assTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual U",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:5755,Availability,error,error,5755,"e(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindClass(const char* classname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClasses() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetSourceDir() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13101,Deployability,configurat,configuration,13101,"d examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in class",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:3321,Energy Efficiency,green,green,3321,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:4439,Integrability,depend,dependencies,4439,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13372,Integrability,message,message,13372,"lect all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set ",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13425,Integrability,message,message,13425," class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:297,Modifiability,inherit,inheritance,297,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:403,Modifiability,inherit,inheritance,403,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:437,Modifiability,inherit,inheritance,437,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:942,Modifiability,inherit,inheritance,942,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1035,Modifiability,inherit,inheritance,1035,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1131,Modifiability,inherit,inheritance,1131,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1218,Modifiability,inherit,inheritance,1218,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1341,Modifiability,inherit,inheritance,1341,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1479,Modifiability,inherit,inheritance,1479,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1552,Modifiability,inherit,inheritance,1552,"Tree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1683,Modifiability,inherit,inheritance,1683,"rted from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1818,Modifiability,inherit,inheritance,1818,"ted by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree t",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:1984,Modifiability,inherit,inheritance,1984," referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; option = ""R"" to show pointers to other classes from data members; option = ""C"" to show classes used by the code(implementation) of a class. The following picture is produced directly by:; TClassTree ct(""ct"",""*TH1""); It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:3180,Modifiability,inherit,inheritance,3180,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:11481,Modifiability,inherit,inheritance,11481,"t_t xleft, Float_t y); virtual voidScanClasses(Int_t iclass); virtual voidShowCod(); virtual voidShowHas(); virtual voidShowMul(); virtual voidShowRef(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassesList of classes to be drawn; TString**fCnames![fNclasses] class names; Int_t*fCparent!parent number of classes (temporary); TClass**fCpointer![fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const ch",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:11549,Modifiability,inherit,inheritance,11549,"t_t xleft, Float_t y); virtual voidScanClasses(Int_t iclass); virtual voidShowCod(); virtual voidShowHas(); virtual voidShowMul(); virtual voidShowRef(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassesList of classes to be drawn; TString**fCnames![fNclasses] class names; Int_t*fCparent!parent number of classes (temporary); TClass**fCpointer![fNclasses] pointers to the TClass objects; Int_t*fCstatus[fNclasses] classes status; TString**fCtitles![fNclasses] class titles; char**fDerived![fNclasses] table to indicate if i derives from j; Float_tfLabelDxwidth along x of TPaveLabels in per cent of pad; TList**fLinks![fNclasses] for each class, the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const ch",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:12016,Modifiability,inherit,inheritance,12016,", the list of referenced(ing) classes; TStringTNamed::fNameobject identifier; Int_tfNclassescurrent number of classes; Int_t*fNdata[fNclasses] Number of data members per class; TString**fOptions![fNclasses] List of options per class; Int_t*fParents[fNclasses] parent number of classes (permanent); Int_tfShowCodif 1 show classes referenced by implementation; Int_tfShowHasif 1 show ""has a"" relationship; Int_tfShowMulif 1 show multiple inheritance; Int_tfShowRefif 1 show classes relationship other than inheritance; TStringfSourceDirConcatenated source directories; TStringTNamed::fTitleobject title; Float_tfYoffsetoffset at top of picture in per cent of pad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassTree(); TClassTree default constructor. TClassTree(const char* name, const char* classes = """"); TClassTree constructor. ~TClassTree(); TClassTree default destructor. void Draw(const char* classes = """"); Draw the inheritance tree and relations for the list of classes; see this class header for the syntax and examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* fil",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13101,Modifiability,config,configuration,13101,"d examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in class",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13993,Modifiability,inherit,inheriting,13993,"and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& b); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * Get",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:14573,Modifiability,inherit,inheritance,14573,"fy option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& b); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetSourceDir() const; {return fSourceDir.Data();}. void SetSourceDir(const char* dir = ""src""); {fSourceDir = dir;}. » Author: Rene Brun 01/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id: TClassTree.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:14662,Modifiability,inherit,inheritance,14662,"fy option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. void ShowHas(); Draw the ""Has a"" relationships. void ShowLinks(Option_t* option = ""HMR""); Set link options in the ClassTree object. ""C"" show References from code; ""H"" show Has a relations; ""M"" show Multiple Inheritance; ""R"" show References from data members. void ShowMul(); Draw the Multiple inheritance relationships. void ShowRef(); Draw the References relationships (other than inheritance or composition). void Streamer(TBuffer& b); Stream an object of class TClassTree.; the status of the object is saved and can be replayed in a subsequent session. TClassTree(). const char * GetClasses() const; {return fClasses.Data();}. const char * GetSourceDir() const; {return fSourceDir.Data();}. void SetSourceDir(const char* dir = ""src""); {fSourceDir = dir;}. » Author: Rene Brun 01/12/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id: TClassTree.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:4482,Security,access,access,4482,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClassTree.html:13326,Security,access,access,13326,"l classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in classes. void ShowClassesUsing(const char* classes); mark classes using any class in the list of classes in classes. void ShowCod(); Draw the Code References relationships. v",MatchSource.WIKI,root/html532/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClassTree.html
https://root.cern/root/html532/TClonesArray.html:2142,Availability,error,error,2142,",y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClones",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2304,Availability,recover,recovered,2304,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2515,Availability,error,errors,2515," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:6830,Availability,error,error,6830,"nst char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:6914,Availability,error,error,6914,"al TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObj",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:23279,Availability,error,error,23279,"nt_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. void Streamer(TBuffer& b); Write all objects in array to the I/O buffer. ATTENTION: empty slots; are also stored (using one byte per slot). If you don't want this; use a TOrdCollection or TList. TObject *& operator[](Int_t idx); Return pointer to reserved area in which a new object of clones; class can be constructed. This operator should not be used for; lefthand side assignments, like a[2] = xxx. Only like,; new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage; is only legal after the object has been constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx) const; Return the object at position idx. Returns 0 if idx is out of bounds. TObject * New(Int_t idx); Create an object of type fClass with the default ctor at the specified; index. Returns 0 in case of error. void AbsorbObjects(TClonesArray* tc); Directly move the object pointers from tc without cloning (copying).; This TClonesArray takes over ownership of all of tc's object; pointers. The tc array is left empty upon return. void AbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); Directly move the rang of object pointers from tc without cloning; (copying).; This TClonesArray takes over ownership of all of tc's object pointers; from idx1 to idx2. The tc array is re-arranged by return. void MultiSort(Int_t nTCs, TClonesArray** tcs, Int_t upto = kMaxInt); Sort multiple TClonesArrays simultaneously with this array.; If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. TObject * AddrAt(Int_t idx). TClass * GetClass() const; { return fClass; }. void AddFirst(TObject* ); { MayNotUse(""AddFirst""); }. void AddLast(TObject* ); { MayNotUse(""AddLast""); }. void AddAt(TObject* , Int_t ); { MayNotUse(""AddAt""); }. void AddAtAndExpand(TObjec",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:385,Energy Efficiency,allocate,allocated,385,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:548,Energy Efficiency,reduce,reduce,548,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:898,Energy Efficiency,reduce,reduces,898,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save abo",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:1196,Energy Efficiency,reduce,reduce,1196,"clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovere",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2108,Energy Efficiency,allocate,allocated,2108,",y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClones",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2281,Energy Efficiency,allocate,allocated,2281,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2331,Energy Efficiency,efficient,efficiently,2331,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2424,Energy Efficiency,allocate,allocate,2424,"or once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do n",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2630,Energy Efficiency,reduce,reduce,2630," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:3144,Energy Efficiency,allocate,allocated,3144,"mory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:3860,Energy Efficiency,allocate,allocate,3860,"ou to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* metho",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:4231,Energy Efficiency,reduce,reduce,4231,"onesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObje",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17930,Energy Efficiency,allocate,allocated,17930,"ptimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the o",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17977,Energy Efficiency,allocate,allocated,17977,"ptimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the o",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:18445,Energy Efficiency,allocate,allocate,18445,"quence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Cle",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:18698,Energy Efficiency,allocate,allocated,18698,"imized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:18745,Energy Efficiency,allocate,allocated,18745,"imized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19141,Energy Efficiency,allocate,allocate,19141," the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. vo",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19335,Energy Efficiency,allocate,allocate,19335," not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19633,Energy Efficiency,allocate,allocated,19633," index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or sh",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19935,Energy Efficiency,allocate,allocate,19935,"object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""ne",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:20013,Energy Efficiency,allocate,allocate,20013,"ass constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:20351,Energy Efficiency,allocate,allocated,20351,"'t; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:20767,Energy Efficiency,allocate,allocated,20767,"with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19302,Integrability,rout,routine,19302," not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19909,Integrability,rout,routine,19909,"object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""ne",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:20383,Integrability,rout,routine,20383,"nction; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:20805,Integrability,rout,routine,20805,"; Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:14865,Modifiability,inherit,inherit,14865,"tCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fClass!Pointer to the class; TObject**TObjArray::fCont!Array contents; TObjArray*fKeep!Saved copies of pointers to objects; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate num",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:15546,Modifiability,inherit,inherit,15546,"fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TC",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19966,Modifiability,inherit,inheriting,19966,"ass constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:21385,Modifiability,inherit,inherit,21385,"ne is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TClass*). void SetOwner(Bool_t enable = kTRUE); A TClonesArray is always the owner of the object it contains.; However the collection its inherits from (TObjArray) does not.; Hence this member function needs to be a nop for TClonesArray. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort ar",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:22160,Modifiability,inherit,inherits,22160,"bject from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TClass*). void SetOwner(Bool_t enable = kTRUE); A TClonesArray is always the owner of the object it contains.; However the collection its inherits from (TObjArray) does not.; Hence this member function needs to be a nop for TClonesArray. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. void Streamer(TBuffer& b); Write all objects in array to the I/O buffer. ATTENTION: empty slots; are also stored (using one byte per slot). If you don't want this; use a TOrdCollection or TList. TObject *& operator[](Int_t idx); Return pointer to reserved area in which a new object of clones; class can be constructed. This operator should not be used for; lefthand side assignments, like a[2] = xxx. Only like,; new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage; is only legal after the object has been constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx) const; Return the object at position idx. Returns 0 if idx is out of bounds. TObject * ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2966,Performance,perform,performance,2966,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:16443,Performance,perform,performance,16443,"Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the rig",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:16658,Performance,optimiz,optimized,16658," make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be c",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:16953,Performance,optimiz,optimized,16953,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; all",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17060,Performance,perform,performance,17060,"tically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClonesArray& tc); Copy ctor. TClonesArray& operator=(const TClonesArray& tc); Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; all",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17257,Performance,optimiz,optimization,17257," Assignment operator. ~TClonesArray(); Delete a clones array. void BypassStreamer(Bool_t bypass = kTRUE); When the kBypassStreamer bit is set, the automatically; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to s",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17307,Performance,optimiz,optimized,17307,"lly; generated Streamer can call directly TClass::WriteBuffer.; Bypassing the Streamer improves the performance when writing/reading; the objects in the TClonesArray. However there is a drawback:; When a TClonesArray is written with split=0 bypassing the Streamer,; the StreamerInfo of the class in the array being optimized,; one cannot use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not,",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:17719,Performance,optimiz,optimized,17719,"use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be ",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2304,Safety,recover,recovered,2304,"cation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; wh",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2899,Safety,avoid,avoiding,2899,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:3417,Safety,avoid,avoid,3417,"ic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc);",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:3881,Safety,avoid,avoid,3881,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:2662,Security,access,access,2662," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:3946,Usability,clear,clearing,3946,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:19809,Usability,clear,cleared,19809,"the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TClonesArray.html:21000,Usability,simpl,simplified,21000,"ory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TCla",MatchSource.WIKI,root/html532/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TClonesArray.html
https://root.cern/root/html532/TCollection.html:1344,Availability,avail,available,1344," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() ",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:2531,Availability,error,error,2531,"dAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; static voidEmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:2615,Availability,error,error,2615,"ol_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; static voidEmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidGarbageCollect(TObject* obj); static TCollection*GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGrowBy(Int_t delta) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voi",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:1154,Deployability,release,release,1154,"ion; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual vo",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:9439,Energy Efficiency,efficient,efficient,9439,"= """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by name. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Optio",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:357,Integrability,protocol,protocol,357,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) co",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:13960,Integrability,depend,depending,13960,"bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void operator=(const TCollection& ). virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* option = """"). Int_t GetEntries() const; { return GetSize(); }. TObject ** GetObjectRef(const TObject* obj) const. Int_t GetSize() const; { return fSize; }. ULong_t Hash() const; { return fName.Hash(); }. Bool_t IsEmpty() const; { return GetSize() <= 0; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsOwner() const; { return TestBit(kIsOwner); }. Bool_t IsSortable() const; { return kTRUE; }. TIterator * MakeIterator(Bool_t dir = kIterForward) const. TIterator * MakeReverseIterator() const; { return MakeIterator(kIterBackward); }. TObject * Remove(TObject* obj). void RemoveAll(TCollection* col)",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:475,Modifiability,inherit,inherit,475,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) co",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:1059,Modifiability,inherit,inherits,1059,"der file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = ",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:8190,Modifiability,inherit,inherit,8190,"y; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfNamename of the collection; Int_tfSizenumber of elements in collection. private:. static TCollection*fgCurrentCollectionused by macro R__FOR_EACH; static Bool_tfgEmptyingGarbageused by garbage collector; static TObjectTable*fgGarbageCollectionused by garbage collector; static Int_tfgGarbageStackused by garbage collector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAll(const TCollection* col); Add all objects from collection col to this collection. void AddVector(TObject *va_(obj1), ...); Add all arguments to the collection. The list of objects must be; temrinated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);. Bool_t AssertClass(TClass* cl) const; Make sure all objects in this collection inherit from class cl. void Browse(TBrowser* b); Browse this collection (called by TBrowser).; If b=0, there is no Browse call TObject::Browse(0) instead.; This means TObject::Inspect() will be invoked indirectly. TObject * Clone(const char* newname = """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by ",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:10276,Performance,perform,perform,10276,"Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Option_t* option = """") const; Defualt print for collections, calls Print(option, 1).; This will print the collection header and Print() methods of; all the collection entries. If you want to override Print() for a collection class, first; see if you can accomplish it by overriding the following protected; methods:; void PrintCollectionHeader(Option_t* option) const;; const char* GetCollectionEntryName(TObject* entry) const;; void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;; Otherwise override the Print(Option_t *option, Int_t); variant. Remember to declare:; using TCollection::Print;; somewhere close to the method declaration. void Print(Option_t* option, Int_t recurse) const; Print the collection header and its elements. If recurse is n",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollection.html:13356,Security,access,accessible,13356,"n col from this collection. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void operator=(const TCollection& ). virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* optio",MatchSource.WIKI,root/html532/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollection.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:3258,Availability,error,error,3258,"CollectionMethodBrowsable&); virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; ",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:3342,Availability,error,error,3342,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:9754,Integrability,depend,depending,9754,"eListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:9931,Integrability,depend,depending,9931,"eListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:458,Modifiability,extend,extend,458,". TCollectionMethodBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, c",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:1185,Performance,cache,cached,1185," » TREE; » TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsa",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:1246,Performance,cache,cached,1246," » TREE; » TCollectionMethodBrowsable. class TCollectionMethodBrowsable: public TMethodBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsa",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionMethodBrowsable.html:1433,Usability,simpl,simple,1433,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsable(const TCollectionMethodBrowsable&); virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voi",MatchSource.WIKI,root/html532/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionMethodBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:3252,Availability,error,error,3252,"ertyBrowsable(const TCollectionPropertyBrowsable&); virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual c",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:3336,Availability,error,error,3336,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:9839,Integrability,depend,depending,9839,"Drawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:10016,Integrability,depend,depending,10016,"ing to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:471,Modifiability,extend,extend,471,". TCollectionPropertyBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(T",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:1198,Performance,cache,cached,1198,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrow",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:1259,Performance,cache,cached,1259,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrow",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:1446,Usability,simpl,simple,1446,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrowsable(const TCollectionPropertyBrowsable&); virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TCollectionPropertyBrowsable.html:9592,Usability,simpl,simply,9592,"ct::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08",MatchSource.WIKI,root/html532/TCollectionPropertyBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html
https://root.cern/root/html532/TColor.html:9115,Availability,error,error,9115,"on = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& color) const; static voidCreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorsGray(); static voidCreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorWheel(); static Int_tCreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAlpha() const; Float_tGetBlue() const; static Int_tGetColor(const char* hexcolor); static Int_tGetColor(ULong_t pixel); static Int_tGetColor(Float_t r, Float_t g, Float_t b); static Int_tGetColor(Int_t r, Int_t g, Int_t b); static Int_tGetColorBright(Int_t color); static Int_tGetColorDark(Int_t color); static Int_tGetColorPalette(Int_t i); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetGrayscale() const; Float_tGetGreen() const; virtual voidGetHLS(Float_t& h, Float_t& l, Float_t& s) const; Float_tGetHue() const; virtual c",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:9199,Availability,error,error,9199,"_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& color) const; static voidCreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorsGray(); static voidCreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorWheel(); static Int_tCreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAlpha() const; Float_tGetBlue() const; static Int_tGetColor(const char* hexcolor); static Int_tGetColor(ULong_t pixel); static Int_tGetColor(Float_t r, Float_t g, Float_t b); static Int_tGetColor(Int_t r, Int_t g, Int_t b); static Int_tGetColorBright(Int_t color); static Int_tGetColorDark(Int_t color); static Int_tGetColorPalette(Int_t i); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetGrayscale() const; Float_tGetGreen() const; virtual voidGetHLS(Float_t& h, Float_t& l, Float_t& s) const; Float_tGetHue() const; virtual const char*TObject::GetIconName() const; Float_tGetLight() const; virtual const char*",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:23433,Availability,error,error,23433,"ent::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors). Static function creating a color table with several connected linear gradients.; ; Number: The number of end point colors that will form the gradients.; Must be at least 2.; Stops: Where in the whole table the end point colors should lie.; Each entry must be on [0, 1], each entry must be greater than; the previous entry.; Red, Green, Blue: The end point color values.; Each entry must be on [0, 1]; NColors: Total number of colors in the table. Must be at least 1.; ; Returns a positive value on success and -1 on error.; ; The table is constructed by tracing lines between the given points in; RGB space. Each color value may have a value between 0 and 1. The; difference between consecutive ""Stops"" values gives the fraction of; space in the whole table that should be used for the interval between; the corresponding color values.; ; Normally the first element of Stops should be 0 and the last should be 1.; If this is not true, fewer than NColors will be used in proportion with; the total interval between the first and last elements of Stops.; ; This definition is similar to the povray-definition of gradient; color tables.; ; For instance:; ; UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; ; This defines a table in which there are three color end points:; RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white; The first 40% of the table is used",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:3135,Deployability,toggle,toggle,3135,"Red, kBlue, kYellow, kPink, etc are defined in the header file; Rtypes.h that is included in all ROOT other header files. It is better; to use these keywords in user code instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The dark colors have an index = color_index+100; The bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanv",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:4491,Deployability,continuous,continuous,4491,"ed grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; To define more a complex palette with a continuous gradient of color, one; should use the static function TColor::CreateGradientColorTable().; The following example demonstrates how to proceed:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; UInt_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->Draw(""surf1z"");; return c2;; }; The function TColor::CreateGradientColorTable() automatically ; calls gStyle->SetPalette(), so there is not need to add one. After a call to TColor::CreateGradientColorTable() it is sometimes; useful to store the newly create palette for further use. In particular, it is; rec",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:493,Energy Efficiency,green,green,493,". TColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TColor. class TColor: public TNamed. The color creation and management class. Introduction; Basic colors; The color wheel; Bright and dark colors; Gray scale view of of canvas with colors; Color palettes. Introduction; Colors are defined by their red, green and blue components, simply called the; RGB components. The colors are also known by the hue, light and saturation; components also known as the HLS components. When a new color is created the; components of both color systems are computed. At initialization time, a table of colors is generated. An existing color can; be retrieved by its index:. TColor *color = gROOT->GetColor(10);. Then it can be manipulated. For example its RGB components can be modified:. color->SetRGB(0.1, 0.2, 0.3);. A new color can be created the following way:. Int_t ci = 1756; // color index; TColor *color = new TColor(ci, 0.1, 0.2, 0.3);. Two sets of colors are initialized;. The basic colors: colors with index from 0 to 50.; The color wheel: colors with indices from 300 to 1000. Basic colors; The following image displays the 50 basic colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; c.DrawColorTable();; return c;; }; The color wheel; The wheel contains the recommended 216 colors to be used in web applications.; The colors in the color wheel are created by TColor::CreateColorWheel. Using this color set for your text, background or graphics will give your; application a consistent appearance across different platforms and browsers. Colors are grouped by hue, the aspect most important in human perception.; Touching color chips have the same hue, but with different brightness and; vividness. Colors of slightly different hues clash. If you intend to display; colors o",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:24626,Energy Efficiency,allocate,allocated,24626,"he; difference between consecutive ""Stops"" values gives the fraction of; space in the whole table that should be used for the interval between; the corresponding color values.; ; Normally the first element of Stops should be 0 and the last should be 1.; If this is not true, fewer than NColors will be used in proportion with; the total interval between the first and last elements of Stops.; ; This definition is similar to the povray-definition of gradient; color tables.; ; For instance:; ; UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; ; This defines a table in which there are three color end points:; RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white; The first 40% of the table is used to go linearly from blue to red.; The remaining 60% of the table is used to go linearly from red to white.; ; If you define a very short interval such that less than one color fits; in it, no colors at all will be allocated. If this occurs for all; intervals, ROOT will revert to the default palette.; ; Original code by Andreas Zoglauer (zog@mpe.mpg.de); ; . void SetPalette(Int_t ncolors, Int_t* colors). Static function.; The color palette is used by the histogram classes; (see TH1::Draw options).; For example TH1::Draw(""col"") draws a 2-D histogram with cells; represented by a box filled with a color CI function of the cell content.; if the cell content is N, the color CI used will be the color number; in colors[N],etc. If the maximum cell content is > ncolors, all; cell contents are scaled to ncolors.; ; if ncolors <= 0 a default palette (see below) of 50 colors is; defined. The colors defined in this palette are OK for coloring pads, labels.; ; if ncolors == 1 && colors == 0, then a Pretty Palette with a; Spectrum Violet->Red is created. It is recommended to use this Pretty; palette when drawing legos, surfaces or contours.; ; if ncolors > 50 and",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:20342,Integrability,depend,dependent,20342,"t& l, Int_t& s). Static method to compute HLS from RGB. The r,g,b triplet is between; [0,255], hue, light and satur are between [0,255].; ; . void SetRGB(Float_t r, Float_t g, Float_t b). Initialize this color and its associated colors.; ; . void Allocate(). Make this color known to the graphics system.; ; . Int_t GetColor(const char* hexcolor). Static method returning color number for color specified by; hex color string of form: #rrggbb, where rr, gg and bb are in; hex between [0,FF], e.g. ""#c0c0c0"".; ; If specified color does not exist it will be created with as; name ""#rrggbb"" with rr, gg and bb in hex between [0,FF].; ; . Int_t GetColor(Float_t r, Float_t g, Float_t b). Static method returning color number for color specified by; r, g and b. The r,g,b should be in the range [0,1].; ; If specified color does not exist it will be created; with as name ""#rrggbb"" with rr, gg and bb in hex between; [0,FF].; ; . Int_t GetColor(ULong_t pixel). Static method returning color number for color specified by; system dependent pixel value. Pixel values can be obtained, e.g.,; from the GUI color picker.; ; . Int_t GetColor(Int_t r, Int_t g, Int_t b). Static method returning color number for color specified by; r, g and b. The r,g,b should be in the range [0,255].; If the specified color does not exist it will be created; with as name ""#rrggbb"" with rr, gg and bb in hex between; [0,FF].; ; . Int_t GetColorBright(Int_t color). Static function: Returns the bright color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:21496,Integrability,depend,dependent,21496," returning color number for color specified by; r, g and b. The r,g,b should be in the range [0,255].; If the specified color does not exist it will be created; with as name ""#rrggbb"" with rr, gg and bb in hex between; [0,FF].; ; . Int_t GetColorBright(Int_t color). Static function: Returns the bright color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ;",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:21637,Integrability,depend,dependent,21637,"it will be created; with as name ""#rrggbb"" with rr, gg and bb in hex between; [0,FF].; ; . Int_t GetColorBright(Int_t color). Static function: Returns the bright color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:21784,Integrability,depend,dependent,21784," TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Numbe",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:22014,Integrability,depend,dependent,22014,"ot exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors). Static function creating a color table with several connected linear gradients.; ; Number: The number of end point colors that will form the grad",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:22231,Integrability,depend,dependent,22231,"be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors). Static function creating a color table with several connected linear gradients.; ; Number: The number of end point colors that will form the gradients.; Must be at least 2.; Stops: Where in the whole table the end point colors should lie.; Each entry must be on [0, 1], each entry must be greater than; the previous entry.; Red, Green, Blue: The end point color valu",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:3729,Modifiability,variab,variable,3729,"ive 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The dark colors have an index = color_index+100; The bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; To define more a complex palette with a continuous gradient of color, one; should use the static function TColor::CreateGradientColorTable().; The following example demonstrates h",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:3260,Security,access,access,3260," instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The dark colors have an index = color_index+100; The bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:3378,Security,access,access,3378," instead of hardcoded color numbers, e.g.:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; return w->GetCanvas();; }; Bright and dark colors; The dark and bright color are used to give 3-D effects when drawing various; boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). The dark colors have an index = color_index+100; The bright colors have an index = color_index+150; Two static functions return the bright and dark color number; corresponding to a color index. If the bright or dark color does not; exist, they are created:; ; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; . Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using; TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB; will return grayscale values according to ITU standards (and close to b&w; printer grayscales), while access via HLS returns de-saturated grayscales. The; image below shows the ROOT color wheel in grayscale mode. Picture; Source. {; TColorWheel *w = new TColorWheel();; w->Draw();; w->GetCanvas()->SetGrayscale();; w->GetCanvas()->Modified();; w->GetCanvas()->Update();; return w->GetCanvas();; }; Color palettes; It is often very useful to represent a variable with a color map. The concept; of ""color palette"" allows to do that. One color palette is active at any time.; This ""current palette"" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColor.html:520,Usability,simpl,simply,520,". TColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TColor. class TColor: public TNamed. The color creation and management class. Introduction; Basic colors; The color wheel; Bright and dark colors; Gray scale view of of canvas with colors; Color palettes. Introduction; Colors are defined by their red, green and blue components, simply called the; RGB components. The colors are also known by the hue, light and saturation; components also known as the HLS components. When a new color is created the; components of both color systems are computed. At initialization time, a table of colors is generated. An existing color can; be retrieved by its index:. TColor *color = gROOT->GetColor(10);. Then it can be manipulated. For example its RGB components can be modified:. color->SetRGB(0.1, 0.2, 0.3);. A new color can be created the following way:. Int_t ci = 1756; // color index; TColor *color = new TColor(ci, 0.1, 0.2, 0.3);. Two sets of colors are initialized;. The basic colors: colors with index from 0 to 50.; The color wheel: colors with indices from 300 to 1000. Basic colors; The following image displays the 50 basic colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; c.DrawColorTable();; return c;; }; The color wheel; The wheel contains the recommended 216 colors to be used in web applications.; The colors in the color wheel are created by TColor::CreateColorWheel. Using this color set for your text, background or graphics will give your; application a consistent appearance across different platforms and browsers. Colors are grouped by hue, the aspect most important in human perception.; Touching color chips have the same hue, but with different brightness and; vividness. Colors of slightly different hues clash. If you intend to display; colors o",MatchSource.WIKI,root/html532/TColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColor.html
https://root.cern/root/html532/TColorWheel.html:2425,Availability,error,error,2425," TColorWheel(); virtual~TColorWheel(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Optio",MatchSource.WIKI,root/html532/TColorWheel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColorWheel.html
https://root.cern/root/html532/TColorWheel.html:2509,Availability,error,error,2509,"l~TColorWheel(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TCanvas*GetCanvas() const; virtual Int_tGetColor(Int_t px, Int_t py) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom",MatchSource.WIKI,root/html532/TColorWheel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColorWheel.html
https://root.cern/root/html532/TColumnView.html:2264,Availability,error,error,2264,"l Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTChair::CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidTChair::CopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTChair::Draw(Option_t* opt); virtual TH1*TChair::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TChair::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTChair::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*TChair::Get",MatchSource.WIKI,root/html532/TColumnView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColumnView.html
https://root.cern/root/html532/TColumnView.html:2348,Availability,error,error,2348,"named) const; Int_tTChair::CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidTChair::CopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTChair::Draw(Option_t* opt); virtual TH1*TChair::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TChair::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTChair::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*TChair::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Optio",MatchSource.WIKI,root/html532/TColumnView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColumnView.html
https://root.cern/root/html532/TColumnView.html:11068,Usability,simpl,simple,11068,"bject* mother); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds); static TDataSet::EDataSetPassTDataSet::SortIt(TDataSet* ds, void* user). Data Members; public:. enum TDataSet::EDataSetPass { kContinue; kPrune; kStop; kUp; kStruct; kAll; kRefs; kMarked; };; enum TDataSet::ESetBits { kMark; kArray; };; enum TDataSet::EBitOpt { kSet; kReset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. ULong_tTChair::fLastIndxindex pof the last used table row;; void*TChair::fLastRowpointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*TChair::fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColumnView(const char* colName = """", TTable* table = 0); constructor. ~TColumnView(); destructor. void Browse(TBrowser* b); Create a column histogram for the simple column. TH1 * Histogram(const char* selection = """"); Create a histogram from the context menu. Bool_t IsFolder() const; Treat the column with the pointer to the ""Ptr"" as a ""folder"". TColumnView(const char* colName = """", TTable* table = 0). » Author: Valery Fine(fine@bnl.gov) 13/03/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id: TColumnView.h 21414 2007-12-17 14:15:59Z brun $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TColumnView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TColumnView.html
https://root.cern/root/html532/TCondition.html:1508,Availability,error,error,1508," TCondition(TMutex* m = 0); virtual~TCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:1592,Availability,error,error,1592,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMutex*GetMutex() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) c",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:6632,Availability,error,error,6632," fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:6971,Availability,error,error,6971," fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TCondition& ). TCondition& operator=(const TCondition& ). Int_t Signal(); { if (fConditionImp) return fConditionImp->Signal(); return -1; }. Int_t Broadcast(); { if (fConditionImp) return fConditionImp->Broadcast(); return -1; }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:339,Modifiability,variab,variable,339,". TCondition. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TCondition. class TCondition: public TObject. TCondition. This class implements a condition variable. Use a condition variable; to signal threads. The actual work is done via the TConditionImp; class (either TPosixCondition or TWin32Condition). Function Members (Methods); public:. TCondition(TMutex* m = 0); virtual~TCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:365,Modifiability,variab,variable,365,". TCondition. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TCondition. class TCondition: public TObject. TCondition. This class implements a condition variable. Use a condition variable; to signal threads. The actual work is done via the TConditionImp; class (either TPosixCondition or TWin32Condition). Function Members (Methods); public:. TCondition(TMutex* m = 0); virtual~TCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:5490,Modifiability,variab,variable,5490,"_t f) const; Int_tTimedWait(ULong_t secs, ULong_t nanoSecs); Int_tTimedWaitRelative(ULong_t ms); virtual voidTObject::UseCurrentStyle(); Int_tWait(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TCondition(const TCondition&); TCondition&operator=(const TCondition&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionImp*fConditionImppointer to condition variable implementation; TMutex*fMutexmutex used around Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::Tim",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:5755,Modifiability,variab,variable,5755,"od, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TCondition(const TCondition&); TCondition&operator=(const TCondition&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionImp*fConditionImppointer to condition variable implementation; TMutex*fMutexmutex used around Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TCondition.html:6017,Modifiability,variab,variable,6017,"ation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TCondition(const TCondition&); TCondition&operator=(const TCondition&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionImp*fConditionImppointer to condition variable implementation; TMutex*fMutexmutex used around Wait() and TimedWait(); Bool_tfPrivateMutexis fMutex our private mutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondition(TMutex* m = 0); Create a condition variable. The actual condition implementation; will be provided via the TThreadFactory. If no external mutex is; provided one will be created. Use GetMutex() to get this mutex; and use it before calling Signal() or Broadcast(). ~TCondition(); Clean up condition variable. TMutex * GetMutex() const; Get internally created mutex. Use it to lock resources; before calling Signal() or Broadcast(). Returns 0 if; external mutex was provided in TCondition ctor. Int_t Wait(); Wait to be signaled. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs); Wait to be signaled or till the timer times out.; This method is given an absolute time since the beginning of; the EPOCH (use TThread::GetTime() to get this absolute time).; To wait for a relative time from now, use; TCondition::TimedWaitRelative(ULong_t ms).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. Int_t TimedWaitRelative(ULong_t ms); Wait to be signaled or till the timer times out.; This method is given a relative time from now.; To wait for an absolute time since the beginning of the EPOCH, use; TCondition::TimedWait(ULong_t secs, ULong_t nanoSec).; Returns 0 if successfully signalled, 1 if time expired and -1 in; case of error. TCondition(const TConditio",MatchSource.WIKI,root/html532/TCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondition.html
https://root.cern/root/html532/TConditionImp.html:571,Availability,avail,available,571,". TConditionImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TConditionImp. class TConditionImp: public TObject. TConditionImp. This class provides an abstract interface to the OS dependent; condition classes (TPosixCondition and TWin32Condition). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TConditionImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root/html532/TConditionImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConditionImp.html
https://root.cern/root/html532/TConditionImp.html:1568,Availability,error,error,1568," virtual~TConditionImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root/html532/TConditionImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConditionImp.html
https://root.cern/root/html532/TConditionImp.html:1652,Availability,error,error,1652,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TConditionImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConditionImp.html
https://root.cern/root/html532/TConditionImp.html:349,Integrability,interface,interface,349,". TConditionImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TConditionImp. class TConditionImp: public TObject. TConditionImp. This class provides an abstract interface to the OS dependent; condition classes (TPosixCondition and TWin32Condition). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TConditionImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root/html532/TConditionImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConditionImp.html
https://root.cern/root/html532/TConditionImp.html:369,Integrability,depend,dependent,369,". TConditionImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TConditionImp. class TConditionImp: public TObject. TConditionImp. This class provides an abstract interface to the OS dependent; condition classes (TPosixCondition and TWin32Condition). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TConditionImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root/html532/TConditionImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConditionImp.html
https://root.cern/root/html532/TCondor.html:1595,Availability,error,error,1595,"::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); TList*Claim(Int_t n, const char* cmd); TCondorSlave*Claim(const char* vmname, const char* cmd); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TStringGetImage(const char* host) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TCondor::EStateGetState() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetVirtualMachines() const; Bool_tGetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; virtual Bool_tTObject::HandleTimer(TTimer* ti",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:1679,Availability,error,error,1679," option = """"); virtual voidTObject::Browse(TBrowser* b); TList*Claim(Int_t n, const char* cmd); TCondorSlave*Claim(const char* vmname, const char* cmd); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TStringGetImage(const char* host) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TCondor::EStateGetState() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetVirtualMachines() const; Bool_tGetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* me",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:6409,Availability,failure,failure,6409,"bie(). Data Members; public:. enum EState { kFree; kSuspended; kActive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 ",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:6016,Integrability,interface,interface,6016,"thod, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TCondorSlave*ClaimVM(const char* vm, const char* cmd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EState { kFree; kSuspended; kActive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, T",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:6106,Integrability,interface,interface,6106,"ufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TCondorSlave*ClaimVM(const char* vm, const char* cmd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EState { kFree; kSuspended; kActive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:6525,Performance,perform,performance,6525,"e; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For c",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:6735,Performance,perform,performance,6735,"num TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondor.html:5801,Security,access,accessed,5801,"st char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TCondorSlave*ClaimVM(const char* vm, const char* cmd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EState { kFree; kSuspended; kActive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetStat",MatchSource.WIKI,root/html532/TCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondor.html
https://root.cern/root/html532/TCondorSlave.html:1506,Availability,error,error,1506," TCondorSlave(); TCondorSlave(const TCondorSlave&); ~TCondorSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const",MatchSource.WIKI,root/html532/TCondorSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondorSlave.html
https://root.cern/root/html532/TCondorSlave.html:1590,Availability,error,error,1590," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TCondorSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCondorSlave.html
https://root.cern/root/html532/TCONE.html:1918,Availability,error,error,1918,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html532/TCONE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCONE.html
https://root.cern/root/html532/TCONE.html:2002,Availability,error,error,2002,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html532/TCONE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCONE.html
https://root.cern/root/html532/TCONE.html:9382,Usability,simpl,simplified,9382,"otDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tfRmax2outside radius at the high z limit; Float_tTTUBE::fRminellipse semi-axis in X inside; Float_tfRmin2inside radius at the high z limit; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCONE(); CONE shape default constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2); CONE shape normal constructor. TCONE(const char* name, const char* title, const char* material, Float_t dz, Float_t rmax1, Float_t rmax2 = 0); CONE shape ""simplified"" constructor. ~TCONE(); CONE shape default destructor. void SetPoints(Double_t* points) const; Create CONE points. TCONE(). Float_t GetRmin2() const; {return fRmin2;}. Float_t GetRmax2() const; {return fRmax2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TCONE.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCONE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCONE.html
https://root.cern/root/html532/TConfidenceLevel.html:1568,Availability,error,error,1568," char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Double_tCLb(bool use_sMC = kFALSE) const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCLs(bool use_sMC = kFALSE) const; Double_tCLsb(bool use_sMC = kFALSE) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGet3sProbability() const; Double_tGet5sProbability() const; Double_tGetAverageCLs() const; Double_tGetAverageCLsb() const; Double_tGetBtot() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetDtot() const; Double_tGetExpectedCLb_b(Int_t sigma = 0) const; Double_tGetExpectedCLb_sb(Int_t sigma = 0) const; Double_tGetExpectedCLs_b(Int_t sigma = 0) const; Double_tGetExpectedCLsb_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_sb(Int_t sigma = 0) const; virtual const char*TObject::GetIconName() const; virtual const char*",MatchSource.WIKI,root/html532/TConfidenceLevel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConfidenceLevel.html
https://root.cern/root/html532/TConfidenceLevel.html:1652,Availability,error,error,1652," voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Double_tCLb(bool use_sMC = kFALSE) const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCLs(bool use_sMC = kFALSE) const; Double_tCLsb(bool use_sMC = kFALSE) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGet3sProbability() const; Double_tGet5sProbability() const; Double_tGetAverageCLs() const; Double_tGetAverageCLsb() const; Double_tGetBtot() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetDtot() const; Double_tGetExpectedCLb_b(Int_t sigma = 0) const; Double_tGetExpectedCLb_sb(Int_t sigma = 0) const; Double_tGetExpectedCLs_b(Int_t sigma = 0) const; Double_tGetExpectedCLsb_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_b(Int_t sigma = 0) const; Double_tGetExpectedStatistic_sb(Int_t sigma = 0) const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) co",MatchSource.WIKI,root/html532/TConfidenceLevel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TConfidenceLevel.html
https://root.cern/root/html532/TCONS.html:2165,Availability,error,error,2165,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBS::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBS::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html532/TCONS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCONS.html
https://root.cern/root/html532/TCONS.html:2249,Availability,error,error,2249,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBS::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBS::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html532/TCONS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCONS.html
https://root.cern/root/html532/TContextMenu.html:478,Availability,down,downs,478,". TContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TContextMenu. class TContextMenu: public TNamed. TContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs. Context Menus are automatically generated by ROOT using the; following convention: if the string // *MENU* is found in the; comment field of a member function. This function will be added to; the list of items in the menu. The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); virtual~TContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(TClassMenuItem* classmenuitem); voidAction(TMethod* method); voidAction(TToggle* toggle); virtual voidAction(TObject* object, TMethod* method); virtual voidAction(TObject* object, TToggle* toggle); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); v",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:2361,Availability,error,error,2361,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(const char* params); voidExecute(TObjArray* params); virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecute(TObject* object, TFunction* method, const char* params); virtual voidExecute(TObject* object, TFunction* method, TObjArray* params); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TBrowser*GetBrowser(); virtual TObject*GetCalledObject(); virtual TContextMenuImp*GetContextMenuImp(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVirt",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:2436,Availability,error,error,2436,"ed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(const char* params); voidExecute(TObjArray* params); virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecute(TObject* object, TFunction* method, const char* params); virtual voidExecute(TObject* object, TFunction* method, TObjArray* params); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TBrowser*GetBrowser(); virtual TObject*GetCalledObject(); virtual TContextMenuImp*GetContextMenuImp(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVirtualPad*GetSelectedCanvas(); virtual TClassMenuItem*GetSelectedMenuItem(); v",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:9888,Availability,error,error,9888,"rgument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject* object, TMethod* method). void Action(TObject* object, TToggle* toggle). void Execute(const char* method, const char* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TObject* object, TFunction* method, const char* params). void Execute(TObject* object, TFunction* method, TObjArray* params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMethod(TFunction* m); { fSelectedMethod = m; }. void SetCalledObject(TObject* o); { fC",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:9935,Availability,error,error,9935,"rgument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject* object, TMethod* method). void Action(TObject* object, TToggle* toggle). void Execute(const char* method, const char* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TObject* object, TFunction* method, const char* params). void Execute(TObject* object, TFunction* method, TObjArray* params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMethod(TFunction* m); { fSelectedMethod = m; }. void SetCalledObject(TObject* o); { fC",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:10002,Availability,error,error,10002,"bject, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject* object, TMethod* method). void Action(TObject* object, TToggle* toggle). void Execute(const char* method, const char* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TObject* object, TFunction* method, const char* params). void Execute(TObject* object, TFunction* method, TObjArray* params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMethod(TFunction* m); { fSelectedMethod = m; }. void SetCalledObject(TObject* o); { fCalledObject = o; }. void SetSelectedMenuItem(TClassMenuItem* mi); { fSelectedMenuItem = mi; }. void SetNameTitle(con",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:10049,Availability,error,error,10049,"bject, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject* object, TMethod* method). void Action(TObject* object, TToggle* toggle). void Execute(const char* method, const char* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TObject* object, TFunction* method, const char* params). void Execute(TObject* object, TFunction* method, TObjArray* params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMethod(TFunction* m); { fSelectedMethod = m; }. void SetCalledObject(TObject* o); { fCalledObject = o; }. void SetSelectedMenuItem(TClassMenuItem* mi); { fSelectedMenuItem = mi; }. void SetNameTitle(con",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:1139,Deployability,toggle,toggle,1139," TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); virtual~TContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(TClassMenuItem* classmenuitem); voidAction(TMethod* method); voidAction(TToggle* toggle); virtual voidAction(TObject* object, TMethod* method); virtual voidAction(TObject* object, TToggle* toggle); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); v",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:1247,Deployability,toggle,toggle,1247," TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); virtual~TContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(TClassMenuItem* classmenuitem); voidAction(TMethod* method); voidAction(TToggle* toggle); virtual voidAction(TObject* object, TMethod* method); virtual voidAction(TObject* object, TToggle* toggle); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); v",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:8591,Deployability,toggle,toggle,8591,"vas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:8633,Deployability,toggle,toggle,8633,"vas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:9819,Deployability,toggle,toggle,9819,"Title(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject* object, TMethod* method). void Action(TObject* object, TToggle* toggle). void Execute(const char* method, const char* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); { TObject::Execute(method, params, error); }. void Execute(TObject* object, TFunction* method, const char* params). void Execute(TObject* object, TFunction* method, TObjArray* params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMeth",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:333,Integrability,interface,interface,333,". TContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TContextMenu. class TContextMenu: public TNamed. TContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs. Context Menus are automatically generated by ROOT using the; following convention: if the string // *MENU* is found in the; comment field of a member function. This function will be added to; the list of items in the menu. The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); virtual~TContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(TClassMenuItem* classmenuitem); voidAction(TMethod* method); voidAction(TToggle* toggle); virtual voidAction(TObject* object, TMethod* method); virtual voidAction(TObject* object, TToggle* toggle); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual const char*CreateArgumentTitle(TMethodArg* argument); virtual const char*CreateDialogTitle(TObject* object, TFunction* method); virtual const char*CreatePopupTitle(TObject* object); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); v",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:8146,Performance,perform,performed,8146,"Delete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBrowser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* obje",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:8378,Performance,perform,performed,8378,"Browser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canv",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenu.html:8613,Performance,perform,performed,8613,"vas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root/html532/TContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenu.html
https://root.cern/root/html532/TContextMenuImp.html:330,Integrability,interface,interface,330,". TContextMenuImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TContextMenuImp. class TContextMenuImp. TContextMenuImp. This class provides an interface to GUI independent; context sensitive popup menus. Function Members (Methods); public:. TContextMenuImp(TContextMenu* c = 0); virtual~TContextMenuImp(); static TClass*Class(); virtual voidDialog(TObject* object, TFunction* function); virtual voidDialog(TObject* object, TMethod* method); virtual voidDisplayPopup(Int_t x, Int_t y); virtual TContextMenu*GetContextMenu() const; virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TContextMenuImp(const TContextMenuImp& cmi); TContextMenuImp&operator=(const TContextMenuImp& cmi). Data Members; protected:. TContextMenu*fContextMenuTContextMenu associated with this implementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dialog(TObject* object, TFunction* function); { }. void Dialog(TObject* object, TMethod* method); { }. void DisplayPopup(Int_t x, Int_t y); { }. TContextMenuImp(const TContextMenuImp& cmi); { }. TContextMenuImp& operator=(const TContextMenuImp& cmi). TContextMenuImp(TContextMenu* c = 0); { }. virtual ~TContextMenuImp(); { }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. » Author: Nenad Buncic 08/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TContextMenuImp.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TContextMenuImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TContextMenuImp.html
https://root.cern/root/html532/TControlBar.html:4091,Availability,error,error,4091,"const char* type = ""button""); voidAddControlBar(TControlBar* controlBar); voidAddControlBar(TControlBar& controlBar); voidAddSeparator(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TControlBarButton::GetAction() const; TControlBarButton*GetClicked() const; TControlBarImp*GetControlBarImp() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfButtons() const; virtual const char*TNamed::GetName() const; Int_tGetNumberOfColumns() const; Int_tGetNumberOfRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetOrientation() const; virtual ",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:4175,Availability,error,error,4175,"trolBar(TControlBar& controlBar); voidAddSeparator(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TControlBarButton::GetAction() const; TControlBarButton*GetClicked() const; TControlBarImp*GetControlBarImp() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfButtons() const; virtual const char*TNamed::GetName() const; Int_tGetNumberOfColumns() const; Int_tGetNumberOfRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetOrientation() const; virtual const char*TNamed::GetTitle() const; virtual Int_tTControlBarButton::GetType() const",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:331,Modifiability,config,configurable,331,". TControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TControlBar. class TControlBar: public TControlBarButton. ControlBar is fully user configurable tool which provides fast; access to frequently used operations. User can choose between; buttons and drawnbuttons (let's say icons) and assign to them his; own actions (let's say ROOT or C++ commands). The macro belows shows an example of controlbar.; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:370,Security,access,access,370,". TControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TControlBar. class TControlBar: public TControlBarButton. ControlBar is fully user configurable tool which provides fast; access to frequently used operations. User can choose between; buttons and drawnbuttons (let's say icons) and assign to them his; own actions (let's say ROOT or C++ commands). The macro belows shows an example of controlbar.; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:722,Security,access,access,722,". TControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TControlBar. class TControlBar: public TControlBarButton. ControlBar is fully user configurable tool which provides fast; access to frequently used operations. User can choose between; buttons and drawnbuttons (let's say icons) and assign to them his; own actions (let's say ROOT or C++ commands). The macro belows shows an example of controlbar.; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:2211,Testability,benchmark,benchmarks,2211,".AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""gROOT.Reset(\""a\"")"",; ""Close ControlBar"");; bar.Show();; gROOT.SaveContext();; }. /*. */. Function Members (Methods); public:. TControlBar(); TControlBar(const TControlBar&); TControlBar(const char* orientation, const char* title = """"); TControlBar(const char* orientation, const char* title, Int_t x, Int_t y); virtual~TControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTControlBarButton::Action(); voidAddButton(TControlBarButton* button); voidAddButton(TControlBarButton& button); voidAddButton(const char* label, const char* action, const char* hint = """", const char* type = ""button""); voidAddControlBar(TControlBar* controlBar); voidAddControlBar(TControlBar& controlBar);",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:2228,Testability,benchmark,benchmarks,2228,"x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""gROOT.Reset(\""a\"")"",; ""Close ControlBar"");; bar.Show();; gROOT.SaveContext();; }. /*. */. Function Members (Methods); public:. TControlBar(); TControlBar(const TControlBar&); TControlBar(const char* orientation, const char* title = """"); TControlBar(const char* orientation, const char* title, Int_t x, Int_t y); virtual~TControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTControlBarButton::Action(); voidAddButton(TControlBarButton* button); voidAddButton(TControlBarButton& button); voidAddButton(const char* label, const char* action, const char* hint = """", const char* type = ""button""); voidAddControlBar(TControlBar* controlBar); voidAddControlBar(TControlBar& controlBar); voidAddSeparator(); v",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:2263,Testability,benchmark,benchmarks,2263,"ams and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""gROOT.Reset(\""a\"")"",; ""Close ControlBar"");; bar.Show();; gROOT.SaveContext();; }. /*. */. Function Members (Methods); public:. TControlBar(); TControlBar(const TControlBar&); TControlBar(const char* orientation, const char* title = """"); TControlBar(const char* orientation, const char* title, Int_t x, Int_t y); virtual~TControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTControlBarButton::Action(); voidAddButton(TControlBarButton* button); voidAddButton(TControlBarButton& button); voidAddButton(const char* label, const char* action, const char* hint = """", const char* type = ""button""); voidAddControlBar(TControlBar* controlBar); voidAddControlBar(TControlBar& controlBar); voidAddSeparator(); virtual voidTObject::AppendPa",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBar.html:1741,Usability,simpl,simple,1741,"clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""gROOT.Reset(\""a\"")"",; ""Close ControlBar"");; bar.Show();; gROOT.SaveContext();; }. /*. */. Function Members (Methods); public:. TControlBar(); TControlBar(const TControlBar&); TControlBar(const char* orientation, const char* title = """"); TC",MatchSource.WIKI,root/html532/TControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBar.html
https://root.cern/root/html532/TControlBarButton.html:1618,Availability,error,error,1618,"button""); virtual~TControlBarButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAction() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html532/TControlBarButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBarButton.html
https://root.cern/root/html532/TControlBarButton.html:1702,Availability,error,error,1702,"d) const; virtual voidAction(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAction() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFro",MatchSource.WIKI,root/html532/TControlBarButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBarButton.html
https://root.cern/root/html532/TControlBarButton.html:400,Energy Efficiency,consumption,consumption,400,". TControlBarButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TControlBarButton. class TControlBarButton: public TNamed. TControlBarButton. TControlBarButtons are created by the TControlBar. Not for general; consumption. Function Members (Methods); public:. TControlBarButton(); TControlBarButton(const TControlBarButton&); TControlBarButton(const char* label, const char* action = """", const char* hint = """", const char* type = ""button""); virtual~TControlBarButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidAction(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(c",MatchSource.WIKI,root/html532/TControlBarButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TControlBarButton.html
https://root.cern/root/html532/TCrown.html:2497,Availability,error,error,2497,"ame = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& crown) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTEllipse::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCrown(Double_t x1, Double_t y1, Double_t radin, Double_t radout, Double_t phimin = 0, Double_t phimax = 360, Option_t* option = """"); virtual voidTEllipse::DrawEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, Double_t theta, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllips",MatchSource.WIKI,root/html532/TCrown.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCrown.html
https://root.cern/root/html532/TCrown.html:2581,Availability,error,error,2581,"idCopy(TObject& crown) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTEllipse::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCrown(Double_t x1, Double_t y1, Double_t radin, Double_t radout, Double_t phimin = 0, Double_t phimax = 360, Option_t* option = """"); virtual voidTEllipse::DrawEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, Double_t theta, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllipse::GetPhimin() const; Double_tTEllipse::GetR1() const; Double_tTEllipse::GetR2() con",MatchSource.WIKI,root/html532/TCrown.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCrown.html
https://root.cern/root/html532/TCTUB.html:2448,Availability,error,error,2448,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBS::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBS::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html532/TCTUB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCTUB.html
https://root.cern/root/html532/TCTUB.html:2532,Availability,error,error,2532,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBS::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBS::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html532/TCTUB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCTUB.html
https://root.cern/root/html532/TCurlyArc.html:2054,Availability,error,error,2054,"se(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTCurlyLine::GetAmplitude() const; Bool_tTCurlyLine::GetCurly() const; static Double_tGetDefaultAmplitude(); static Bool_tGetDefaultIsCurly(); static Double_tGetDefaultWaveLength(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTCurlyLine::GetEndX() const; Double_tTCurlyLine::GetEndY() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tTPolyLine::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAt",MatchSource.WIKI,root/html532/TCurlyArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArc.html
https://root.cern/root/html532/TCurlyArc.html:2138,Availability,error,error,2138,"ect::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTCurlyLine::GetAmplitude() const; Bool_tTCurlyLine::GetCurly() const; static Double_tGetDefaultAmplitude(); static Bool_tGetDefaultIsCurly(); static Double_tGetDefaultWaveLength(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTCurlyLine::GetEndX() const; Double_tTCurlyLine::GetEndY() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tTPolyLine::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine::GetN() const; virtual const char*TObjec",MatchSource.WIKI,root/html532/TCurlyArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArc.html
https://root.cern/root/html532/TCurlyArc.html:11244,Deployability,release,released,11244,"edefault amplitude; static Bool_tfgDefaultIsCurlydefault curly type; static Double_tfgDefaultWaveLengthdefault wavelength . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCurlyArc(Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl = .02, Double_t amp = .01); create a new TCurlyarc with center (x1, y1) and radius rad.; The wavelength and amplitude are given in percent of the line length; phimin and phimax are given in degrees. void Build(); Create a curly (Gluon) or wavy (Gamma) arc. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an arc. Compute the closest distance of approach from point px,py to this arc.; The distance is computed in pixels units. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TCurlyArc is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void SavePrimitive(ostream& out, Option_t* = """"); Save primitive as a C++ statement(s) on output stream out. void SetCenter(Double_t x1, Double_t y1); Set Curly Arc center. void SetRadius(Double_t radius); Set Curly Arc radius. void SetPhimin(Double_t phimin); Set Curly Arc minimum Phi. void SetPhimax(Double_t phimax); Set Curly Arc maximum Phi. void SetDefaultWaveLength(Double_t WaveLength); Set default wave length. void SetDefaultAmplitude(Double_t Amplitude); Set default wave amplitude. void SetDefaultIsCurly(Bool_t IsCurly); Set default ""IsCurly"". Double_t GetDefaultWaveLength(); Get default wave length. Double_t GetDefaultAmplitude(); Get default wave amplitude. Bool_t GetDefaultIsCurly(); Get default ""IsCurly"". TCurlyArc(); {;}. TCurlyArc(Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl = .02, Do",MatchSource.WIKI,root/html532/TCurlyArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArc.html
https://root.cern/root/html532/TCurlyArc.html:11338,Deployability,release,released,11338,"default wavelength . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCurlyArc(Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl = .02, Double_t amp = .01); create a new TCurlyarc with center (x1, y1) and radius rad.; The wavelength and amplitude are given in percent of the line length; phimin and phimax are given in degrees. void Build(); Create a curly (Gluon) or wavy (Gamma) arc. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an arc. Compute the closest distance of approach from point px,py to this arc.; The distance is computed in pixels units. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TCurlyArc is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void SavePrimitive(ostream& out, Option_t* = """"); Save primitive as a C++ statement(s) on output stream out. void SetCenter(Double_t x1, Double_t y1); Set Curly Arc center. void SetRadius(Double_t radius); Set Curly Arc radius. void SetPhimin(Double_t phimin); Set Curly Arc minimum Phi. void SetPhimax(Double_t phimax); Set Curly Arc maximum Phi. void SetDefaultWaveLength(Double_t WaveLength); Set default wave length. void SetDefaultAmplitude(Double_t Amplitude); Set default wave amplitude. void SetDefaultIsCurly(Bool_t IsCurly); Set default ""IsCurly"". Double_t GetDefaultWaveLength(); Get default wave length. Double_t GetDefaultAmplitude(); Get default wave amplitude. Bool_t GetDefaultIsCurly(); Get default ""IsCurly"". TCurlyArc(); {;}. TCurlyArc(Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl = .02, Double_t amp = .01); {;}. Double_t GetRadius() const; {return fR1;}. Double_t GetPhimin() const; {return",MatchSource.WIKI,root/html532/TCurlyArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArc.html
https://root.cern/root/html532/TCurlyArc.html:527,Modifiability,inherit,inheritance,527,". TCurlyArc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TCurlyArc. class TCurlyArc: public TCurlyLine. This class implements curly or wavy arcs typically used to draw Feynman diagrams.; Amplitudes and wavelengths may be specified in the constructors,; via commands or interactively from popup menus.; The class make use of TCurlyLine by inheritance, ExecuteEvent methods; are highly inspired from the methods used in TPolyLine and TArc.; The picture below has been generated by the tutorial feynman. /*. */. Function Members (Methods); public:. TCurlyArc(); TCurlyArc(const TCurlyArc&); TCurlyArc(Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl = .02, Double_t amp = .01); virtual~TCurlyArc(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Ex",MatchSource.WIKI,root/html532/TCurlyArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArc.html
https://root.cern/root/html532/TCurlyArcEditor.html:4630,Availability,error,error,4630,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TCurlyArcEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArcEditor.html
https://root.cern/root/html532/TCurlyArcEditor.html:4714,Availability,error,error,4714,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TCurlyArcEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArcEditor.html
https://root.cern/root/html532/TCurlyArcEditor.html:17617,Availability,mask,mask,17617,,MatchSource.WIKI,root/html532/TCurlyArcEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyArcEditor.html
https://root.cern/root/html532/TCurlyLine.html:2043,Availability,error,error,2043,"se(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAmplitude() const; Bool_tGetCurly() const; static Double_tGetDefaultAmplitude(); static Bool_tGetDefaultIsCurly(); static Double_tGetDefaultWaveLength(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEndX() const; Double_tGetEndY() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tTPolyLine::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine::Get",MatchSource.WIKI,root/html532/TCurlyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLine.html
https://root.cern/root/html532/TCurlyLine.html:2127,Availability,error,error,2127,"ect::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAmplitude() const; Bool_tGetCurly() const; static Double_tGetDefaultAmplitude(); static Bool_tGetDefaultIsCurly(); static Double_tGetDefaultWaveLength(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEndX() const; Double_tGetEndY() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tTPolyLine::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObj",MatchSource.WIKI,root/html532/TCurlyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLine.html
https://root.cern/root/html532/TCurlyLine.html:10234,Deployability,release,released,10234,"PolyLine::fY[fN] Array of Y coordinates; Double_tfY1start y, center for arc; Double_tfY2end y; static Double_tfgDefaultAmplitudedefault amplitude; static Bool_tfgDefaultIsCurlydefault curly type; static Double_tfgDefaultWaveLengthdefault wavelength. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCurlyLine(); Default constructor. TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t wl = .02, Double_t amp = .01); Create a new TCurlyLine with starting point (x1, y1), end point (x2,y2).; The wavelength and amplitude are given in percent of the pad height. void Build(); Create a curly (Gluon) or wavy (Gamma) line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TCurlyLine is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void SavePrimitive(ostream& out, Option_t* = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurly(); Set curly. void SetWavy(); Set wavy. void SetWaveLength(Double_t WaveLength); Set wave length. void SetAmplitude(Double_t x); Set amplitude. void SetStartPoint(Double_t x1, Double_t y1); Set start point. void SetEndPoint(Double_t x2, Double_t y2); Set edn point. void SetDefaultWaveLength(Double_t WaveLength); Set default wave length. void SetDefaultAmplitude(Double_t Amplitude); Set default amplitude. void SetDefaultIsCurly(Bool_t IsCurly); Set defaul ""IsCurly"". Double_t GetDefaultWaveLength(); Get default wave length. Double_t GetDefaultAmplitude(); Get default amplitude. Bool_t GetDefaultIsCurly(); Get default ""IsCurly"". TCurlyLine(). virtual ~TCurlyLine(); {;}. Bool_t GetCurly() const; {return fIsCurly;}. Double",MatchSource.WIKI,root/html532/TCurlyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLine.html
https://root.cern/root/html532/TCurlyLine.html:10328,Deployability,release,released,10328,"ouble_tfgDefaultAmplitudedefault amplitude; static Bool_tfgDefaultIsCurlydefault curly type; static Double_tfgDefaultWaveLengthdefault wavelength. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCurlyLine(); Default constructor. TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t wl = .02, Double_t amp = .01); Create a new TCurlyLine with starting point (x1, y1), end point (x2,y2).; The wavelength and amplitude are given in percent of the pad height. void Build(); Create a curly (Gluon) or wavy (Gamma) line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TCurlyLine is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void SavePrimitive(ostream& out, Option_t* = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurly(); Set curly. void SetWavy(); Set wavy. void SetWaveLength(Double_t WaveLength); Set wave length. void SetAmplitude(Double_t x); Set amplitude. void SetStartPoint(Double_t x1, Double_t y1); Set start point. void SetEndPoint(Double_t x2, Double_t y2); Set edn point. void SetDefaultWaveLength(Double_t WaveLength); Set default wave length. void SetDefaultAmplitude(Double_t Amplitude); Set default amplitude. void SetDefaultIsCurly(Bool_t IsCurly); Set defaul ""IsCurly"". Double_t GetDefaultWaveLength(); Get default wave length. Double_t GetDefaultAmplitude(); Get default amplitude. Bool_t GetDefaultIsCurly(); Get default ""IsCurly"". TCurlyLine(). virtual ~TCurlyLine(); {;}. Bool_t GetCurly() const; {return fIsCurly;}. Double_t GetWaveLength() const; {return fWaveLength;}. Double_t GetAmplitude() const; {return fAmplitude;}. ",MatchSource.WIKI,root/html532/TCurlyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLine.html
https://root.cern/root/html532/TCurlyLine.html:533,Modifiability,inherit,inheritance,533,". TCurlyLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TCurlyLine. class TCurlyLine: public TPolyLine. This class implements curly or wavy polylines typically used to draw Feynman diagrams.; Amplitudes and wavelengths may be specified in the constructors,; via commands or interactively from popup menus.; The class make use of TPolyLine by inheritance, ExecuteEvent methods; are highly inspired from the methods used in TPolyLine and TArc.; The picture below has been generated by the tutorial feynman. /*. */. Function Members (Methods); public:. TCurlyLine(); TCurlyLine(const TCurlyLine&); TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t wl = .02, Double_t amp = .01); virtual~TCurlyLine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPolyLine::Copy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyLine::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyLine::DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root/html532/TCurlyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLine.html
https://root.cern/root/html532/TCurlyLineEditor.html:4652,Availability,error,error,4652,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TCurlyLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLineEditor.html
https://root.cern/root/html532/TCurlyLineEditor.html:4736,Availability,error,error,4736,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TCurlyLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLineEditor.html
https://root.cern/root/html532/TCurlyLineEditor.html:17670,Availability,mask,mask,17670,,MatchSource.WIKI,root/html532/TCurlyLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCurlyLineEditor.html
https://root.cern/root/html532/TCut.html:1953,Availability,error,error,1953," TCut(const TCut& cut); TCut(const char* name, const char* title); virtual~TCut(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html532/TCut.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCut.html
https://root.cern/root/html532/TCut.html:2037,Availability,error,error,2037,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html532/TCut.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCut.html
https://root.cern/root/html532/TCut.html:474,Testability,log,logical,474,". TCut. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TCut. class TCut: public TNamed. TCut. A specialized string object used for TTree selections.; A TCut object has a name and a title. It does not add any data; members compared to a TNamed. It only add a set of operators to; facilitate logical string concatenation. For example, assume; cut1 = ""x<1"" and cut2 = ""y>2""; then; cut1 && cut2 will be the string ""(x<1)&&(y>2)"". Operators =, +=, +, *, !, &&, || overloaded. Examples of use:; Root > TCut c1 = ""x<1""; Root > TCut c2 = ""y<0""; Root > TCut c3 = c1&&c2; Root > ntuple.Draw(""x"", c1); Root > ntuple.Draw(""x"", c1||""x>0""); Root > ntuple.Draw(""x"", c1&&c2); Root > ntuple.Draw(""x"", ""(x+y)""*(c1&&c2)). Function Members (Methods); public:. TCut(); TCut(const char* title); TCut(const TCut& cut); TCut(const char* name, const char* title); virtual~TCut(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod",MatchSource.WIKI,root/html532/TCut.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCut.html
https://root.cern/root/html532/TCutG.html:4921,Availability,error,error,4921,"ject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGraph::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGraph::Draw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGraph::DrawGraph(Int_t n, const Int_t* x, const Int_t* y, Option_t* option = """"); virtual voidTGraph::DrawGraph(Int_t n, const Float_t* x, const Float_t* y, Option_t* option = """"); virtual voidTGraph::DrawGraph(Int_t n, const Double_t* x = 0, const Double_t* y = 0, Option_t* option = """"); virtual voidTGraph::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTGraph::Eval(Double_t x, TSpline* spline = 0, Option_t* option = """") const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTGraph::Expand(Int_t newsize); virtual voidTGraph::Expand(Int_t newsize, Int_t step); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TGraph::FindObject(const char* name) const; virtual TObject*TGraph::FindObject(const TObject* obj) const; virtual TFitResultPtrTGraph::Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0)MENU ; virtual TFitResultPtrTGraph::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual voidTGraph::FitPanel()MENU ; virtual Double_tTGraph::GetCorrelationFactor() const; virtual Double_tTGraph::GetCovariance() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tTGra",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:5005,Availability,error,error,5005,"t_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGraph::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGraph::Draw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGraph::DrawGraph(Int_t n, const Int_t* x, const Int_t* y, Option_t* option = """"); virtual voidTGraph::DrawGraph(Int_t n, const Float_t* x, const Float_t* y, Option_t* option = """"); virtual voidTGraph::DrawGraph(Int_t n, const Double_t* x = 0, const Double_t* y = 0, Option_t* option = """"); virtual voidTGraph::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTGraph::Eval(Double_t x, TSpline* spline = 0, Option_t* option = """") const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTGraph::Expand(Int_t newsize); virtual voidTGraph::Expand(Int_t newsize, Int_t step); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TGraph::FindObject(const char* name) const; virtual TObject*TGraph::FindObject(const TObject* obj) const; virtual TFitResultPtrTGraph::Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0)MENU ; virtual TFitResultPtrTGraph::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual voidTGraph::FitPanel()MENU ; virtual Double_tTGraph::GetCorrelationFactor() const; virtual Double_tTGraph::GetCovariance() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tTGraph::GetEditable() const; virtual Double_tTGraph::GetErrorX(Int_t bin) const; virtual",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:16741,Energy Efficiency,reduce,reduces,16741,"nt_tTGraph::fNpointsNumber of points <= fMaxSize; TObject*fObjectX!pointer to an object corresponding to X; TObject*fObjectY!pointer to an object corresponding to Y; TStringTNamed::fTitleobject title; TStringfVarXX variable; TStringfVarYY variable; Double_t*TGraph::fX[fNpoints] array of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffe",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:17025,Energy Efficiency,reduce,reduces,17025," of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffer& b); Stream an object of class TCutG. TObject * GetObjectX() const; {return fObjectX;}. TObject * GetObjectY() const; {return fObjectY;}. const char * GetVarX() const; {return fVarX.Data();}. const char * GetVarY() const; {return fVarY.Data();}. » Author: Rene Brun 16/05/97 » Copyr",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:922,Modifiability,variab,variables,922,". TCutG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TCutG. class TCutG: public TGraph. Graphical cut class; A Graphical cut. A TCutG object is a closed polygon defining a closed region in a x,y plot.; It can be created via the graphics editor option ""CutG"" or directly by; invoking its constructor. The first and last points should be the same. To create a TCutG via the graphics editor, use the left button to select the; points building the contour of the cut. Click on the right button to close the; TCutG. When it is created via the graphics editor, the TCutG object is named; ""CUTG"". It is recommended to immediatly change the name by using the context; menu item ""SetName"". When the graphics editor is used, the names of the; variables X,Y are automatically taken from the current pad title. Example:. Assume a TTree object T and:. Root > T.Draw(""abs(fMomemtum)%fEtot""). the TCutG members fVarX, fVary will be set to:. fVarx = fEtot; fVary = abs(fMomemtum). A graphical cut can be used in a TTree selection expression:. Root > T.Draw(""fEtot"",""cutg1""). where ""cutg1"" is the name of an existing graphical cut. Note that, as shown in the example above, a graphical cut may be used in a; selection expression when drawing TTrees expressions of 1-d, 2-d or; 3-dimensions. The expressions used in TTree::Draw can reference the variables in; the fVarX, fVarY of the graphical cut plus other variables. When the TCutG object is created by TTree::Draw, it is added to the list of special objects in; the main TROOT object pointed by gROOT. To retrieve a pointer to this object; from the code or command line, do:. TCutG *mycutg;; mycutg = (TCutG*)gROOT->GetListOfSpecials()->FindObject(""CUTG""); mycutg->SetName(""mycutg"");. When the TCutG is not created via TTree::Draw, one must set the variable names; correspondi",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:1517,Modifiability,variab,variables,1517,"he same. To create a TCutG via the graphics editor, use the left button to select the; points building the contour of the cut. Click on the right button to close the; TCutG. When it is created via the graphics editor, the TCutG object is named; ""CUTG"". It is recommended to immediatly change the name by using the context; menu item ""SetName"". When the graphics editor is used, the names of the; variables X,Y are automatically taken from the current pad title. Example:. Assume a TTree object T and:. Root > T.Draw(""abs(fMomemtum)%fEtot""). the TCutG members fVarX, fVary will be set to:. fVarx = fEtot; fVary = abs(fMomemtum). A graphical cut can be used in a TTree selection expression:. Root > T.Draw(""fEtot"",""cutg1""). where ""cutg1"" is the name of an existing graphical cut. Note that, as shown in the example above, a graphical cut may be used in a; selection expression when drawing TTrees expressions of 1-d, 2-d or; 3-dimensions. The expressions used in TTree::Draw can reference the variables in; the fVarX, fVarY of the graphical cut plus other variables. When the TCutG object is created by TTree::Draw, it is added to the list of special objects in; the main TROOT object pointed by gROOT. To retrieve a pointer to this object; from the code or command line, do:. TCutG *mycutg;; mycutg = (TCutG*)gROOT->GetListOfSpecials()->FindObject(""CUTG""); mycutg->SetName(""mycutg"");. When the TCutG is not created via TTree::Draw, one must set the variable names; corresponding to x,y if one wants to use the cut as input to TTree::Draw,eg. TCutG *cutg = new TCutG(""mycut"",5);; cutg->SetVarX(""y"");; cutg->SetVarY(""x"");; cutg->SetPoint(0,-0.3586207,1.509534);; cutg->SetPoint(1,-1.894181,-0.529661);; cutg->SetPoint(2,0.07780173,-1.21822);; cutg->SetPoint(3,-1.0375,-0.07944915);; cutg->SetPoint(4,0.756681,0.1853814);; cutg->SetPoint(5,-0.3586207,1.509534);. ; Example of use of a TCutG in TTree::Draw:. tree.Draw(""x:y"",""mycutg && z>0 %% sqrt(x)>1""). A Graphical cut may be drawn via TGraph::Draw. It",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:1580,Modifiability,variab,variables,1580,"he same. To create a TCutG via the graphics editor, use the left button to select the; points building the contour of the cut. Click on the right button to close the; TCutG. When it is created via the graphics editor, the TCutG object is named; ""CUTG"". It is recommended to immediatly change the name by using the context; menu item ""SetName"". When the graphics editor is used, the names of the; variables X,Y are automatically taken from the current pad title. Example:. Assume a TTree object T and:. Root > T.Draw(""abs(fMomemtum)%fEtot""). the TCutG members fVarX, fVary will be set to:. fVarx = fEtot; fVary = abs(fMomemtum). A graphical cut can be used in a TTree selection expression:. Root > T.Draw(""fEtot"",""cutg1""). where ""cutg1"" is the name of an existing graphical cut. Note that, as shown in the example above, a graphical cut may be used in a; selection expression when drawing TTrees expressions of 1-d, 2-d or; 3-dimensions. The expressions used in TTree::Draw can reference the variables in; the fVarX, fVarY of the graphical cut plus other variables. When the TCutG object is created by TTree::Draw, it is added to the list of special objects in; the main TROOT object pointed by gROOT. To retrieve a pointer to this object; from the code or command line, do:. TCutG *mycutg;; mycutg = (TCutG*)gROOT->GetListOfSpecials()->FindObject(""CUTG""); mycutg->SetName(""mycutg"");. When the TCutG is not created via TTree::Draw, one must set the variable names; corresponding to x,y if one wants to use the cut as input to TTree::Draw,eg. TCutG *cutg = new TCutG(""mycut"",5);; cutg->SetVarX(""y"");; cutg->SetVarY(""x"");; cutg->SetPoint(0,-0.3586207,1.509534);; cutg->SetPoint(1,-1.894181,-0.529661);; cutg->SetPoint(2,0.07780173,-1.21822);; cutg->SetPoint(3,-1.0375,-0.07944915);; cutg->SetPoint(4,0.756681,0.1853814);; cutg->SetPoint(5,-0.3586207,1.509534);. ; Example of use of a TCutG in TTree::Draw:. tree.Draw(""x:y"",""mycutg && z>0 %% sqrt(x)>1""). A Graphical cut may be drawn via TGraph::Draw. It",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:1974,Modifiability,variab,variable,1974," Example:. Assume a TTree object T and:. Root > T.Draw(""abs(fMomemtum)%fEtot""). the TCutG members fVarX, fVary will be set to:. fVarx = fEtot; fVary = abs(fMomemtum). A graphical cut can be used in a TTree selection expression:. Root > T.Draw(""fEtot"",""cutg1""). where ""cutg1"" is the name of an existing graphical cut. Note that, as shown in the example above, a graphical cut may be used in a; selection expression when drawing TTrees expressions of 1-d, 2-d or; 3-dimensions. The expressions used in TTree::Draw can reference the variables in; the fVarX, fVarY of the graphical cut plus other variables. When the TCutG object is created by TTree::Draw, it is added to the list of special objects in; the main TROOT object pointed by gROOT. To retrieve a pointer to this object; from the code or command line, do:. TCutG *mycutg;; mycutg = (TCutG*)gROOT->GetListOfSpecials()->FindObject(""CUTG""); mycutg->SetName(""mycutg"");. When the TCutG is not created via TTree::Draw, one must set the variable names; corresponding to x,y if one wants to use the cut as input to TTree::Draw,eg. TCutG *cutg = new TCutG(""mycut"",5);; cutg->SetVarX(""y"");; cutg->SetVarY(""x"");; cutg->SetPoint(0,-0.3586207,1.509534);; cutg->SetPoint(1,-1.894181,-0.529661);; cutg->SetPoint(2,0.07780173,-1.21822);; cutg->SetPoint(3,-1.0375,-0.07944915);; cutg->SetPoint(4,0.756681,0.1853814);; cutg->SetPoint(5,-0.3586207,1.509534);. ; Example of use of a TCutG in TTree::Draw:. tree.Draw(""x:y"",""mycutg && z>0 %% sqrt(x)>1""). A Graphical cut may be drawn via TGraph::Draw. It can be edited like a normal; TGraph. A Graphical cut may be saved to a file via TCutG::Write.; . Function Members (Methods); public:. TCutG(); TCutG(const TCutG& cutg); TCutG(const char* name, Int_t n); TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); virtual~TCutG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* opt",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:15980,Modifiability,variab,variable,15980," iend); virtual voidTGraph::SwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum TGraph::[unnamed] { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*TGraph::fFunctionsPointer to list of functions (fits and user); TH1F*TGraph::fHistogramPointer to histogram used for drawing axis; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTGraph::fMaxSize!Current dimension of arrays fX and fY; Double_tTGraph::fMaximumMaximum value for plotting along y; Double_tTGraph::fMinimumMinimum value for plotting along y; TStringTNamed::fNameobject identifier; Int_tTGraph::fNpointsNumber of points <= fMaxSize; TObject*fObjectX!pointer to an object corresponding to X; TObject*fObjectY!pointer to an object corresponding to Y; TStringTNamed::fTitleobject title; TStringfVarXX variable; TStringfVarYY variable; Double_t*TGraph::fX[fNpoints] array of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() ",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:16004,Modifiability,variab,variable,16004," iend); virtual voidTGraph::SwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum TGraph::[unnamed] { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*TGraph::fFunctionsPointer to list of functions (fits and user); TH1F*TGraph::fHistogramPointer to histogram used for drawing axis; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTGraph::fMaxSize!Current dimension of arrays fX and fY; Double_tTGraph::fMaximumMaximum value for plotting along y; Double_tTGraph::fMinimumMinimum value for plotting along y; TStringTNamed::fNameobject identifier; Int_tTGraph::fNpointsNumber of points <= fMaxSize; TObject*fObjectX!pointer to an object corresponding to X; TObject*fObjectY!pointer to an object corresponding to Y; TStringTNamed::fTitleobject title; TStringfVarXX variable; TStringfVarYY variable; Double_t*TGraph::fX[fNpoints] array of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() ",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:17688,Modifiability,variab,variable,17688,"e, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffer& b); Stream an object of class TCutG. TObject * GetObjectX() const; {return fObjectX;}. TObject * GetObjectY() const; {return fObjectY;}. const char * GetVarX() const; {return fVarX.Data();}. const char * GetVarY() const; {return fVarY.Data();}. » Author: Rene Brun 16/05/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id: TCutG.h 37309 2010-12-06 00:10:29Z pcanal $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TCutG.html:17736,Modifiability,variab,variable,17736,"e, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffer& b); Stream an object of class TCutG. TObject * GetObjectX() const; {return fObjectX;}. TObject * GetObjectY() const; {return fObjectY;}. const char * GetVarX() const; {return fVarX.Data();}. const char * GetVarY() const; {return fVarY.Data();}. » Author: Rene Brun 16/05/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id: TCutG.h 37309 2010-12-06 00:10:29Z pcanal $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TCutG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TCutG.html
https://root.cern/root/html532/TDatabasePDG.html:2453,Availability,error,error,2453,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tConvertGeant3ToPdg(Int_t Geant3Number); virtual Int_tConvertIsajetToPdg(Int_t isaNumber); virtual Int_tConvertPdgToGeant3(Int_t pdgNumber); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParticlePDG*GetParticle(Int_t pdgCode) const; TParticlePDG*GetParticle(const char* name) const; TParticleClassPDG*GetParticleClass(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root/html532/TDatabasePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html
https://root.cern/root/html532/TDatabasePDG.html:2537,Availability,error,error,2537,"atic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tConvertGeant3ToPdg(Int_t Geant3Number); virtual Int_tConvertIsajetToPdg(Int_t isaNumber); virtual Int_tConvertPdgToGeant3(Int_t pdgNumber); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParticlePDG*GetParticle(Int_t pdgCode) const; TParticlePDG*GetParticle(const char* name) const; TParticleClassPDG*GetParticleClass(const char* name); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Inf",MatchSource.WIKI,root/html532/TDatabasePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html
https://root.cern/root/html532/TDatabasePDG.html:8232,Energy Efficiency,energy,energy,8232,"DG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. TParticlePDG* AddAntiParticle(const char* Name, Int_t PdgCode); assuming particle has already been defined. TParticlePDG * GetParticle(const char* name) const. Get a pointer to the particle object according to the name given. TParticlePDG * GetParticle(Int_t pdgCode) const. Get a pointer to the particle object according to the MC code number. void Print(Option_t* opt = """") const; Print contents of PDG database. Int_t ConvertGeant3ToPdg(Int_t Geant3Number); Converts Geant3 particle codes to PDG convention. (Geant4 uses; PDG convention already); Source: BaBar User Guide, Neil I. Geddes,. /*; see Conversion table; */. with some fixes by PB, marked with (PB) below. Checked against; PDG listings from 2000. Paul Balm, Nov 19, 2001. Int_t ConvertPdgToGeant3(Int_t pdgNumber); Converts pdg code to geant3 id. Int_t ConvertIsajetToPdg(Int_t isaNumber). Converts the ISAJET Particle number into the PDG MC number. void ReadPDGTable(const char* ",MatchSource.WIKI,root/html532/TDatabasePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html
https://root.cern/root/html532/TDatabasePDG.html:7001,Security,hash,hash-map,7001,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWritePDGTable(const char* filename). protected:. TDatabasePDG(const TDatabasePDG& db); voidBuildPdgMap() const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TDatabasePDG&operator=(const TDatabasePDG& db). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfClasseslist of classes (leptons etc.); TStringTNamed::fNameobject identifier; THashList*fParticleListlist of PDG particles; TExMap*fPdgMap!hash-map from pdg-code to particle; TStringTNamed::fTitleobject title; static TDatabasePDG*fgInstanceprotect against multiple instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatabasePDG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does hav",MatchSource.WIKI,root/html532/TDatabasePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html
https://root.cern/root/html532/TDatabasePDG.html:8224,Testability,log,logwise,8224,"DG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. TParticlePDG* AddAntiParticle(const char* Name, Int_t PdgCode); assuming particle has already been defined. TParticlePDG * GetParticle(const char* name) const. Get a pointer to the particle object according to the name given. TParticlePDG * GetParticle(Int_t pdgCode) const. Get a pointer to the particle object according to the MC code number. void Print(Option_t* opt = """") const; Print contents of PDG database. Int_t ConvertGeant3ToPdg(Int_t Geant3Number); Converts Geant3 particle codes to PDG convention. (Geant4 uses; PDG convention already); Source: BaBar User Guide, Neil I. Geddes,. /*; see Conversion table; */. with some fixes by PB, marked with (PB) below. Checked against; PDG listings from 2000. Paul Balm, Nov 19, 2001. Int_t ConvertPdgToGeant3(Int_t pdgNumber); Converts pdg code to geant3 id. Int_t ConvertIsajetToPdg(Int_t isaNumber). Converts the ISAJET Particle number into the PDG MC number. void ReadPDGTable(const char* ",MatchSource.WIKI,root/html532/TDatabasePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html
https://root.cern/root/html532/TDataMember.html:6280,Availability,error,error,6280,,MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:6364,Availability,error,error,6364,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayDim() const; const char*GetArrayIndex() const; TClass*GetClass() const; TDataType*GetDataType() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; Int_tGetMaxIndex(Int_t dim) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long_tGetOffset() const; Long_tGetOffsetCint() const; virtual Option_t*",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:2856,Integrability,rout,routines,2856,"now,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few lines which get and set; a fEditable field in TCanvas:. ; /*; TCanvas *c = new TCanvas(""c""); // create a canvas; TClass *cl = c->IsA(); // get its class description object.; TDataMember *dm = cl->GetDataMember(""fEditable""); //This is our data member; TMethodCall *getter = dm->GetterMethod(c); //find a method that gets value!; Long_t l; // declare a storage for this value;; getter->Execute(c,"""",l); // Get this Value !!!! It will appear in l !!!; TMethodCall *setter = dm->SetterMethod(c);; setter->Execute(c,""0"",); // Set Value 0 !!!; */. This trick is widely used in ROOT TContextMenu and dialogs for obtaining; current values and put them as initial values in dialog fields. If you don't want to follow the convention of naming used by ROOT; you still could benefit from Getter/Setter method support: the solution; is to instruct ROOT what the names of these routines are.; The way to do it is putting this information in a comment string to a data; field in your class declaration:. ; /*; class MyClass{; Int_t mydata; // *OPTIONS={GetMethod=""Get"";SetMethod=""Set""} ; ...; Int_t Get() const { return mydata;};; void Set(Int_t i) {mydata=i;};; }; */. However, this getting/setting functions are not the only feature of; this class. The next point is providing lists of possible settings; for the concerned data member. The idea is to have a list of possible; options for this data member, with strings identifying them. This; is used in dialogs with parameters to set - for details see; TMethodArg, TRootContextMenu, TContextMenu. This list not only specifies; the allowed value, but also provides strings naming the options.; Options are managed via TList of TOptionListItem objects. This list; is also created automatically: if a data type is an enum tynpe,; the list will",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:14072,Modifiability,inherit,inheritance,14072,"peName() const; Get full type description of data member, e,g.: ""class TDirectory*"". Long_t GetOffset() const; Get offset from ""this"". Long_t GetOffsetCint() const; Get offset from ""this"" using the information in CINT only. Int_t GetUnitSize() const; Get the sizeof the underlying type of the data member; (i.e. if the member is an array sizeof(member)/length). Bool_t IsBasic() const; Return true if data member is a basic type, e.g. char, int, long... Bool_t IsEnum() const; Return true if data member is an enum. Bool_t IsaPointer() const; Return true if data member is a pointer. int IsSTLContainer(); The return type is defined in TDictionary (kVector, kList, etc.). Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of options - list of TOptionListItems. TMethodCall * GetterMethod(TClass* cl = 0); Return a TMethodCall method responsible for getting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TMethodCall * SetterMethod(TClass* cl); Return a TMethodCall method responsible for setting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TClass * GetClass() const; { return fClass; }. TDataType * GetDataType() const; { return fDataType; }. Bool_t IsPersistent() const; { return TestBit(kObjIsPersistent); }. » Author: Fons Rademakers 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataMember.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:14380,Modifiability,inherit,inheritance,14380,"peName() const; Get full type description of data member, e,g.: ""class TDirectory*"". Long_t GetOffset() const; Get offset from ""this"". Long_t GetOffsetCint() const; Get offset from ""this"" using the information in CINT only. Int_t GetUnitSize() const; Get the sizeof the underlying type of the data member; (i.e. if the member is an array sizeof(member)/length). Bool_t IsBasic() const; Return true if data member is a basic type, e.g. char, int, long... Bool_t IsEnum() const; Return true if data member is an enum. Bool_t IsaPointer() const; Return true if data member is a pointer. int IsSTLContainer(); The return type is defined in TDictionary (kVector, kList, etc.). Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of options - list of TOptionListItems. TMethodCall * GetterMethod(TClass* cl = 0); Return a TMethodCall method responsible for getting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TMethodCall * SetterMethod(TClass* cl); Return a TMethodCall method responsible for setting the value; of data member. The cl argument specifies the class of the object; which will be used to call this method (in case of multiple; inheritance TMethodCall needs to know this to calculate the proper; offset). TClass * GetClass() const; { return fClass; }. TDataType * GetDataType() const; { return fDataType; }. Bool_t IsPersistent() const; { return TestBit(kObjIsPersistent); }. » Author: Fons Rademakers 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataMember.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:961,Security,access,access,961,". TDataMember. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDataMember. class TDataMember: public TDictionary. TDataMember. All ROOT classes may have RTTI (run time type identification) support; added. The data is stored in so called DICTIONARY (look at TDictionary).; Information about a class is stored in TClass.; This information may be obtained via the CINT api - see class TCint.; TClass has a list of TDataMember objects providing information about all; data members of described class. /*. */. TDataMember provides information about name of data member, its type,; and comment field string. It also tries to find the TMethodCall objects; responsible for getting/setting a value of it, and gives you pointers; to these methods. This gives you a unique possibility to access; protected and private (!) data members if only methods for doing that; are defined.; These methods could either be specified in a comment field, or found; out automatically by ROOT: here's an example:; suppose you have a class definition:. ; /*; class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; */. Look at the data member name and method names: a data member name has; a prefix letter (f) and has a base name X1 . The methods for getting and; setting this value have names which consist of string Get/Set and the; same base name. This convention of naming data fields and methods which; access them allows TDataMember find this methods by itself completely; automatically. To make this description complete, one should know,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few lines whi",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataMember.html:1637,Security,access,access,1637,"ta members of described class. /*. */. TDataMember provides information about name of data member, its type,; and comment field string. It also tries to find the TMethodCall objects; responsible for getting/setting a value of it, and gives you pointers; to these methods. This gives you a unique possibility to access; protected and private (!) data members if only methods for doing that; are defined.; These methods could either be specified in a comment field, or found; out automatically by ROOT: here's an example:; suppose you have a class definition:. ; /*; class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; */. Look at the data member name and method names: a data member name has; a prefix letter (f) and has a base name X1 . The methods for getting and; setting this value have names which consist of string Get/Set and the; same base name. This convention of naming data fields and methods which; access them allows TDataMember find this methods by itself completely; automatically. To make this description complete, one should know,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few lines which get and set; a fEditable field in TCanvas:. ; /*; TCanvas *c = new TCanvas(""c""); // create a canvas; TClass *cl = c->IsA(); // get its class description object.; TDataMember *dm = cl->GetDataMember(""fEditable""); //This is our data member; TMethodCall *getter = dm->GetterMethod(c); //find a method that gets value!; Long_t l; // declare a storage for this value;; getter->Execute(c,"""",l); // Get this Value !!!! It will appear in l !!!; TMethodCall *setter = dm->SetterMethod(c);; setter->Execute(c,""0"",); // Set Value 0 !!!; */. This trick is widely used in ROOT TContextMenu and dialogs for obtaining; current values and put them as initial valu",MatchSource.WIKI,root/html532/TDataMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataMember.html
https://root.cern/root/html532/TDataSet.html:5429,Availability,error,error,5429,"irtual voidAddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidAddFirst(TDataSet* dataset); virtual voidAddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*Find(const char* path) const; virtual TDataSet*FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*FindByPath(const char* path) const; virtual TDataSet*FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* o) const; virtual TDataSet*First() const; virtual TSeqCollection*GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetList() const; virtual Int_tGetListSize() const; static TDataSet*GetMainSet(); TObject*GetMother() ",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSet.html:5513,Availability,error,error,5513,"ataSet* dataset); virtual voidAddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*Find(const char* path) const; virtual TDataSet*FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*FindByPath(const char* path) const; virtual TDataSet*FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* o) const; virtual TDataSet*First() const; virtual TSeqCollection*GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetList() const; virtual Int_tGetListSize() const; static TDataSet*GetMainSet(); TObject*GetMother() const; virtual const char*TNamed::GetName() const; TObjArray*GetObjArray() const; vi",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSet.html:18578,Deployability,update,updates,18578,"= 0). Break the ""parent"" relationship with the current object parent if present; parent != 0 Makes this object the ""Structural Member""; of the ""parent"" dataset; = 0 Makes this object the ""pure Associator"", i.e it makes this; object the ""Structural Member"" of NO other TDataSet. void SetWrite(); One should not use this method but TDataSet::Write instead; This method os left here for the sake of the backward compatibility; To Write object first we should temporary break the; the backward fParent pointer (otherwise ROOT follows this links; and will pull fParent out too. void Shunt(TDataSet* newParent = 0). Remove the object from the original and add it to dataset; TDataSet dataset != 0 - Make this object the ""Structural Member""; of ""dataset""; = 0 - Make this object ""Orphan"". void Update(TDataSet* set, UInt_t opt = 0). Update this TDataSet with ""set"". ATTENTION !!!. This method changes the parent relationships of the input ""set"". void Update(). Update(). Recursively updates all tables for all nested datasets; in inverse order. void Sort(); Sort recursively all members of the TDataSet with TList::Sort method. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0). To Write object first we should temporary break the; the backward fParent pointer (otherwise ROOT follows this links; and will pull fParent out too. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. To Write object first we should temporary break the; the backward fParent pointer (otherwise ROOT follows this links; and will pull fParent out too. void Add(TDataSet* dataset); { AddLast(dataset); }. TDataSet * At(Int_t idx) const; {return fList ? (TDataSet *)fList->At(idx) : 0; }. Int_t GetListSize() const; {return (fList) ? fList->GetSize():0;}. TDataSet * instance(); { return new TDataSet();}. Bool_t IsMarked() const; { return TestBit(kMark); }. void Mark(UInt_t flag, TDataSet::EBitOpt reset = kSet); { SetBit(flag,reset); }. void Mark(); { Mark(kMark,kSet); }. void UnMa",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSet.html:14087,Usability,simpl,simplify,14087,"! Under construction !!!!!; Add TDataSet object at the ""idx"" position in ds; or at the end of the dataset; The final result is defined by either TList::AddAt or TObjArray::AddAt; methods. void AddLast(TDataSet* dataset); Add TDataSet object at the end of the dataset list of this dataset. void AddFirst(TDataSet* dataset); Add TDataSet object at the beginning of the dataset list of this dataset. void Browse(TBrowser* b); Browse this dataset (called by TBrowser). TObject * Clone(const char* newname = """") const; the custom implementation fo the TObject::Clone. void Delete(Option_t* opt = """"). Delete - deletes the list of the TDataSet objects and all ""Structural Members""; as well; This method doesn't affect the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data s",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSet.html:14442,Usability,simpl,simplify,14442,"ning of the dataset list of this dataset. void Browse(TBrowser* b); Browse this dataset (called by TBrowser). TObject * Clone(const char* newname = """") const; the custom implementation fo the TObject::Clone. void Delete(Option_t* opt = """"). Delete - deletes the list of the TDataSet objects and all ""Structural Members""; as well; This method doesn't affect the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data set. TDataSet * GetMainSet(); return pointer to the main dataset. TObject * GetObject() const; The depricated method (left here for the sake of the backward compatibility). TDataSet * Last() const; Return the last object in the list. Returns 0 when list is empty. TDataSet * Next() const; Return the object next to this one in the parent structure; This co",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSet.html:14796,Usability,simpl,simplify,14796,"ct the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data set. TDataSet * GetMainSet(); return pointer to the main dataset. TObject * GetObject() const; The depricated method (left here for the sake of the backward compatibility). TDataSet * Last() const; Return the last object in the list. Returns 0 when list is empty. TDataSet * Next() const; Return the object next to this one in the parent structure; This convinient but time-consuming. Don't use it in the inner loops. TDataSet * Prev() const; Return the object that is previous to this one in the parent structure; This convinient but time-consuming. Don't use it in the inner loops. void SetObject(TObject* obj); The depricated method (left here for the sake of the backward compatibility). void ls(Option_t* ",MatchSource.WIKI,root/html532/TDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSet.html
https://root.cern/root/html532/TDataSetIter.html:2043,Availability,error,error,2043,"tual voidTObject::Browse(TBrowser* b); virtual TDataSet*Cd(const Char_t* dirname); virtual TDataSet*Cd(TDataSet* ds); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TDataSet*Cwd() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDf() const; virtual TDataSet*Dir(Char_t* dirname); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDu() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TDataSet*Find(const Char_t* path, TDataSet* rootset = 0, Bool_t mkdir = kFALSE, Bool_t titleFlag = kFALSE); virtual TDataSet*FindByName(const Char_t* name, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindByPath(const Char_t* path, TDataSet* rootset = 0, Bool_t mkdir = kFALSE); virtual TDataSet*FindByPointer(TDataSet* set, const Char_t* path = 0, Option_t* opt = """"); virtual TDataSet*FindByTitle(const Char_t* title, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindDataSet(const Char_t* name, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindDataSet(TDataSet* set, const Char_t* path, Option_t* opt = """"); virtual TObject*FindObject(const Char_t* name) const; virtual TObject*FindObject(const TObjec",MatchSource.WIKI,root/html532/TDataSetIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetIter.html
https://root.cern/root/html532/TDataSetIter.html:2127,Availability,error,error,2127,"irtual TDataSet*Cd(TDataSet* ds); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TDataSet*Cwd() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDf() const; virtual TDataSet*Dir(Char_t* dirname); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDu() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TDataSet*Find(const Char_t* path, TDataSet* rootset = 0, Bool_t mkdir = kFALSE, Bool_t titleFlag = kFALSE); virtual TDataSet*FindByName(const Char_t* name, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindByPath(const Char_t* path, TDataSet* rootset = 0, Bool_t mkdir = kFALSE); virtual TDataSet*FindByPointer(TDataSet* set, const Char_t* path = 0, Option_t* opt = """"); virtual TDataSet*FindByTitle(const Char_t* title, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindDataSet(const Char_t* name, const Char_t* path = """", Option_t* opt = """"); virtual TDataSet*FindDataSet(TDataSet* set, const Char_t* path, Option_t* opt = """"); virtual TObject*FindObject(const Char_t* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Int_tFlag(UInt_t flag = TDataSet::kMark, TDataSet::EBitOpt re",MatchSource.WIKI,root/html532/TDataSetIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetIter.html
https://root.cern/root/html532/TDataSetManager.html:1775,Availability,error,error,1775,"ol_tCheckDataSetSrvMaps(TUrl* furl, TString& fn, TList* srvmaplist = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual Int_tClearCache(const char* uri); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TStringCreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tFillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* server = 0); virtual TMap*GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport); static TList*GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetGroupQuota(const char* group); virtual TMap*GetGroupQuotaMap(); virtual Long64_tGetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; virtual const char*",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:1859,Availability,error,error,1859,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual Int_tClearCache(const char* uri); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TStringCreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tFillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* server = 0); virtual TMap*GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport); static TList*GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetGroupQuota(const char* group); virtual TMap*GetGroupQuotaMap(); virtual Long64_tGetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) co",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:10438,Availability,avail,available,10438,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManager(const char* group = 0, const char* user = 0, const char* options = 0). Main constructor. ~TDataSetManager(); Destructor. void ParseInitOpts(const char* opts); Parse the opts string and set the init bits accordingly; Available options:; Cq: set kCheckQuota; Ar: set kAllowRegister; Av: set kAllowVerify; Ti: set kTrustInfo; Sb: set kIsSandbox; Ca: set kUseCache or kDoNotUseCache; The opts string may also contain additional unrelated info: in such a case; the field delimited by the prefix ""opt:"" is analyzed, e.g. if opts is; ""/tmp/dataset opt:Cq:-Ar: root://lxb6046.cern.ch"" only the substring; ""Cq:-Ar:"" will be parsed . Bool_t ReadGroupConfig(const char* cf = 0); Read group config file 'cf'.; If cf == 0 re-read, if changed, the file pointed by fGroupConfigFile . expects the following directives:; Group definition:; group <groupname> <user>+; disk quota; property <groupname> diskquota <quota in GB>; average filesize (to be used when the file size is not available); averagefilesize <average size>{G,g,M,m,K,k}. Long64_t ToBytes(const char* size = 0); Static utility function to gt the number of bytes from a string; representation in the form ""<digit><sfx>"" with <sfx> = {"""", ""k"", ""M"", ""G"",; ""T"", ""P""} (case insensitive).; Returns -1 if the format is wrong. TFileCollection * GetDataSet(const char* uri, const char* server = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. TMap * GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (T",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:12870,Availability,failure,failure,12870,"anDataSet(const char* uri, const char* opt); Scans the dataset indicated by 'uri' following the 'opts' directives. The 'opts' string contains up to 4 directive fields separated by ':'. 'selection' field :; A, allfiles: process all files; D, staged: process only staged (on Disk) files (if 'allfiles:' is not specified; the default is to process only files marked as non-staged); 'pre-action field':; O, open: open the files marked as staged when processing only files; marked as non-staged; T, touch: open and touch the files marked as staged when processing; only files marked as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if ne",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:13051,Availability,failure,failure,13051,"election' field :; A, allfiles: process all files; D, staged: process only staged (on Disk) files (if 'allfiles:' is not specified; the default is to process only files marked as non-staged); 'pre-action field':; O, open: open the files marked as staged when processing only files; marked as non-staged; T, touch: open and touch the files marked as staged when processing; only files marked as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into t",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:13896,Availability,failure,failure,13896," Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]u",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:14173,Availability,error,error,14173,"ollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the 'subdir'; is the directory in the file wher it should be looked for.; After resolving against a base URI consisting of proof://masterhos",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:11674,Deployability,update,update,11674,"epresentation in the form ""<digit><sfx>"" with <sfx> = {"""", ""k"", ""M"", ""G"",; ""T"", ""P""} (case insensitive).; Returns -1 if the format is wrong. TFileCollection * GetDataSet(const char* uri, const char* server = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. TMap * GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t ScanDataSet(const char* uri, const char* opt); Scans the dataset indicated by 'uri' following the 'opts' directives. The 'opts' string contains up to 4 directive fields separated by ':'. 'selection' field :; A, allfiles: process all files; D, staged: process only staged (on Disk) files (if 'allfiles:' is not specified; the default is to process only files marked as non-staged); 'pre-action field':; O, open: open the files marked as staged when processing only files; marked as non-staged; T, touch: open and touch the files marked as staged when processing; only files marked as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullpr",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:13697,Deployability,update,updates,13697,"ected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString*",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:14104,Deployability,update,updated,14104,"ollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the 'subdir'; is the directory in the file wher it should be looked for.; After resolving against a base URI consisting of proof://masterhos",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:17223,Deployability,update,update,17223,"RL. void ShowDataSets(const char* uri = ""*"", const char* opt = """"); Prints formatted information about the dataset 'uri'.; The type and format of output is driven by 'opt':. 1. opt = ""server:srv1[,srv2[,srv3[,...]]]""; Print info about the subsets of 'uri' on servers srv1, srv2, ...; 2. opt = ""servers[:exclude:srv1[,srv2[,srv3[,...]]]]""; Print info about the subsets of 'uri' on all servers, except; the ones in the exclude list srv1, srv2, ...; 3. opt = <any>; Print info about all datasets matching 'uri'. If 'opt' contains 'full:' the list of files in the datasets are also printed.; In case 3. this is enabled only if 'uri' matches a single dataset. In case 3, if 'opt' contains; 'full:' the list of files in the datasets are also printed.; 'forcescan:' the dataset are open to get the information; otherwise the; pre-processed information is used.; 'noheader:' the labelling header is not printed; usefull when to chain; several printouts; 'noupdate:' do not update the cache (which may be slow on very remote; servers); 'refresh:' refresh the information (requires appropriate credentials;; typically it can be done only for owned datasets). Int_t ScanDataSet(TFileCollection* dataset, Int_t fopt, Int_t sopt = 0, Int_t ropt = 0, Bool_t dbg = kFALSE, Int_t* touched = 0, Int_t* opened = 0, Int_t* disappeared = 0, TList* flist = 0, Long64_t avgsz = -1, const char* mss = 0, Int_t maxfiles = -1, const char* stageopts = 0); Go through the files in the specified dataset, selecting files according to; 'fopt' and doing on these files the actions described by 'sopt'.; If required, the information in 'dataset' is updated. The int fopt controls which files have to be processed (or added to the list; if ropt is 1 - see below); 'fopt' is defined in term of csopt and fsopt:; fopt = sign(fsopt) * csopt * 100 + fsopt; where 'fsopt' controls the actual selection; -1 all files in the dataset; 0 process only files marked as 'non-staged'; >=1 as 0 but files that are marked 'staged' are open; >=2 as ",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:17876,Deployability,update,updated,17876," this is enabled only if 'uri' matches a single dataset. In case 3, if 'opt' contains; 'full:' the list of files in the datasets are also printed.; 'forcescan:' the dataset are open to get the information; otherwise the; pre-processed information is used.; 'noheader:' the labelling header is not printed; usefull when to chain; several printouts; 'noupdate:' do not update the cache (which may be slow on very remote; servers); 'refresh:' refresh the information (requires appropriate credentials;; typically it can be done only for owned datasets). Int_t ScanDataSet(TFileCollection* dataset, Int_t fopt, Int_t sopt = 0, Int_t ropt = 0, Bool_t dbg = kFALSE, Int_t* touched = 0, Int_t* opened = 0, Int_t* disappeared = 0, TList* flist = 0, Long64_t avgsz = -1, const char* mss = 0, Int_t maxfiles = -1, const char* stageopts = 0); Go through the files in the specified dataset, selecting files according to; 'fopt' and doing on these files the actions described by 'sopt'.; If required, the information in 'dataset' is updated. The int fopt controls which files have to be processed (or added to the list; if ropt is 1 - see below); 'fopt' is defined in term of csopt and fsopt:; fopt = sign(fsopt) * csopt * 100 + fsopt; where 'fsopt' controls the actual selection; -1 all files in the dataset; 0 process only files marked as 'non-staged'; >=1 as 0 but files that are marked 'staged' are open; >=2 as 1 but files that are marked 'staged' are touched; 10 process only files marked as 'staged'; files marked as 'non-staged'; are ignored; and 'csopt' controls if an actual check on the staged status (via TFileStager) is done; 0 check that the file is staged using TFileStager; 1 do not hard check the staged status; (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; to re-check the stage status of all the files marked as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large da",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:19710,Deployability,update,update,19710,"d as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large datasets, an operation; which can take a very long time. The int 'sopt' controls what is done on the selected files (this is effective only; if ropt is 0 or 2 - see below):; -1 no action (fopt = 2 and sopt = -1 touches all staged files); 0 do the full process: open the files and fill the meta-information; in the TFileInfo object, including the end-point URL; 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; which is must faster of an TFile::Open); 2 issue a stage request on the files. The int 'ropt' controls which actions are performed:; 0 do the full process: get list of files to process and process them; 1 get the list of files to be scanned and return it in flist; 2 process the files in flist (according to sopt); When defined flist is under the responsability the caller. If avgsz > 0 it is used for the final update of the dataset global counters. If 'mss' is defined use it to initialize the stager (instead of the Url in the; TFileInfo objects). If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; 1 dataset was not changed; 2 dataset was changed. The number of touched, opened and disappeared files are returned in the respective; variables, if these are defined. Int_t ScanFile(TFileInfo* fileinfo, Bool_t notify); Open the file described by 'fileinfo' to extract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem h",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:3876,Energy Efficiency,monitor,monitoring,3876,"Object::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TMap*GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); static TList*ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALS",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:13456,Energy Efficiency,monitor,monitoring,13456,"d as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = ",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:13485,Energy Efficiency,monitor,monitoring,13485,"the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the fo",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:8685,Modifiability,config,config,8685,"; kSetDefaultTree; kForceScan; kNoHeaderPrint; kReopen; kTouch; kMaxFiles; kReadShort; kFileMustExist; kNoAction; kLocateOnly; kStageOnly; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUrifBaseBase URI used to parse dataset names; TStringfCommonGroupGroup that stores the COMMON datasets; TStringfCommonUserUser that stores the COMMON datasets; TStringfGroupGroup to which the owner of this session belongs; TStringfGroupConfigFilePath to the group config file; TMapfGroupQuotaGroup quotas (read from config file); TMapfGroupUsed<group> --> <used bytes> (TParameter); Long_tfMTimeGroupConfigLast modification of the group config file; Int_tfNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tfNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tfNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringfUserOwner of the session; TMapfUserUsed<group> --> <map of users> --> <value>; static TStringfgCommonDataSetTagName for common datasets, default: COMMON; static TList*fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManager(const char* group = 0, const char* user = 0, const char* options = 0). Main constructor. ~TDataSetManager(); Destructor. void ParseInitOpts(const char* opts); Parse the opts string and set the init bits accordingly; Available options:; Cq: set kCheckQuota; Ar: set kAllowRegister; Av: set kAllowVerify; Ti: set kTrustInfo; Sb: set kIsSandbox; Ca: set kUseCache or kDoNotUseCa",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:8737,Modifiability,config,config,8737,"; kSetDefaultTree; kForceScan; kNoHeaderPrint; kReopen; kTouch; kMaxFiles; kReadShort; kFileMustExist; kNoAction; kLocateOnly; kStageOnly; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUrifBaseBase URI used to parse dataset names; TStringfCommonGroupGroup that stores the COMMON datasets; TStringfCommonUserUser that stores the COMMON datasets; TStringfGroupGroup to which the owner of this session belongs; TStringfGroupConfigFilePath to the group config file; TMapfGroupQuotaGroup quotas (read from config file); TMapfGroupUsed<group> --> <used bytes> (TParameter); Long_tfMTimeGroupConfigLast modification of the group config file; Int_tfNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tfNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tfNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringfUserOwner of the session; TMapfUserUsed<group> --> <map of users> --> <value>; static TStringfgCommonDataSetTagName for common datasets, default: COMMON; static TList*fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManager(const char* group = 0, const char* user = 0, const char* options = 0). Main constructor. ~TDataSetManager(); Destructor. void ParseInitOpts(const char* opts); Parse the opts string and set the init bits accordingly; Available options:; Cq: set kCheckQuota; Ar: set kAllowRegister; Av: set kAllowVerify; Ti: set kTrustInfo; Sb: set kIsSandbox; Ca: set kUseCache or kDoNotUseCa",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:8858,Modifiability,config,config,8858,"; kSetDefaultTree; kForceScan; kNoHeaderPrint; kReopen; kTouch; kMaxFiles; kReadShort; kFileMustExist; kNoAction; kLocateOnly; kStageOnly; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUrifBaseBase URI used to parse dataset names; TStringfCommonGroupGroup that stores the COMMON datasets; TStringfCommonUserUser that stores the COMMON datasets; TStringfGroupGroup to which the owner of this session belongs; TStringfGroupConfigFilePath to the group config file; TMapfGroupQuotaGroup quotas (read from config file); TMapfGroupUsed<group> --> <used bytes> (TParameter); Long_tfMTimeGroupConfigLast modification of the group config file; Int_tfNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tfNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tfNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringfUserOwner of the session; TMapfUserUsed<group> --> <map of users> --> <value>; static TStringfgCommonDataSetTagName for common datasets, default: COMMON; static TList*fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManager(const char* group = 0, const char* user = 0, const char* options = 0). Main constructor. ~TDataSetManager(); Destructor. void ParseInitOpts(const char* opts); Parse the opts string and set the init bits accordingly; Available options:; Cq: set kCheckQuota; Ar: set kAllowRegister; Av: set kAllowVerify; Ti: set kTrustInfo; Sb: set kIsSandbox; Ca: set kUseCache or kDoNotUseCa",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:10154,Modifiability,config,config,10154," session; TMapfUserUsed<group> --> <map of users> --> <value>; static TStringfgCommonDataSetTagName for common datasets, default: COMMON; static TList*fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManager(const char* group = 0, const char* user = 0, const char* options = 0). Main constructor. ~TDataSetManager(); Destructor. void ParseInitOpts(const char* opts); Parse the opts string and set the init bits accordingly; Available options:; Cq: set kCheckQuota; Ar: set kAllowRegister; Av: set kAllowVerify; Ti: set kTrustInfo; Sb: set kIsSandbox; Ca: set kUseCache or kDoNotUseCache; The opts string may also contain additional unrelated info: in such a case; the field delimited by the prefix ""opt:"" is analyzed, e.g. if opts is; ""/tmp/dataset opt:Cq:-Ar: root://lxb6046.cern.ch"" only the substring; ""Cq:-Ar:"" will be parsed . Bool_t ReadGroupConfig(const char* cf = 0); Read group config file 'cf'.; If cf == 0 re-read, if changed, the file pointed by fGroupConfigFile . expects the following directives:; Group definition:; group <groupname> <user>+; disk quota; property <groupname> diskquota <quota in GB>; average filesize (to be used when the file size is not available); averagefilesize <average size>{G,g,M,m,K,k}. Long64_t ToBytes(const char* size = 0); Static utility function to gt the number of bytes from a string; representation in the form ""<digit><sfx>"" with <sfx> = {"""", ""k"", ""M"", ""G"",; ""T"", ""P""} (case insensitive).; Returns -1 if the format is wrong. TFileCollection * GetDataSet(const char* uri, const char* server = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. TMap * GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport). Returns all datasets for the <group>",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:20146,Modifiability,variab,variables,20146,"n the files and fill the meta-information; in the TFileInfo object, including the end-point URL; 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; which is must faster of an TFile::Open); 2 issue a stage request on the files. The int 'ropt' controls which actions are performed:; 0 do the full process: get list of files to process and process them; 1 get the list of files to be scanned and return it in flist; 2 process the files in flist (according to sopt); When defined flist is under the responsability the caller. If avgsz > 0 it is used for the final update of the dataset global counters. If 'mss' is defined use it to initialize the stager (instead of the Url in the; TFileInfo objects). If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; 1 dataset was not changed; 2 dataset was changed. The number of touched, opened and disappeared files are returned in the respective; variables, if these are defined. Int_t ScanFile(TFileInfo* fileinfo, Bool_t notify); Open the file described by 'fileinfo' to extract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem happens (object found in keys cannot be read,; for example). TList * ParseDataSetSrvMaps(const TString& srvmaps); Create a server mapping list from the content of 'srvmaps'; Return the list (owned by the caller) or 0 if no valid info could be found). TList * GetDataSetSrvMaps(); Static getter for server mapping list. Bool_t CheckDataSetSrvMaps(TUrl* furl, TString& fn, TList* srvmaplist = 0); Check if the dat",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:14221,Performance,cache,cached,14221,", const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the 'subdir'; is the directory in the file wher it should be looked for.; After resolving against a base URI consisting of proof://masterhost/group/user; - meaning masterhost, group and user of the current session -; the path is c",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:14293,Performance,cache,cached,14293,"rom this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the 'subdir'; is the directory in the file wher it should be looked for.; After resolving against a base URI consisting of proof://masterhost/group/user; - meaning masterhost, group and user of the current session -; the path is checked to contain exactly three elements separated by '/':; group/user/ds",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:17234,Performance,cache,cache,17234,"RL. void ShowDataSets(const char* uri = ""*"", const char* opt = """"); Prints formatted information about the dataset 'uri'.; The type and format of output is driven by 'opt':. 1. opt = ""server:srv1[,srv2[,srv3[,...]]]""; Print info about the subsets of 'uri' on servers srv1, srv2, ...; 2. opt = ""servers[:exclude:srv1[,srv2[,srv3[,...]]]]""; Print info about the subsets of 'uri' on all servers, except; the ones in the exclude list srv1, srv2, ...; 3. opt = <any>; Print info about all datasets matching 'uri'. If 'opt' contains 'full:' the list of files in the datasets are also printed.; In case 3. this is enabled only if 'uri' matches a single dataset. In case 3, if 'opt' contains; 'full:' the list of files in the datasets are also printed.; 'forcescan:' the dataset are open to get the information; otherwise the; pre-processed information is used.; 'noheader:' the labelling header is not printed; usefull when to chain; several printouts; 'noupdate:' do not update the cache (which may be slow on very remote; servers); 'refresh:' refresh the information (requires appropriate credentials;; typically it can be done only for owned datasets). Int_t ScanDataSet(TFileCollection* dataset, Int_t fopt, Int_t sopt = 0, Int_t ropt = 0, Bool_t dbg = kFALSE, Int_t* touched = 0, Int_t* opened = 0, Int_t* disappeared = 0, TList* flist = 0, Long64_t avgsz = -1, const char* mss = 0, Int_t maxfiles = -1, const char* stageopts = 0); Go through the files in the specified dataset, selecting files according to; 'fopt' and doing on these files the actions described by 'sopt'.; If required, the information in 'dataset' is updated. The int fopt controls which files have to be processed (or added to the list; if ropt is 1 - see below); 'fopt' is defined in term of csopt and fsopt:; fopt = sign(fsopt) * csopt * 100 + fsopt; where 'fsopt' controls the actual selection; -1 all files in the dataset; 0 process only files marked as 'non-staged'; >=1 as 0 but files that are marked 'staged' are open; >=2 as ",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:19419,Performance,perform,performed,19419,"leStager; 1 do not hard check the staged status; (example: use fopt = -101 to check the staged status of all the files, or fopt = 110; to re-check the stage status of all the files marked as staged). If 'dbg' is true, some information about the ongoing operations is reguraly; printed; this can be useful when processing very large datasets, an operation; which can take a very long time. The int 'sopt' controls what is done on the selected files (this is effective only; if ropt is 0 or 2 - see below):; -1 no action (fopt = 2 and sopt = -1 touches all staged files); 0 do the full process: open the files and fill the meta-information; in the TFileInfo object, including the end-point URL; 1 only locate the files, by updating the end-point URL (uses TFileStager::Locate; which is must faster of an TFile::Open); 2 issue a stage request on the files. The int 'ropt' controls which actions are performed:; 0 do the full process: get list of files to process and process them; 1 get the list of files to be scanned and return it in flist; 2 process the files in flist (according to sopt); When defined flist is under the responsability the caller. If avgsz > 0 it is used for the final update of the dataset global counters. If 'mss' is defined use it to initialize the stager (instead of the Url in the; TFileInfo objects). If maxfiles > 0, select for processing a maximum of 'filesmax' files (but if fopt is 1 or 2; all files marked as 'staged' are still open or touched). Return code; 1 dataset was not changed; 2 dataset was changed. The number of touched, opened and disappeared files are returned in the respective; variables, if these are defined. Int_t ScanFile(TFileInfo* fileinfo, Bool_t notify); Open the file described by 'fileinfo' to extract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTre",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:4047,Security,checksum,checksum,4047,"::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); static TList*ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemov",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManager.html:14023,Security,checksum,checksum,14023,"i> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the",MatchSource.WIKI,root/html532/TDataSetManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManager.html
https://root.cern/root/html532/TDataSetManagerFile.html:1851,Availability,error,error,1851,"ps(TUrl* furl, TString& fn, TList* srvmaplist = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual Int_tClearCache(const char* uri = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TStringTDataSetManager::CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:1935,Availability,error,error,1935,"onst char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual Int_tClearCache(const char* uri = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TStringTDataSetManager::CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:12363,Availability,avail,available,12363,"; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Crea",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13251,Availability,error,error,13251,"atasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. T",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13594,Availability,error,error,13594," = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the speci",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:14625,Availability,avail,available,14625,"ts(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the specified dataset; is processed.; Action depends on option; available options:. kExport Return a TMap object containing all the information about; datasets in the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:15072,Availability,avail,available,15072,"ort"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the specified dataset; is processed.; Action depends on option; available options:. kExport Return a TMap object containing all the information about; datasets in the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not;",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:15735,Availability,failure,failure,15735,"the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCo",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16479,Availability,failure,failure,16479,"and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum);",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:17255,Availability,error,error,17255,"nst char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the datase",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:17517,Availability,error,error,17517,"const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns 0 on success, -1 on fai",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:18503,Availability,failure,failure,18503,"turn 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns 0 on success, -1 on failure. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default se",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:18677,Availability,failure,failure,18677,"r* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns 0 on success, -1 on failure. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export na",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:11251,Deployability,update,updated,11251,"ng_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const cha",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:11444,Deployability,update,updates,11444,"ng_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const cha",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13095,Deployability,update,updated,13095,"tor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdat",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:14024,Deployability,update,update,14024," the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the specified dataset; is processed.; Action depends on option; available options:. kExport Return a TMap object containing all the information about; datasets in the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no outp",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:15252,Deployability,update,update,15252,"ort"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the specified dataset; is processed.; Action depends on option; available options:. kExport Return a TMap object containing all the information about; datasets in the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not;",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16406,Deployability,update,updates,16406,"and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum);",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:19647,Deployability,update,update,19647,"bug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. TFileCollection * GetDataSet(const char* uri, const char* srv = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. void UpdateUsedSpace(); updates the used space maps. const char * GetDataSetPath(const char* group, const char* user, const char* dsName). TDataSetManagerFile(); { }. virtual ~TDataSetManagerFile(); { }. const char * GetMSSUrl() const; { return fMSSUrl; }. const char * GetStageOpts() const; { return fStageOpts; }. » Author: Jan Fiete Grosse-Oetringhaus, 08.08.07 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TDataSetM",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:20132,Deployability,update,updates,20132,"t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. TFileCollection * GetDataSet(const char* uri, const char* srv = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. void UpdateUsedSpace(); updates the used space maps. const char * GetDataSetPath(const char* group, const char* user, const char* dsName). TDataSetManagerFile(); { }. virtual ~TDataSetManagerFile(); { }. const char * GetMSSUrl() const; { return fMSSUrl; }. const char * GetStageOpts() const; { return fStageOpts; }. » Author: Jan Fiete Grosse-Oetringhaus, 08.08.07 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TDataSetManagerFile.h 33357 2010-05-04 06:56:18Z ganis $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:4378,Energy Efficiency,monitor,monitoring,4378,"t; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTDataSetManager::MonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); static TList*TDataSetManager::ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tTDataSetManager::ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString*",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:14606,Integrability,depend,depends,14606,"ts(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; If <dsName> is defined, only the information about the specified dataset; is processed.; Action depends on option; available options:. kExport Return a TMap object containing all the information about; datasets in the form:; { <group>, <map of users> }; |; { <map of datasets>, <dataset>}; (<dataset> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:10337,Modifiability,config,config,10337,"y; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tTDataSetManager::fAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUriTDataSetManager::fBaseBase URI used to parse dataset names; TStringTDataSetManager::fCommonGroupGroup that stores the COMMON datasets; TStringTDataSetManager::fCommonUserUser that stores the COMMON datasets; TStringTDataSetManager::fGroupGroup to which the owner of this session belongs; TStringTDataSetManager::fGroupConfigFilePath to the group config file; TMapTDataSetManager::fGroupQuotaGroup quotas (read from config file); TMapTDataSetManager::fGroupUsed<group> --> <used bytes> (TParameter); Long_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeL",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:10406,Modifiability,config,config,10406,"y; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tTDataSetManager::fAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUriTDataSetManager::fBaseBase URI used to parse dataset names; TStringTDataSetManager::fCommonGroupGroup that stores the COMMON datasets; TStringTDataSetManager::fCommonUserUser that stores the COMMON datasets; TStringTDataSetManager::fGroupGroup to which the owner of this session belongs; TStringTDataSetManager::fGroupConfigFilePath to the group config file; TMapTDataSetManager::fGroupQuotaGroup quotas (read from config file); TMapTDataSetManager::fGroupUsed<group> --> <used bytes> (TParameter); Long_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeL",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:10561,Modifiability,config,config,10561,"y; kNoCacheUpdate; kRefreshLs; kList; kAllFiles; kStagedFiles; kNoStagedCheck; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tTDataSetManager::fAvgFileSizeAverage file size to be used to estimate the dataset size (in MB); TUriTDataSetManager::fBaseBase URI used to parse dataset names; TStringTDataSetManager::fCommonGroupGroup that stores the COMMON datasets; TStringTDataSetManager::fCommonUserUser that stores the COMMON datasets; TStringTDataSetManager::fGroupGroup to which the owner of this session belongs; TStringTDataSetManager::fGroupConfigFilePath to the group config file; TMapTDataSetManager::fGroupQuotaGroup quotas (read from config file); TMapTDataSetManager::fGroupUsed<group> --> <used bytes> (TParameter); Long_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeL",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13522,Modifiability,portab,portable,13522,"ar* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; I",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:18255,Modifiability,config,configured,18255," Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns 0 on success, -1 on failure. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, i",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:18449,Modifiability,config,configured,18449,"path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the dataset object (status bits, meta,...); is trusted, i.e. not reset (if the dataset manager is configured to allow so).; Returns 0 on success, -1 on failure. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs, >= 0 on success.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). Int_t ScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); See documentation of ScanDataSet(TFileCollection *dataset, UInt_t option). TMap * GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:11480,Performance,cache,cache,11480,"ng_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const cha",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:11738,Performance,cache,cache,11738,"ng_tTDataSetManager::fMTimeGroupConfigLast modification of the group config file; Int_tTDataSetManager::fNDisappearedFilesNumber of files disappared in the last ScanDataSet operation; Int_tTDataSetManager::fNOpenedFilesNumber of files opened in the last ScanDataSet operation; Int_tTDataSetManager::fNTouchedFilesNumber of files touched in the last ScanDataSet operation; TStringTDataSetManager::fUserOwner of the session; TMapTDataSetManager::fUserUsed<group> --> <map of users> --> <value>; static TStringTDataSetManager::fgCommonDataSetTagName for common datasets, default: COMMON; static TList*TDataSetManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const cha",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:12107,Performance,cache,cache,12107,"etManager::fgDataSetSrvMapsList of TPair(TRegexp, TObjString) for mapping server coordinates. private:. Int_tfCacheUpdatePeriodPeriod for checking for new updated information; TStringfDataSetDirLocation of datasets; TStringfDataSetLockFileDataset lock file; Bool_tfIsRemoteTrue if the repository is remote; TStringfListFileFile to check repository updates; TStringfLocalCacheDirLocal cache when the repository is remote; Int_tfLockFileTimeLimitLimit in seconds after a lock automatically expires; TStringfMSSUrlURL for the Mass Storage System; TStringfStageOptsOption string to be used in issuing staging requests; Bool_tfUseCacheTrue if the cache is used for browsing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the up",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:12745,Performance,cache,cache,12745,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:12790,Performance,cache,cachedir,12790,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13508,Performance,optimiz,optimized,13508,"ar* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; I",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16323,Performance,cache,cache,16323,"and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum);",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16533,Performance,cache,cached,16533,"ut, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bo",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16609,Performance,cache,cached,16609,"e path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:2597,Security,checksum,checksum,2597,"bject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTDataSetManager::GetGroupQuota(const char* group); virtual TMap*TDataSetManager::GetGroupQuotaMap(); virtual Long64_tTDataSetManager::GetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; const char*GetMSSUrl() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vi",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:4533,Security,checksum,checksum,4533,":GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTDataSetManager::MonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); static TList*TDataSetManager::ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tTDataSetManager::ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const;",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:7363,Security,checksum,checksum,7363,"TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); virtual Bool_tRemoveDataSet(const char* uri); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); static Int_tTDataSetManager::ScanFile(TFileInfo* fileinfo, Bool_t notify); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidTDataSetManager::SetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tShowCache(const char* uri = 0); virtual voidTDataSetManager::ShowDataSets(const char* uri = ""*"", const char* opt = """"); virtual voidShowMembers(TMemberInspector& insp); virtual voidTDataSetManager::ShowQuota(const char* opt); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0).",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:7570,Security,checksum,checksum,7570,"t option = 0, Int_t bufsize = 0) const; Int_tWriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). protected:. Bool_tBrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Int_tChecksumDataSet(const char* path, const char* md5path, TString& checksum); Int_tCreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExistsDataSet(const char* group, const char* user, const char* dsName); Int_tFillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); const char*GetDataSetPath(const char* group, const char* user, const char* dsName); const char*GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); virtual TMap*TDataSetManager::GetGroupUsedMap(); Int_tTDataSetManager::GetNDisapparedFiles() const; Int_tTDataSetManager::GetNOpenedFiles() const; Int_tTDataSetManager::GetNTouchedFiles() const; voidTDataSetManager::GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset); virtual TMap*TDataSetManager::GetUserUsedMap(); voidInit(); voidTObject::MakeZombie(); voidTDataSetManager::PrintDataSet(TFileCollection* fc, Int_t popt = 0); voidTDataSetManager::PrintUsedSpace(); Bool_tTDataSetManager::ReadGroupConfig(const char* cf = 0); Bool_tRemoveDataSet(const char* group, const char* user, const char* dsName); Int_tScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); static Long64_tTDataSetManager::ToBytes(const char* size = 0); virtual voidUpdateUsedSpace(). private:. Int_tCheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); voidInitLocalCache(). Data Members; public:. enum TDataSetManager::EDataSetS",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:7660,Security,checksum,checksum,7660,"t option = 0, Int_t bufsize = 0) const; Int_tWriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). protected:. Bool_tBrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Int_tChecksumDataSet(const char* path, const char* md5path, TString& checksum); Int_tCreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExistsDataSet(const char* group, const char* user, const char* dsName); Int_tFillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); const char*GetDataSetPath(const char* group, const char* user, const char* dsName); const char*GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); virtual TMap*TDataSetManager::GetGroupUsedMap(); Int_tTDataSetManager::GetNDisapparedFiles() const; Int_tTDataSetManager::GetNOpenedFiles() const; Int_tTDataSetManager::GetNTouchedFiles() const; voidTDataSetManager::GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset); virtual TMap*TDataSetManager::GetUserUsedMap(); voidInit(); voidTObject::MakeZombie(); voidTDataSetManager::PrintDataSet(TFileCollection* fc, Int_t popt = 0); voidTDataSetManager::PrintUsedSpace(); Bool_tTDataSetManager::ReadGroupConfig(const char* cf = 0); Bool_tRemoveDataSet(const char* group, const char* user, const char* dsName); Int_tScanDataSet(const char* group, const char* user, const char* dsName, UInt_t option = kReopen|kDebug); static Long64_tTDataSetManager::ToBytes(const char* size = 0); virtual voidUpdateUsedSpace(). private:. Int_tCheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); voidInitLocalCache(). Data Members; public:. enum TDataSetManager::EDataSetS",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13011,Security,checksum,checksum,13011,"tor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdat",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13212,Security,checksum,checksum,13212,"t string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; N",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:13338,Security,checksum,checksum,13338,"ataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t op",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:15856,Security,checksum,checksum,15856,"set> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated datase",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:15938,Security,checksum,checksum,15938,"print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16019,Security,checksum,checksum,16019,"print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16769,Security,checksum,checksum,16769,"rn 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName);",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16952,Security,checksum,checksum,16952,"eted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:16991,Security,checksum,checksum,16991,"eted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:17165,Security,checksum,checksum,17165,"ster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' th",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:17332,Security,checksum,checksum,17332,"er, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataSetManagerFile.html:17357,Security,checksum,checksum,17357,"er, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName); Checks if the indicated dataset exits. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings and verification, if required.; If a dataset with the same name already exists the action fails unless 'opts'; contains 'O', in which case the old dataset is overwritten, or contains 'U',; in which case 'newDataSet' is added to the existing dataset (duplications are; ignored, if any).; If 'opts' contains 'V' the dataset files are also verified (if the dataset manager; is configured to allow so). By default the dataset is not verified.; If 'opts' contains 'T' the in the ",MatchSource.WIKI,root/html532/TDataSetManagerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html
https://root.cern/root/html532/TDataType.html:1664,Availability,error,error,1664," voidTObject::AbstractMethod(const char* method) const; static voidAddBuiltins(TCollection* types); virtual voidTObject::AppendPad(Option_t* option = """"); const char*AsString(void* buf) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDataType*GetDataType(EDataType type); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; In",MatchSource.WIKI,root/html532/TDataType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataType.html
https://root.cern/root/html532/TDataType.html:1748,Availability,error,error,1748,"ection* types); virtual voidTObject::AppendPad(Option_t* option = """"); const char*AsString(void* buf) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDataType*GetDataType(EDataType type); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Int_tGetType() const; static EDataTypeGetType(const type_info& typeinfo); const char*G",MatchSource.WIKI,root/html532/TDataType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataType.html
https://root.cern/root/html532/TDataType.html:7558,Integrability,depend,depending,7558,"NameTrue name of the (potential) underlying class ; EDataTypefTypetype id; static TDataType*fgBuiltins[22]Array of builtins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataType(TypedefInfo_t* info = 0); Default TDataType ctor. TDataTypes are constructed in TROOT via; a call to TCint::UpdateListOfTypes(). TDataType(const char* typenam); Constructor for basic data types, like ""char"", ""unsigned char"", etc. TDataType(const TDataType& ); copy constructor. TDataType& operator=(const TDataType& ); assignement operator. ~TDataType(); TDataType dtor deletes adopted CINT TypedefInfo object. const char * GetTypeName(EDataType type); Return the name of the type. const char * GetTypeName() const; Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of typedef, e,g.: ""class TDirectory*"". EDataType GetType(const type_info& typeinfo); Set type id depending on name. const char * AsString(void* buf) const; Return string containing value in buffer formatted according to; the basic data type. The result needs to be used or copied immediately. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void SetType(const char* name); Set type id depending on name. Int_t Size() const; Get size of basic typedef'ed type. void CheckInfo(); Refresh the underlying information. void AddBuiltins(TCollection* types); Create the TDataType objects for builtins. TDataType* GetDataType(EDataType type); Given a EDataType type, get the TDataType* that represents it. Int_t GetType() const; { return (Int_t)fType; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataType.h 41070 2011-09-30 12:15:22Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root/html532/TDataType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataType.html
https://root.cern/root/html532/TDataType.html:7889,Integrability,depend,depending,7889,"id; static TDataType*fgBuiltins[22]Array of builtins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataType(TypedefInfo_t* info = 0); Default TDataType ctor. TDataTypes are constructed in TROOT via; a call to TCint::UpdateListOfTypes(). TDataType(const char* typenam); Constructor for basic data types, like ""char"", ""unsigned char"", etc. TDataType(const TDataType& ); copy constructor. TDataType& operator=(const TDataType& ); assignement operator. ~TDataType(); TDataType dtor deletes adopted CINT TypedefInfo object. const char * GetTypeName(EDataType type); Return the name of the type. const char * GetTypeName() const; Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of typedef, e,g.: ""class TDirectory*"". EDataType GetType(const type_info& typeinfo); Set type id depending on name. const char * AsString(void* buf) const; Return string containing value in buffer formatted according to; the basic data type. The result needs to be used or copied immediately. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void SetType(const char* name); Set type id depending on name. Int_t Size() const; Get size of basic typedef'ed type. void CheckInfo(); Refresh the underlying information. void AddBuiltins(TCollection* types); Create the TDataType objects for builtins. TDataType* GetDataType(EDataType type); Given a EDataType type, get the TDataType* that represents it. Int_t GetType() const; { return (Int_t)fType; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataType.h 41070 2011-09-30 12:15:22Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDataType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataType.html
https://root.cern/root/html532/TDataType.html:501,Security,access,accessible,501,". TDataType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDataType. class TDataType: public TDictionary. Basic data type descriptor (datatype information is obtained from; CINT). This class describes the attributes of type definitions; (typedef's). The TROOT class contains a list of all currently; defined types (accessible via TROOT::GetListOfTypes()). Function Members (Methods); public:. TDataType(TypedefInfo_t* info = 0); TDataType(const char* typenam); virtual~TDataType(); voidTObject::AbstractMethod(const char* method) const; static voidAddBuiltins(TCollection* types); virtual voidTObject::AppendPad(Option_t* option = """"); const char*AsString(void* buf) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html532/TDataType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDataType.html
https://root.cern/root/html532/TDatime.html:3015,Energy Efficiency,allocate,allocated,3015,"tor& insp); Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_tfDatimeDate (relative to 1995) + time. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatime(); Create a TDatime and set it to the current time. TDatime(Int_t date, Int_t time); Create a TDatime and set it to the specified date and time.; See Set(Int_t, Int_t) about the date, time format. TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); Create a TDatime and set it to the specified year, month,; day, time, hour, minute and second. See Set() about the format. TDatime(const char* sqlDateTime); Expects as input a string in SQL date/time compatible format, like:; yyyy-mm-dd hh:mm:ss. Int_t GetDayOfWeek() const; Returns day of week, with Monday being day 1 and Sunday day 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to ",MatchSource.WIKI,root/html532/TDatime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatime.html
https://root.cern/root/html532/TDatime.html:3935,Integrability,depend,dependent,3935," 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to datime. void FillBuffer(char*& buffer); Encode Date/Time into buffer, used by I/O system. UInt_t Get() const; Return raw date/time as encoded by TDatime. Note, this value cannot; be used to e.g. calculate time differences, as it is an encoded value.; To calculate time differences use the Convert() method to get a time; in seconds and then subtract the values. Int_t GetDate() const; Return date in form of 19971224 (i.e. 24/12/1997). Int_t GetTime() const; Return time in form of 123623 (i.e. 12:36:23). void Print(Option_t* option = """") const; Print date and time. void ReadBuffer(char*& buffer); Decode Date/Time from output buffer, used by I/O system. void Set(); Set Date/Time to current time as reported by the system.; Date and Time are encoded into one single unsigned 32 bit word.; Date is stored with the origin being the 1st january 1995.; Time has 1 second precision. ",MatchSource.WIKI,root/html532/TDatime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatime.html
https://root.cern/root/html532/TDatime.html:626,Modifiability,portab,portable,626,". TDatime. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TDatime. class TDatime. TDatime. This class stores the date and time with a precision of one second; in an unsigned 32 bit word (e.g. 950130 124559). The date is stored; with the origin being the 1st january 1995. This class has no support for time zones. The time is assumed; to be in the local time of the machine where the object was created.; As a result, TDatime objects are not portable between machines; operating in different time zones and unsuitable for storing the; date/time of data taking events and the like. If absolute time is; required, use TTimeStamp. Function Members (Methods); public:. TDatime(); TDatime(const TDatime& d); TDatime(const char* sqlDateTime); TDatime(UInt_t tloc, Bool_t dosDate = kFALSE); TDatime(Int_t date, Int_t time); TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); virtual~TDatime(); const char*AsSQLString() const; const char*AsString() const; const char*AsString(char* out) const; static TClass*Class(); UInt_tConvert(Bool_t toGMT = kFALSE) const; voidCopy(TDatime& datime) const; voidFillBuffer(char*& buffer); UInt_tGet() const; Int_tGetDate() const; static voidGetDateTime(UInt_t datetime, Int_t& date, Int_t& time); Int_tGetDay() const; Int_tGetDayOfWeek() const; Int_tGetHour() const; Int_tGetMinute() const; Int_tGetMonth() const; Int_tGetSecond() const; Int_tGetTime() const; Int_tGetYear() const; virtual TClass*IsA() const; TDatime&operator=(const TDatime& d); voidPrint(Option_t* option = """") const; voidReadBuffer(char*& buffer); voidSet(); voidSet(const char* sqlDateTime); voidSet(UInt_t tloc, Bool_t dosDate = kFALSE); voidSet(Int_t date, Int_t time); voidSet(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); virtual voidShowMembers(TMemberInspecto",MatchSource.WIKI,root/html532/TDatime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatime.html
https://root.cern/root/html532/TDatime.html:3234,Safety,safe,safe,3234,"ries. Function documentation; TDatime(); Create a TDatime and set it to the current time. TDatime(Int_t date, Int_t time); Create a TDatime and set it to the specified date and time.; See Set(Int_t, Int_t) about the date, time format. TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); Create a TDatime and set it to the specified year, month,; day, time, hour, minute and second. See Set() about the format. TDatime(const char* sqlDateTime); Expects as input a string in SQL date/time compatible format, like:; yyyy-mm-dd hh:mm:ss. Int_t GetDayOfWeek() const; Returns day of week, with Monday being day 1 and Sunday day 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to datime. void FillBuffer(char*& buffer); Encode Date/Time into buffer, used by I/O system. UInt_t Get() const; Return raw date/time as encoded by TDatime. Note, this value cannot; be used to e.g. calculate time differences, as it is a",MatchSource.WIKI,root/html532/TDatime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDatime.html
https://root.cern/root/html532/TDCacheFile.html:3346,Availability,error,error,3346,"e); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenH",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:3430,Availability,error,error,3430," cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetB",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23849,Availability,error,error,23849,"r performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to E",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23999,Availability,error,error,23999,"umentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. v",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24346,Availability,failure,failure,24346," If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysR",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24490,Availability,error,error,24490,"ct. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24615,Availability,failure,failure,24615,"ption and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t S",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24737,Availability,failure,failure,24737,"e(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24973,Availability,error,error,24973,"mote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed, so there's no need to; sync() them manually. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a fi",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23620,Integrability,interface,interface,23620,"e (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFil",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:12137,Performance,cache,cacheDir,12137,"yname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:12264,Performance,cache,cache,12264,"ve(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTF",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:12322,Performance,cache,cache,12322,"virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenT",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:18708,Performance,cache,cache,18708,,MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:18780,Performance,cache,cache,18780,,MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:20454,Performance,cache,cache,20454,"e!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:20737,Performance,cache,cache,20737,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:22117,Performance,cache,cache,22117,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:22147,Performance,cache,cached,22147,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:22840,Performance,perform,performance,22840,"Number of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRU",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:22900,Performance,cache,cached,22900,"Number of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRU",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24782,Performance,cache,cached,24782,"ote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed,",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:24894,Safety,timeout,timeout,24894,"(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed, so there's no need to; sync() them manually. Int_t SysStat(Int_t fd, Long_t* i",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23190,Security,access,accessed,23190,"TFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23394,Security,access,accessable,23394,", the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write ",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheFile.html:23521,Security,access,accessable,23521,"ds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Sta",MatchSource.WIKI,root/html532/TDCacheFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheFile.html
https://root.cern/root/html532/TDCacheSystem.html:3390,Availability,error,error,3390,"oncatFileName(const char* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSyste",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:3474,Availability,error,error,3474,"named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtual const char*TSystem::GetBuildCompilerVersion() c",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:12416,Availability,mask,mask,12416,"ct::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidTSystem::SetProgname(const char* name); virtual intTSystem::SetSockOpt(int sock, int kind, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec); virt",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:14068,Availability,mask,mask,14068,"med::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidTSystem::SetProgname(const char* name); virtual intTSystem::SetSockOpt(int sock, int kind, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidTSystem::StackTrace(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual intTSystem::Symlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSystem::Syslog(ELogLevel level, const char* mess); virtual const char*TSystem::TempDirectory() const; virtual FILE*TSystem::TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intTSystem::Umask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intTSystem::Unlink(const char* name); virtual voidTSystem::Unload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intTSystem::Utime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*TSystem::WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17190,Availability,error,error,17190,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17844,Availability,mask,mask,17844,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fD",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17891,Availability,mask,mask,17891,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fD",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17972,Availability,mask,masks,17972,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fD",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:9437,Integrability,protocol,protocol,9437,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObje",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17196,Integrability,message,message,17196,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:16160,Modifiability,config,configure,16160,"rmInterruptsSyscalls(Bool_t); static const char*TSystem::StripOffProto(const char* path, const char* proto). private:. virtual void*GetDirPtr() const. Data Members; public:. enum TSystem::EAclicMode { kDefault; kDebug; kOpt; };; enum TSystem::EAclicProperties { kFlatBuildDir; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixD",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:16777,Performance,optimiz,optimized,16777,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:17522,Performance,cache,cache,17522,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:11525,Safety,timeout,timeout,11525,"int length); virtual intTSystem::RecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:11589,Safety,timeout,timeout,11589," int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDCacheSystem.html:16886,Security,access,access,16886,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TDCacheSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html
https://root.cern/root/html532/TDecayChannel.html:1565,Availability,error,error,1565,"); virtual~TDecayChannel(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBranchingRatio(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tDaughterPdgCode(Int_t i); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecayChannel.html
https://root.cern/root/html532/TDecayChannel.html:1649,Availability,error,error,1649,"irtual voidTObject::AppendPad(Option_t* option = """"); Double_tBranchingRatio(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tDaughterPdgCode(Int_t i); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecayChannel.html
https://root.cern/root/html532/TDecayChannel.html:5925,Security,access,accessors,5925," char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfBranchingRatiobranching ratio ( < 1); TArrayIfDaughtersPDG codes of the daughters; Int_tfMatrixElementCodematrix element for this decay mode; Int_tfNumberchannel number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecayChannel(); default constructor. TDecayChannel(Int_t Number, Int_t MatrixElementCode, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); constructor. ~TDecayChannel(). TDecayChannel(); ****** constructors and destructor. Int_t Number(); ****** accessors. { return fNumber; }. Int_t MatrixElementCode(); { return fMatrixElementCode; }. Int_t NDaughters(); { return fDaughters.fN; }. Double_t BranchingRatio(); { return fBranchingRatio; }. Int_t DaughterPdgCode(Int_t i); { return fDaughters.fArray[i]; }. » Author: P.Murat 15/02/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TDecayChannel.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecayChannel.html
https://root.cern/root/html532/TDecompBase.html:617,Availability,avail,available,617,". TDecompBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TDecompBase. class TDecompBase: public TObject. Decomposition Base class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supp",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:2414,Availability,toler,tolerance,2414,"cy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, o",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:2797,Availability,toler,tolerance,2797,"omposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the ",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:2855,Availability,toler,tolerance,2855,"; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs ",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3293,Availability,toler,tolerance,3293,"l to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. vir",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3349,Availability,toler,tolerance,3349,"s calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3761,Availability,toler,tolerance,3761,"ther linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tD",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:4216,Availability,avail,available,4216,"ad to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:5286,Availability,error,error,5286,"tractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Double_tGetCondition() const; Double_tGetDet1() const; Double_tGetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bo",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:5370,Availability,error,error,5370,"on = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Double_tGetCondition() const; Double_tGetDet1() const; Double_tGetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tGetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtu",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:448,Deployability,install,installed,448,". TDecompBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TDecompBase. class TDecompBase: public TObject. Decomposition Base class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supp",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:539,Energy Efficiency,monitor,monitoring,539,". TDecompBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TDecompBase. class TDecompBase: public TObject. Decomposition Base class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supp",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:2565,Energy Efficiency,power,powerful,2565,"nt this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice t",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:2582,Energy Efficiency,monitor,monitor,2582,"nt this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice t",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3750,Energy Efficiency,reduce,reduce,3750,"ther linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tD",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:10109,Energy Efficiency,power,powers,10109,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static voidDiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tHager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidResetStatus(). Data Members; public:. enum EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwbColumn lower bound of decomposed matrix; Double_tfConditionmatrix condition number; Double_tfDet1determinant mantissa; Double_tfDet2determinant exponent for powers of 2; Int_tfRowLwbRow lower bound of decomposed matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t newTol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t ",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:1706,Performance,perform,performed,1706," for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not w",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3687,Safety,detect,detect,3687,"epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObj",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:4059,Testability,test,test,4059,"e checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::D",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:891,Usability,simpl,simple,891,". TDecompBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TDecompBase. class TDecompBase: public TObject. Decomposition Base class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supp",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:1294,Usability,simpl,simple,1294," class. This class forms the base for all the decompositions methods in the; linear algebra package .; It or its derived classes have installed the methods to solve; equations,invert matrices and calculate determinants while monitoring; the accuracy. Each derived class has always the following methods available:. Condition() :; In an iterative scheme the condition number for matrix inversion is; calculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); gives,. {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBase.html:3381,Usability,clear,clear,3381,"s calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root/html532/TDecompBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBase.html
https://root.cern/root/html532/TDecompBK.html:2991,Availability,error,error,2991,"thod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t&, Double_t&); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDeco",MatchSource.WIKI,root/html532/TDecompBK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBK.html
https://root.cern/root/html532/TDecompBK.html:3075,Availability,error,error,3075,"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t&, Double_t&); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const; const TMatrixD&GetU(); virtual UInt_tTObject::GetUniqueID() ",MatchSource.WIKI,root/html532/TDecompBK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBK.html
https://root.cern/root/html532/TDecompBK.html:8202,Energy Efficiency,power,powers,8202,"d2); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_t*fIpiv[fNIpiv] row permutation index; Int_tfNIpivsize of row permutation index; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUdecomposed matrix so that a = u d u^T. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBK(); Default constructor. TDecompBK(Int_t nrows); Constructor for (nrows x nrows) symmetric matrix. TDecompBK(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) symmetric matrix. TDecompBK(const TMatrixDSym& m, Double_t tol = 0.0); Constructor for symmetric matrix A. TDecompBK(const TDecompBK& another); Copy constructor. Bool_t Decompose(); Matrix A is decomposed in components U and D so that A = U*D*U^T; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. void SetMatrix(const TMatrixDSym& a); Set the matrix to be decomposed, decomposition status is reset. Bool_t Sol",MatchSource.WIKI,root/html532/TDecompBK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompBK.html
https://root.cern/root/html532/TDecompChol.html:1914,Availability,error,error,1914,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixDSymGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::G",MatchSource.WIKI,root/html532/TDecompChol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompChol.html
https://root.cern/root/html532/TDecompChol.html:1998,Availability,error,error,1998,"tual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixDSymGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const; const TMatrixD&GetU() const; v",MatchSource.WIKI,root/html532/TDecompChol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompChol.html
https://root.cern/root/html532/TDecompChol.html:7165,Energy Efficiency,power,powers,7165,"g, Double_t tol, Double_t& d1, Double_t& d2); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUdecomposed matrix fU so that a = fU^T fU. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompChol(Int_t nrows); Constructor for (nrows x nrows) matrix. TDecompChol(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) matrix. TDecompChol(const TMatrixDSym& a, Double_t tol = 0.0); Constructor for symmetric matrix A . Matrix should be positive definite. TDecompChol(const TMatrixD& a, Double_t tol = 0.0); Constructor for general matrix A . Matrix should be symmetric positive definite. TDecompChol(const TDecompChol& another); Copy constructor. Bool_t Decompose(); Matrix A is decomposed in component U so that A = U^T*U^T; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. const TMatrixDSym GetMatrix(); Rec",MatchSource.WIKI,root/html532/TDecompChol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompChol.html
https://root.cern/root/html532/TDecompLU.html:2288,Availability,error,error,2288,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixD&GetLU(); const TMatrixDGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual ",MatchSource.WIKI,root/html532/TDecompLU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompLU.html
https://root.cern/root/html532/TDecompLU.html:2372,Availability,error,error,2372,"tual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixD&GetLU(); const TMatrixDGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const; virtual U",MatchSource.WIKI,root/html532/TDecompLU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompLU.html
https://root.cern/root/html532/TDecompLU.html:7794,Energy Efficiency,power,powers,7794,"ject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tfImplicitPivotcontrol to determine implicit row scale before; Int_t*fIndex[fNIndex] row permutation index; TMatrixDfLUdecomposed matrix so that a = l u where; Int_tfNIndexsize of row permutation index; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tfSign= +/- 1 reflecting even/odd row permutations, resp.; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompLU(); Default constructor. TDecompLU(Int_t nrows); Constructor for (nrows x nrows) matrix. TDecompLU(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) matrix. TDecompLU(const TMatrixD& m, Double_t tol = 0.0, Int_t implicit = 1); Constructor for matrix a. TDecompLU(const TDecompLU& another); Copy constructor. Bool_t Decompose(); Matrix A is decomposed in components U and L so that P * A = U * L; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. const",MatchSource.WIKI,root/html532/TDecompLU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompLU.html
https://root.cern/root/html532/TDecompQRH.html:2202,Availability,error,error,2202,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const TMatrixD&GetQ(); virtual const TMatrixD&GetR(); Int_tTDecompBase::GetRowLwb() cons",MatchSource.WIKI,root/html532/TDecompQRH.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompQRH.html
https://root.cern/root/html532/TDecompQRH.html:2286,Availability,error,error,2286,"tual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const TMatrixD&GetQ(); virtual const TMatrixD&GetR(); Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const",MatchSource.WIKI,root/html532/TDecompQRH.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompQRH.html
https://root.cern/root/html532/TDecompQRH.html:7615,Energy Efficiency,power,powers,7615,"tDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); static Bool_tQRH(TMatrixD& q, TVectorD& diagR, TVectorD& up, TVectorD& w, Double_t tol); voidTDecompBase::ResetStatus(). Data Members; public:. enum { kWorkMax; };; enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TMatrixDfQ(m x n) - orthogonal matrix; TMatrixDfR(n x n) - upper triangular matrix; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TVectorDfUp(n) - vector with Householder up's; TVectorDfW(n) - vector with Householder beta's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompQRH(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompQRH(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompQRH(const TMatrixD& m, Double_t tol = 0.0); Constructor for general matrix A . TDecompQRH(const TDecompQRH& another); Copy constructor. Bool_t Decompose(); QR decomposition of matrix a by Householder transformations,; see Golub & Loan first edition p41 & Sec 6.2.; First fR is returned in upper triang of fQ and diagR. fQ returned in; 'u-form' in lower triang of fQ and fW, the latter containing the",MatchSource.WIKI,root/html532/TDecompQRH.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompQRH.html
https://root.cern/root/html532/TDecompQRH.html:9652,Integrability,rout,routine,9652,"ng the; ""Householder betas"".; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. Bool_t QRH(TMatrixD& q, TVectorD& diagR, TVectorD& up, TVectorD& w, Double_t tol); Decomposition function . void SetMatrix(const TMatrixD& a); Set matrix to be decomposed. Bool_t Solve(TVectorD& b); Solve Ax=b assuming the QR form of A is stored in fR,fQ and fW, but assume b; has *not* been transformed. Solution returned in b. Bool_t Solve(TMatrixDColumn& b); Solve Ax=b assuming the QR form of A is stored in fR,fQ and fW, but assume b; has *not* been transformed. Solution returned in b. Bool_t TransSolve(TVectorD& b); Solve A^T x=b assuming the QR form of A is stored in fR,fQ and fW, but assume b; has *not* been transformed. Solution returned in b. Bool_t TransSolve(TMatrixDColumn& b); Solve A^T x=b assuming the QR form of A is stored in fR,fQ and fW, but assume b; has *not* been transformed. Solution returned in b. void Det(Double_t& d1, Double_t& d2); This routine calculates the absolute (!) value of the determinant; |det| = d1*TMath::Power(2.,d2). Bool_t Invert(TMatrixD& inv); For a matrix A(m,n), its inverse A_inv is defined as A * A_inv = A_inv * A = unit; The user should always supply a matrix of size (m x m) !; If m > n , only the (n x m) part of the returned (pseudo inverse) matrix; should be used . TMatrixD Invert(Bool_t& status); For a matrix A(m,n), its inverse A_inv is defined as A * A_inv = A_inv * A = unit; (n x m) Ainv is returned . void Print(Option_t* opt = """") const; Print the class members. TDecompQRH & operator=(const TDecompQRH& source); Assignment operator. const TMatrixDBase & GetDecompMatrix() const; { return fR; }. TDecompQRH(); {}. virtual ~TDecompQRH(); {}. Int_t GetNrows() const; { return fQ.GetNrows(); }. Int_t GetNcols() const; { return fQ.GetNcols(); }. const TMatrixD & GetQ(). const TMatrixD & GetR(). const TVectorD & GetUp(). const TVectorD & GetW(). Bool_t Solve(TVectorD& b). Bool_t TransSolve(TVectorD& b). Bool_t Invert(TMatri",MatchSource.WIKI,root/html532/TDecompQRH.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompQRH.html
https://root.cern/root/html532/TDecompSparse.html:1859,Availability,error,error,1859,"thod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t&, Double_t&); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDeco",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:1943,Availability,error,error,1943,"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t&, Double_t&); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTO",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:10190,Energy Efficiency,power,powers,10190,"t_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows an",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:10337,Energy Efficiency,allocate,allocated,10337,"t_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows an",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:12052,Energy Efficiency,allocate,allocate,12052,"e; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows and unspecified number of columns .; nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(Int_t row_lwb, Int_t row_upb, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with row range, [row_lwb..row_upb] and unspecified column; range . nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(const TMatrixDSparse& a, Int_t verbose); Constructor for matrix A . TDecompSparse(const TDecompSparse& another); Copy constructor. Int_t NonZerosUpperTriang(const TMatrixDSparse& a); Static function, returning the number of non-zero entries in the upper triangular matrix . void CopyUpperTriang(const TMatrixDSparse& a, Double_t* b); Static function, copying the non-zero entries in the upper triangle to; array b . User should allocate enough memory for array b . void SetMatrix(const TMatrixDSparse& a); Set matrix to be decomposed . Bool_t Decompose(); Decomposition engine .; If the decomposition succeeds, bit kDecomposed is set . Bool_t Solve(TVectorD& b); Solve Ax=b . Solution returned in b. void InitParam(); initializing control parameters. void InitPivot(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routin",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:12841,Integrability,rout,routine,12841,"r. Int_t NonZerosUpperTriang(const TMatrixDSparse& a); Static function, returning the number of non-zero entries in the upper triangular matrix . void CopyUpperTriang(const TMatrixDSparse& a, Double_t* b); Static function, copying the non-zero entries in the upper triangle to; array b . User should allocate enough memory for array b . void SetMatrix(const TMatrixDSparse& a); Set matrix to be decomposed . Bool_t Decompose(); Decomposition engine .; If the decomposition succeeds, bit kDecomposed is set . Bool_t Solve(TVectorD& b); Solve Ax=b . Solution returned in b. void InitParam(); initializing control parameters. void InitPivot(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, ",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:13058,Integrability,rout,routine,13058," non-zero entries in the upper triangle to; array b . User should allocate enough memory for array b . void SetMatrix(const TMatrixDSparse& a); Set matrix to be decomposed . Bool_t Decompose(); Decomposition engine .; If the decomposition succeeds, bit kDecomposed is set . Bool_t Solve(TVectorD& b); Solve Ax=b . Solution returned in b. void InitParam(); initializing control parameters. void InitPivot(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, In",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:13252,Integrability,rout,routine,13252,"ecomposition engine .; If the decomposition succeeds, bit kDecomposed is set . Bool_t Solve(TVectorD& b); Solve Ax=b . Solution returned in b. void InitParam(); initializing control parameters. void InitPivot(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:13490,Integrability,rout,routine,13490,"t_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, I",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:13626,Integrability,rout,routine,13626,"ps); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, co",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:13835,Integrability,rout,routine,13835,"t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t ",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:14018,Integrability,rout,routine,14018,"Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. v",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:14189,Integrability,rout,routine,14189," nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:14431,Integrability,rout,routine,14431," const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routine for pivoting setup. void InitPivot_sub2a(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:14658,Integrability,rout,routine,14658,"* iw, const Int_t lw, Int_t& iwfr, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub3(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source);",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:14926,Integrability,rout,routine,14926,"t_t* info); Help routine for pivoting setup. void InitPivot_sub4(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* ips, Int_t* ipv, Int_t* nv, Int_t* flag, Int_t& ncmpa); Help routine for pivoting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source); Assignment operator. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info). Int_t IDiag(Int_t ix, Int_t iy); { return ((iy-1)*(2*ix-iy+2))/",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:15089,Integrability,rout,routine,15089,"oting setup. void InitPivot_sub5(const Int_t n, Int_t* ipe, Int_t* nv, Int_t* ips, Int_t* ne, Int_t* na, Int_t* nd, Int_t& nsteps, const Int_t nemin); Help routine for pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source); Assignment operator. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info). Int_t IDiag(Int_t ix, Int_t iy); { return ((iy-1)*(2*ix-iy+2))/2; }. Int_t IError(); { return fInfo[2]; }. Int_t MinRealWorkspace(); { return fInfo[5]; }. Int_t MinIntWorkspace(); { return fInfo[6]; }. Int_t ErrorFlag(); { return fInfo[1]; }. Double_t GetThresholdPivoting(); Tak",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:15263,Integrability,rout,routine,15263,"r pivoting setup. void InitPivot_sub6(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* perm, Int_t* na, Int_t* ne, Int_t* nd, const Int_t nsteps, Int_t* lstki, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source); Assignment operator. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info). Int_t IDiag(Int_t ix, Int_t iy); { return ((iy-1)*(2*ix-iy+2))/2; }. Int_t IError(); { return fInfo[2]; }. Int_t MinRealWorkspace(); { return fInfo[5]; }. Int_t MinIntWorkspace(); { return fInfo[6]; }. Int_t ErrorFlag(); { return fInfo[1]; }. Double_t GetThresholdPivoting(); Takes values in the range [0,1]. Larger values enforce greater stability in; the factorization as they insist on larger pivots. Smaller values preserve; sparsity at the",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:15436,Integrability,rout,routine,15436,"i, Int_t* lstkr, Int_t* iw, Int_t* info, Double_t& ops); Help routine for pivoting setup. void Factor_sub1(const Int_t n, const Int_t nz, Int_t& nz1, Double_t* a, const Int_t la, Int_t* irn, Int_t* icn, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* iw2, Int_t* icntl, Int_t* info); Help routine for factorization. void Factor_sub2(const Int_t n, const Int_t nz, Double_t* a, const Int_t la, Int_t* iw, const Int_t liw, Int_t* perm, Int_t* nstk, const Int_t nsteps, Int_t& maxfrt, Int_t* nelim, Int_t* iw2, Int_t* icntl, Double_t* cntl, Int_t* info); Help routine for factorization. void Factor_sub3(Double_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source); Assignment operator. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info). Int_t IDiag(Int_t ix, Int_t iy); { return ((iy-1)*(2*ix-iy+2))/2; }. Int_t IError(); { return fInfo[2]; }. Int_t MinRealWorkspace(); { return fInfo[5]; }. Int_t MinIntWorkspace(); { return fInfo[6]; }. Int_t ErrorFlag(); { return fInfo[1]; }. Double_t GetThresholdPivoting(); Takes values in the range [0,1]. Larger values enforce greater stability in; the factorization as they insist on larger pivots. Smaller values preserve; sparsity at the cost of using smaller pivots. { return fCntl[1]; }. Double_t GetTreatAsZero(); { return fCntl[3]; }. void SetThresholdPivoting(Double_t piv); The factorization will not a",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:12605,Modifiability,variab,variables,12605,"w_lwb..row_upb] and unspecified column; range . nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(const TMatrixDSparse& a, Int_t verbose); Constructor for matrix A . TDecompSparse(const TDecompSparse& another); Copy constructor. Int_t NonZerosUpperTriang(const TMatrixDSparse& a); Static function, returning the number of non-zero entries in the upper triangular matrix . void CopyUpperTriang(const TMatrixDSparse& a, Double_t* b); Static function, copying the non-zero entries in the upper triangle to; array b . User should allocate enough memory for array b . void SetMatrix(const TMatrixDSparse& a); Set matrix to be decomposed . Bool_t Decompose(); Decomposition engine .; If the decomposition succeeds, bit kDecomposed is set . Bool_t Solve(TVectorD& b); Solve Ax=b . Solution returned in b. void InitParam(); initializing control parameters. void InitPivot(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayI& Aiw, TArrayI& Aikeep, TArrayI& Aiw1, Int_t& nsteps, const Int_t iflag, Int_t* icntl, Double_t* cntl, Int_t* info, Double_t& ops); Setup Pivoting variables. void Factor(const Int_t n, const Int_t nz, TArrayI& Airn, TArrayI& Aicn, TArrayD& Aa, TArrayI& Aiw, TArrayI& Aikeep, const Int_t nsteps, Int_t& maxfrt, TArrayI& Aiw1, Int_t* icntl, Double_t* cntl, Int_t* info); Factorization routine, the workhorse for the decompostion step. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info); Main routine for solving Ax=b. void InitPivot_sub1(const Int_t n, const Int_t nz, Int_t* irn, Int_t* icn, Int_t* iw, Int_t* ipe, Int_t* iq, Int_t* flag, Int_t& iwfr, Int_t* icntl, Int_t* info); Help routine for pivoting setup. void InitPivot_sub2(const Int_t n, Int_t* ipe, Int_t* iw, const Int_t lw, Int_t& iwfr, Int_t* nv, Int_t* nxt, Int_t* lst, Int_t* ipd, Int_t* flag, const Int_t iovflo, Int_t& ncmpa, const Double_t fratio); Help routi",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSparse.html:10754,Safety,detect,detected,10754,"med] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows and unspecified number of columns .; nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(Int_t row_lwb, Int_t row_upb, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with row range, [row_lwb..row_upb] and unspecified column; range . nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(const TMatrixDSparse& a, Int_t verbose); Constructor for matrix A . TDecompSparse(const TDecompSparse& anoth",MatchSource.WIKI,root/html532/TDecompSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSparse.html
https://root.cern/root/html532/TDecompSVD.html:2459,Availability,error,error,2459,"tractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixDGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; const TVectorD&GetSig(); virtual",MatchSource.WIKI,root/html532/TDecompSVD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSVD.html
https://root.cern/root/html532/TDecompSVD.html:2543,Availability,error,error,2543,"on = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTDecompBase::GetColLwb() const; Double_tTDecompBase::GetCondition() const; Double_tTDecompBase::GetDet1() const; Double_tTDecompBase::GetDet2() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TMatrixDGetMatrix(); virtual const char*TObject::GetName() const; virtual Int_tGetNcols() const; virtual Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTDecompBase::GetRowLwb() const; const TVectorD&GetSig(); virtual const char*TObject::GetTitle() const; Double_tTDecompBase::GetTol() const; const TM",MatchSource.WIKI,root/html532/TDecompSVD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSVD.html
https://root.cern/root/html532/TDecompSVD.html:8241,Energy Efficiency,power,powers,8241,"t char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(); static voidSortSingular(TMatrixD& v, TMatrixD& u, TVectorD& sDiag). Data Members; public:. enum { kWorkMax; };; enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; TVectorDfSigdiagonal of diagonal matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUorthogonal matrix; TMatrixDfVorthogonal matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSVD(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompSVD(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompSVD(const TMatrixD& m, Double_t tol = 0.0); Constructor for general matrix A . TDecompSVD(const TDecompSVD& another); Copy constructor. Bool_t Decompose(); SVD decomposition of matrix; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. Bool_t Bidiagonalize(TMatrixD& v, TMatrixD& u, TVectorD& sDiag, TVectorD& oDiag); Bidiagonalize the (m x n) - matrix a (stored in v) through a series of Householder; transformat",MatchSource.WIKI,root/html532/TDecompSVD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDecompSVD.html
https://root.cern/root/html532/TDialogCanvas.html:6561,Availability,error,error,6561,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasID() const; virtual",MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDialogCanvas.html:6645,Availability,error,error,6645,"ect::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasID() const; virtual TCanvasImp*TCanvas::GetCanvasImp() const; TVirtualPadPainter*TCanvas::GetCanvasPain",MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDialogCanvas.html:28472,Availability,down,down,28472,,MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDialogCanvas.html:30875,Testability,log,log,30875,":fEmbeddedGL!; Int_tTCanvas::fEvent!Type of current or last handled event; Int_tTCanvas::fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDialogCanvas.html:30932,Testability,log,log,30932,":fEmbeddedGL!; Int_tTCanvas::fEvent!Type of current or last handled event; Int_tTCanvas::fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDialogCanvas.html:30989,Testability,log,log,30989,":fEmbeddedGL!; Int_tTCanvas::fEvent!Type of current or last handled event; Int_tTCanvas::fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html532/TDialogCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html
https://root.cern/root/html532/TDiamond.html:2474,Availability,error,error,2474,"ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTPaveText::DeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTPaveText::EditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TList*TPaveText::GetListOfLines() const; ",MatchSource.WIKI,root/html532/TDiamond.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDiamond.html
https://root.cern/root/html532/TDiamond.html:2558,Availability,error,error,2558,"::Delete(Option_t* option = """")MENU ; virtual voidTPaveText::DeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTPaveText::EditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TList*TPaveText::GetListOfLines() const; Float_tTPaveText::GetMargin() const; virtual Option_t*TPave::GetName() const; virtua",MatchSource.WIKI,root/html532/TDiamond.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDiamond.html
https://root.cern/root/html532/TDictionary.html:1013,Availability,avail,available,1013,"ctionary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDictionary. class TDictionary: public TNamed. TDictionary. This class defines an abstract interface that must be implemented; by all classes that contain dictionary information. The dictionary is defined by the followling classes:; TDataType (typedef definitions); TGlobal (global variables); TGlobalFunc (global functions); TClass (classes); TBaseClass (base classes); TDataMember (class datamembers); TMethod (class methods); TMethodArg (method arguments). All the above classes implement the TDictionary abstract interface.; Note: the indentation shows aggregation not inheritance. TMethodCall (method call environment). /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:1984,Availability,error,error,1984," virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:2068,Availability,error,error,2068,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDictionary*GetDictionary(const char* name); static TDictionary*GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgf",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:337,Integrability,interface,interface,337,". TDictionary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDictionary. class TDictionary: public TNamed. TDictionary. This class defines an abstract interface that must be implemented; by all classes that contain dictionary information. The dictionary is defined by the followling classes:; TDataType (typedef definitions); TGlobal (global variables); TGlobalFunc (global functions); TClass (classes); TBaseClass (base classes); TDataMember (class datamembers); TMethod (class methods); TMethodArg (method arguments). All the above classes implement the TDictionary abstract interface.; Note: the indentation shows aggregation not inheritance. TMethodCall (method call environment). /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:763,Integrability,interface,interface,763,". TDictionary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDictionary. class TDictionary: public TNamed. TDictionary. This class defines an abstract interface that must be implemented; by all classes that contain dictionary information. The dictionary is defined by the followling classes:; TDataType (typedef definitions); TGlobal (global variables); TGlobalFunc (global functions); TClass (classes); TBaseClass (base classes); TDataMember (class datamembers); TMethod (class methods); TMethodArg (method arguments). All the above classes implement the TDictionary abstract interface.; Note: the indentation shows aggregation not inheritance. TMethodCall (method call environment). /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:528,Modifiability,variab,variables,528,". TDictionary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDictionary. class TDictionary: public TNamed. TDictionary. This class defines an abstract interface that must be implemented; by all classes that contain dictionary information. The dictionary is defined by the followling classes:; TDataType (typedef definitions); TGlobal (global variables); TGlobalFunc (global functions); TClass (classes); TBaseClass (base classes); TDataMember (class datamembers); TMethod (class methods); TMethodArg (method arguments). All the above classes implement the TDictionary abstract interface.; Note: the indentation shows aggregation not inheritance. TMethodCall (method call environment). /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDictionary.html:819,Modifiability,inherit,inheritance,819,". TDictionary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TDictionary. class TDictionary: public TNamed. TDictionary. This class defines an abstract interface that must be implemented; by all classes that contain dictionary information. The dictionary is defined by the followling classes:; TDataType (typedef definitions); TGlobal (global variables); TGlobalFunc (global functions); TClass (classes); TBaseClass (base classes); TDataMember (class datamembers); TMethod (class methods); TMethodArg (method arguments). All the above classes implement the TDictionary abstract interface.; Note: the indentation shows aggregation not inheritance. TMethodCall (method call environment). /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDictionary(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TDictionary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDictionary.html
https://root.cern/root/html532/TDirectory.html:2059,Availability,error,error,2059,"oidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; static TDirectory*&CurrentDirectory(); static voidDecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidDeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*FindKey(const char*) const; virtual TKey*FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char*) const; virtual TObject*Get(const char* namecycle); virtual Int_tGetBufferSize() const; virtual TDirectory*GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual TKey*GetKey(const char*, Short_t = 9999) c",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:2143,Availability,error,error,2143," """") const; virtual TObject*CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; static TDirectory*&CurrentDirectory(); static voidDecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidDeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*FindKey(const char*) const; virtual TKey*FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char*) const; virtual TObject*Get(const char* namecycle); virtual Int_tGetBufferSize() const; virtual TDirectory*GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual TKey*GetKey(const char*, Short_t = 9999) const; virtual TList*GetList() const; virtual TList*GetListOfKeys() const; virtual TO",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:12107,Availability,error,error,12107,"toadd = kTRUE); Clone an object.; This function is called when the directory is not a TDirectoryFile.; This version has to load the I/O package, hence via CINT. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TDirectory *& CurrentDirectory(); Return the current directory for the current thread. TDirectory * GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory using apath.; It apath is null or empty, returns ""this"" directory.; Otherwie use apath to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. Bool_t cd(const char* path = 0); Change current directory to ""this"" directory . Using path one can; change the current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa. Returns kTRUE in case of success. Bool_t cd1(const char* path); Change current directory to ""this"" directory . Using path one can; change the current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa. Returns kFALSE in case path does not exist. Bool_t Cd(const char* path); Change current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:18719,Availability,error,error,18719," to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectory::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). void FillFullPath(TString& buf) const; recursive method to fill full path for directory. TDirectory * mkdir(const char* name, const char* title = """"); Create a sub-directory and return a pointer to the created directory.; Returns 0 in case of error.; Returns 0 if a directory with the same name already exists.; Note that the directory name may be of the form ""a/b/c"" to create a hierarchy of directories.; In this case, the function returns the pointer to the ""a"" directory if the operation is successful. void ls(Option_t* option = """") const; List Directory contents. Indentation is used to identify the directory tree; Subdirectories are listed first, then objects in memory. The option can has the following format:; [<regexp>]; The <regexp> will be used to match the name of the objects.; By default memory and disk objects are listed. void Paint(Option_t* option = """"); Paint all objects in the directory. void Print(Option_t* option = """") const; Print all objects in the directory. void pwd() const; Print the path of the directory. void RecursiveRemove(TObject* obj); Recursively remove object from a Directory. TObject * Remove(TObject* ); Remove an object from the in-memory list. void rmdir(const char* name); Removes subdir",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:12113,Integrability,message,message,12113,"toadd = kTRUE); Clone an object.; This function is called when the directory is not a TDirectoryFile.; This version has to load the I/O package, hence via CINT. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TDirectory *& CurrentDirectory(); Return the current directory for the current thread. TDirectory * GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory using apath.; It apath is null or empty, returns ""this"" directory.; Otherwie use apath to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. Bool_t cd(const char* path = 0); Change current directory to ""this"" directory . Using path one can; change the current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa. Returns kTRUE in case of success. Bool_t cd1(const char* path); Change current directory to ""this"" directory . Using path one can; change the current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa. Returns kFALSE in case path does not exist. Bool_t Cd(const char* path); Change current directory to ""path"". The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:20222,Integrability,message,message,20222,"ll be used to match the name of the objects.; By default memory and disk objects are listed. void Paint(Option_t* option = """"); Paint all objects in the directory. void Print(Option_t* option = """") const; Print all objects in the directory. void pwd() const; Print the path of the directory. void RecursiveRemove(TObject* obj); Recursively remove object from a Directory. TObject * Remove(TObject* ); Remove an object from the in-memory list. void rmdir(const char* name); Removes subdirectory from the directory; When directory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;*"");. Int_t SaveObjectAs(const TObject* , const char* = """", Option_t* = """") const; Save object in filename,; if filename is 0 or """", a file with ""objectname.root"" is created.; The name of the key is the object name.; If the operation is successful, it returns the number of bytes written to the file; otherwise it returns 0.; By default a message is printed. Use option ""q"" to not print the message. void SetName(const char* newname); Set the name for directory; If the directory name is changed after the directory was written once,; ROOT currently would NOT change the name of correspondent key in the; mother directory.; DO NOT use this method to 'rename a directory'.; Renaming a directory is currently NOT supported. void EncodeNameCycle(char* buffer, const char* name, Short_t cycle); Encode the name and cycle into buffer like: ""aap;2"". void DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". void RegisterContext(TDirectory::TContext* ctxt); Register a TContext pointing to this TDirectory object. Int_t WriteTObject(const TObject* obj, const char* name = 0, Option_t* = """", Int_t = 0); See TDirectoryFile::WriteTObject for details. void UnregisterContext(TDirectory::TContext* ctxt); UnRegister a TContext pointing to this TDirectory object. TContext& opera",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:20274,Integrability,message,message,20274,"bjects.; By default memory and disk objects are listed. void Paint(Option_t* option = """"); Paint all objects in the directory. void Print(Option_t* option = """") const; Print all objects in the directory. void pwd() const; Print the path of the directory. void RecursiveRemove(TObject* obj); Recursively remove object from a Directory. TObject * Remove(TObject* ); Remove an object from the in-memory list. void rmdir(const char* name); Removes subdirectory from the directory; When directory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;*"");. Int_t SaveObjectAs(const TObject* , const char* = """", Option_t* = """") const; Save object in filename,; if filename is 0 or """", a file with ""objectname.root"" is created.; The name of the key is the object name.; If the operation is successful, it returns the number of bytes written to the file; otherwise it returns 0.; By default a message is printed. Use option ""q"" to not print the message. void SetName(const char* newname); Set the name for directory; If the directory name is changed after the directory was written once,; ROOT currently would NOT change the name of correspondent key in the; mother directory.; DO NOT use this method to 'rename a directory'.; Renaming a directory is currently NOT supported. void EncodeNameCycle(char* buffer, const char* name, Short_t cycle); Encode the name and cycle into buffer like: ""aap;2"". void DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". void RegisterContext(TDirectory::TContext* ctxt); Register a TContext pointing to this TDirectory object. Int_t WriteTObject(const TObject* obj, const char* name = 0, Option_t* = """", Int_t = 0); See TDirectoryFile::WriteTObject for details. void UnregisterContext(TDirectory::TContext* ctxt); UnRegister a TContext pointing to this TDirectory object. TContext& operator=(const TDirectory& ). void Add(TOb",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:16101,Modifiability,inherit,inherits,16101," current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectory::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offer better protection and avoid the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, e.g.; MyClass ",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:16226,Modifiability,inherit,inheritance,16226," found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectory::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offer better protection and avoid the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, e.g.; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const c",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:18067,Modifiability,inherit,inheriting,18067,"ation must cast the returned object to; the final type, e.g.; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectory::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). void FillFullPath(TString& buf) const; recursive method to fill full path for directory. TDirectory * mkdir(const char* name, const char* title = """"); Create a sub-directory and return a pointer to the created directory.; Returns 0 in case of error.; Returns 0 if a directory with the same name already exists.; Note that the directory name may be of the form ""a/b/c"" to create a hierarchy of directories.; In this case, the function returns the pointer to the ""a"" directory if the operation is successful. void ls(Option_t* option = """") const; List Direct",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:11205,Performance,load,load,11205,"lity,; one object can be removed from its support directory; by calling object->SetDirectory(0) or object->SetDirectory(dir) to add it; to the list of objects in the directory dir. NOTE that this is a static function. To call it, use;; TDirectory::AddDirectory. Bool_t AddDirectoryStatus(); static function: see TDirectory::AddDirectory for more comments. void Append(TObject* obj, Bool_t replace = kFALSE); Append object to this directory. If replace is true:; remove any existing objects with the same same (if the name is not """". void Browse(TBrowser* b); Browse the content of the directory. void Build(TFile* motherFile = 0, TDirectory* motherDir = 0); -*-*Initialise directory to defaults; *-* ================================. void CleanTargets(); Clean the pointers to this object (gDirectory, TContext, etc.). TObject * CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); Clone an object.; This function is called when the directory is not a TDirectoryFile.; This version has to load the I/O package, hence via CINT. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TDirectory *& CurrentDirectory(); Return the current directory for the current thread. TDirectory * GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory using apath.; It apath is null or empty, returns ""this"" directory.; Otherwie use apath to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. Bool_t cd(const char* path = 0); Change current directory to ""this"" directory . Using path ",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:17583,Performance,perform,performed,17583,"cial case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, e.g.; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectory::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectory.html:15977,Safety,avoid,avoid,15977,"me in the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectory::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offer better protection and avoid the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IM",MatchSource.WIKI,root/html532/TDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectory.html
https://root.cern/root/html532/TDirectoryFile.html:2527,Availability,error,error,2527,"ne(const char* newname = """") const; virtual TObject*CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; static TDirectory*&TDirectory::CurrentDirectory(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*FindKey(const char* keyname) const; virtual TKey*FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; virtual TObject*Get(const char* namecycle); virtual Int_tGetBufferSize() const; const TDatime&GetCreationDate() const; virtual TDirectory*GetDirectory(const char* apath, Bool_t printError = false, const char* funcname = ""GetDirectory""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile() const; virtual const char*TObject:",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:2611,Availability,error,error,2611,"Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; static TDirectory*&TDirectory::CurrentDirectory(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*FindKey(const char* keyname) const; virtual TKey*FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; virtual TObject*Get(const char* namecycle); virtual Int_tGetBufferSize() const; const TDatime&GetCreationDate() const; virtual TDirectory*GetDirectory(const char* apath, Bool_t printError = false, const char* funcname = ""GetDirectory""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual TKey*GetKey(const char* name, Short_t cycle = 9999) co",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:14122,Availability,error,error,14122,"s called; by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; a new name to the newly created object. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. TDirectory * GetDirectory(const char* apath, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory named ""apath"".; It apath is null or empty, returns ""this"" directory.; Otherwise use the name ""apath"" to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. void Close(Option_t* option = """"); -- Delete all objects from memory and directory structure itself. void Delete(const char* namecycle = """"); Delete Objects or/and keys in a directory; *-* =========================================; namecycle has the format name;cycle; namecycle = """" same as namecycle =""T*""; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. To delete one directory, you must specify the directory cycle,; eg. file.Delete(""dir1;1"");. examples:; foo : delete object named foo in memory; foo* : delete all objects with a name starting with foo; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on file and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories; WARNI",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:20279,Availability,error,error,20279,"of objects in the file so far. TKey * GetKey(const char* name, Short_t cycle = 9999) const; -*-*-*Return pointer to key with name,cycle; *-* =====================================; if cycle = 9999 returns highest cycle. void ls(Option_t* option = """") const; List Directory contents*-*-; *-* =======================; Indentation is used to identify the directory tree; Subdirectories are listed first, then objects in memory, then objects on the file. The option can has the following format:; [-d |-m][<regexp>]; Option -d means: only list objects in the file; -m means: only list objects in memory; The <regexp> will be used to match the name of the objects.; By default memory and disk objects are listed. TFile * OpenFile(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Interface to TFile::Open. TDirectory * mkdir(const char* name, const char* title = """"); Create a sub-directory and return a pointer to the created directory.; Returns 0 in case of error.; Returns 0 if a directory with the same name already exists.; Note that the directory name may be of the form ""a/b/c"" to create a hierarchy of directories.; In this case, the function returns the pointer to the ""a"" directory if the operation is successful. void Purge(Short_t nkeep = 1); Purge lowest key cycles in a directory.; By default, only the highest cycle of a key is kept. Keys for which; the ""KEEP"" flag has been set are not removed. See TKey::Keep(). void ReadAll(Option_t* option = """"); Read objects from a ROOT db file directory into memory.; If an object is already in memory, the memory copy is deleted; and the object is again read from the file.; If opt==""dirs"", only subdirectories will be read; If opt==""dirs*"" complete directory tree will be read. Int_t ReadKeys(Bool_t forceRead = kTRUE); Read the KEYS linked list; *-* =========================; Every directory has a linked list (fKeys). This linked list has been; written on the file via WriteKeys as a single d",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:21737,Deployability,update,updates,21737,"ReadAll(Option_t* option = """"); Read objects from a ROOT db file directory into memory.; If an object is already in memory, the memory copy is deleted; and the object is again read from the file.; If opt==""dirs"", only subdirectories will be read; If opt==""dirs*"" complete directory tree will be read. Int_t ReadKeys(Bool_t forceRead = kTRUE); Read the KEYS linked list; *-* =========================; Every directory has a linked list (fKeys). This linked list has been; written on the file via WriteKeys as a single data record. It is interesting to call this function in the following situation.; Assume another process1 is connecting this directory in Update mode; -Process1 is adding/updating objects in this directory; -You want to see the latest status from process1.; Example Process1:; obj1.Write();; obj2.Write();; gDirectory->SaveSelf();. Example Process2; gDirectory->ReadKeys();; obj1->Draw();. This is an efficient way (without opening/closing files) to view; the latest updates of a file being modified by another process; as it is typically the case in a data acquisition system. Int_t ReadTObject(TObject* obj, const char* keyname); Read object with keyname from the current directory; Read contents of object with specified name from the current directory.; First the key with keyname is searched in the current directory,; next the key buffer is deserialized into the object.; The object must have been created before via the default constructor.; See TObject::Write(). void ResetAfterMerge(TFileMergeInfo* ); Reset the TDirectory after its content has been merged into another; Directory. This returns the TDirectoryFile object back to its state; before any data has been written to the file.; The object in the in-memory list are assumed to also have been reset. void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:21671,Energy Efficiency,efficient,efficient,21671,"ReadAll(Option_t* option = """"); Read objects from a ROOT db file directory into memory.; If an object is already in memory, the memory copy is deleted; and the object is again read from the file.; If opt==""dirs"", only subdirectories will be read; If opt==""dirs*"" complete directory tree will be read. Int_t ReadKeys(Bool_t forceRead = kTRUE); Read the KEYS linked list; *-* =========================; Every directory has a linked list (fKeys). This linked list has been; written on the file via WriteKeys as a single data record. It is interesting to call this function in the following situation.; Assume another process1 is connecting this directory in Update mode; -Process1 is adding/updating objects in this directory; -You want to see the latest status from process1.; Example Process1:; obj1.Write();; obj2.Write();; gDirectory->SaveSelf();. Example Process2; gDirectory->ReadKeys();; obj1->Draw();. This is an efficient way (without opening/closing files) to view; the latest updates of a file being modified by another process; as it is typically the case in a data acquisition system. Int_t ReadTObject(TObject* obj, const char* keyname); Read object with keyname from the current directory; Read contents of object with specified name from the current directory.; First the key with keyname is searched in the current directory,; next the key buffer is deserialized into the object.; The object must have been created before via the default constructor.; See TObject::Write(). void ResetAfterMerge(TFileMergeInfo* ); Reset the TDirectory after its content has been merged into another; Directory. This returns the TDirectoryFile object back to its state; before any data has been written to the file.; The object in the in-memory list are assumed to also have been reset. void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:14128,Integrability,message,message,14128,"s called; by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; a new name to the newly created object. If autoadd is true and if the object class has a; DirectoryAutoAdd function, it will be called at the end of the; function with the parameter gDirector. This usually means that; the object will be appended to the current ROOT directory. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. TDirectory * GetDirectory(const char* apath, Bool_t printError = false, const char* funcname = ""GetDirectory""); Find a directory named ""apath"".; It apath is null or empty, returns ""this"" directory.; Otherwise use the name ""apath"" to find a directory.; The absolute path syntax is:; file.root:/dir1/dir2; where file.root is the file and /dir1/dir2 the desired subdirectory; in the file. Relative syntax is relative to ""this"" directory. E.g:; ../aa.; Returns 0 in case path does not exist.; If printError is true, use Error with 'funcname' to issue an error message. void Close(Option_t* option = """"); -- Delete all objects from memory and directory structure itself. void Delete(const char* namecycle = """"); Delete Objects or/and keys in a directory; *-* =========================================; namecycle has the format name;cycle; namecycle = """" same as namecycle =""T*""; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. To delete one directory, you must specify the directory cycle,; eg. file.Delete(""dir1;1"");. examples:; foo : delete object named foo in memory; foo* : delete all objects with a name starting with foo; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on file and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories; WARNI",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:23235,Integrability,message,message,23235,"(). void ResetAfterMerge(TFileMergeInfo* ); Reset the TDirectory after its content has been merged into another; Directory. This returns the TDirectoryFile object back to its state; before any data has been written to the file.; The object in the in-memory list are assumed to also have been reset. void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;*"");. void Save(); *-*-*-*-*Save recursively all directory keys and headers; *-* ===============================================. Int_t SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; Save object in filename,; if filename is 0 or """", a file with ""objectname.root"" is created.; The name of the key is the object name.; If the operation is successful, it returns the number of bytes written to the file; otherwise it returns 0.; By default a message is printed. Use option ""q"" to not print the message. void SaveSelf(Bool_t force = kFALSE); Save Directory keys and header*-*-; *-* ==============================; If the directory has been modified (fModified set), write the keys; and the directory header. This function assumes the cd is correctly set. It is recommended to use this function in the following situation:; Assume a process1 using a directory in Update mode; -New objects or modified objects have been written to the directory; -You do not want to close the file; -You want your changes be visible from another process2 already connected; to this directory in read mode; -Call this function; -In process2, use TDirectoryFile::ReadKeys to refresh the directory. void SetBufferSize(Int_t bufsize); set the default buffer size when creating new TKeys; see also TDirectoryFile::GetBufferSize. void SetTRefAction(TObject* ref, TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corre",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:23287,Integrability,message,message,23287,"fo* ); Reset the TDirectory after its content has been merged into another; Directory. This returns the TDirectoryFile object back to its state; before any data has been written to the file.; The object in the in-memory list are assumed to also have been reset. void rmdir(const char* name); Removes subdirectory from the directory; When diredctory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); Equivalent call is Delete(""name;*"");. void Save(); *-*-*-*-*Save recursively all directory keys and headers; *-* ===============================================. Int_t SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; Save object in filename,; if filename is 0 or """", a file with ""objectname.root"" is created.; The name of the key is the object name.; If the operation is successful, it returns the number of bytes written to the file; otherwise it returns 0.; By default a message is printed. Use option ""q"" to not print the message. void SaveSelf(Bool_t force = kFALSE); Save Directory keys and header*-*-; *-* ==============================; If the directory has been modified (fModified set), write the keys; and the directory header. This function assumes the cd is correctly set. It is recommended to use this function in the following situation:; Assume a process1 using a directory in Update mode; -New objects or modified objects have been written to the directory; -You do not want to close the file; -You want your changes be visible from another process2 already connected; to this directory in read mode; -Call this function; -In process2, use TDirectoryFile::ReadKeys to refresh the directory. void SetBufferSize(Int_t bufsize); set the default buffer size when creating new TKeys; see also TDirectoryFile::GetBufferSize. void SetTRefAction(TObject* ref, TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corresponding exec number into fBits.; This",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:17055,Modifiability,inherit,inherits,17055,"nt directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectoryFile::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offers better protection and avoids the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, eg; MyClass *o",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:17180,Modifiability,inherit,inheritance,17180,",; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectoryFile::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offers better protection and avoids the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, eg; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const cha",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:19027,Modifiability,inherit,inheriting,19027,"n must cast the returned object to; the final type, eg; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectoryFile::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. Int_t GetBufferSize() const; Return the buffer size to create new TKeys.; If the stored fBufferSize is null, the value returned is the average; buffer size of objects in the file so far. TKey * GetKey(const char* name, Short_t cycle = 9999) const; -*-*-*Return pointer to key with name,cycle; *-* =====================================; if cycle = 9999 returns highest cycle. void ls(Option_t* option = """") const; List Directory contents*-*-; *-* =======================; Indentation is used to identify the directory tree; Subdirectories are listed first, then objects in memory, then objects on the file. The option can has the following format:; [-d |-m][<regexp>]; Option -d means: only list objects in the file; -m means: only list objects in memory; The <regexp> will be used to match the name of the objects.; By default memory and disk objects are listed. TFile * OpenF",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:28215,Modifiability,inherit,inheritance,28215,"n; is safer than kOverwrite but it is slower.; The ""SingleKey"" option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory.; It returns 0 if the object cannot be written. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). Int_t WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object from pointer of class classname in this directory; obj may not derive from TObject; see TDirectoryFile::WriteTObject for comments. VERY IMPORTANT NOTE:; The value passed as 'obj' needs to be from a pointer to the type described by classname; For example with:; TopClass *top;; BottomClass *bottom;; top = bottom;; you can do:; directory->WriteObjectAny(top,""top"",""name of object"");; directory->WriteObjectAny(bottom,""bottom"",""name of object"");; BUT YOU CAN NOT DO (it will fail in particular with multiple inheritance):; directory->WriteObjectAny(top,""bottom"",""name of object"");. We STRONGLY recommend to use; TopClass *top = ....;; directory->WriteObject(top,""name of object""). see laso remarks in TDirectoryFile::WriteTObject. Int_t WriteObjectAny(const void* obj, const TClass* cl, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object of class with dictionary cl in this directory; obj may not derive from TObject; To get the TClass* cl pointer, one can use; TClass *cl = TClass::GetClass(""classname"");; An alternative is to call the function WriteObjectAny above.; see TDirectoryFile::WriteTObject for comments. void WriteDirHeader(); -*-*Overwrite the Directory header record; *-* =====================================. void WriteKeys(); -*-*-*-*Write KEYS linked list on the file ; *-* ==================================; The li",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:18539,Performance,perform,performed,18539,"al case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, eg; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectoryFile::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. Int_t GetBufferSize() const; Return the buffer size to create new TKeys.; If the stored fBufferSize is null, the value returned is the average; buffer size of objects in the file so far. TKey * GetKey(const char* name, Short_t cycle = 9999) const; -*-*-*Return pointer to key with name,cycle; *-* ======",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:16930,Safety,avoid,avoids,16930," the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectoryFile::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offers better protection and avoids the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY I",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:27069,Safety,safe,safer,27069,"fer object is filled via the class::Streamer function. -If the file is compressed (default) a second buffer is created to; hold the compressed buffer. -Reservation of the corresponding space in the file by looking; in the TFree list of free blocks of the file. -The buffer is written to the file. By default, the buffersize will be taken from the average buffer size; of all objects written to the current file so far.; Use TDirectoryFile::SetBufferSize to force a given buffer size. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by obj->GetName(). The option can be a combination of:; ""SingleKey"", ""Overwrite"" or ""WriteDelete""; Using the ""Overwrite"" option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the ""WriteDelete"" option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The ""SingleKey"" option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory.; It returns 0 if the object cannot be written. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). Int_t WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object from pointer of class classname in this directory; obj may not derive from TObject; see TDirectoryFile::WriteTObject for comments. VERY IMPORTANT NOTE:; The value passed as 'obj' needs to be from a pointer to the type described by classname; For example with:; TopClass *top;; BottomClass *bottom;; top = bottom;; you can do:; directory->WriteObjectAny(top,""top"",""name of",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDirectoryFile.html:27469,Safety,avoid,avoid,27469,"rrent file so far.; Use TDirectoryFile::SetBufferSize to force a given buffer size. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by obj->GetName(). The option can be a combination of:; ""SingleKey"", ""Overwrite"" or ""WriteDelete""; Using the ""Overwrite"" option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the ""WriteDelete"" option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The ""SingleKey"" option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory.; It returns 0 if the object cannot be written. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). Int_t WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object from pointer of class classname in this directory; obj may not derive from TObject; see TDirectoryFile::WriteTObject for comments. VERY IMPORTANT NOTE:; The value passed as 'obj' needs to be from a pointer to the type described by classname; For example with:; TopClass *top;; BottomClass *bottom;; top = bottom;; you can do:; directory->WriteObjectAny(top,""top"",""name of object"");; directory->WriteObjectAny(bottom,""bottom"",""name of object"");; BUT YOU CAN NOT DO (it will fail in particular with multiple inheritance):; directory->WriteObjectAny(top,""bottom"",""name of object"");. We STRONGLY recommend to use; TopClass *top = ....;; directory->WriteObject(top,""name of object""). see laso remarks in TDirectoryFile::WriteTObject. Int_t WriteObjectAny(const void* obj, cons",MatchSource.WIKI,root/html532/TDirectoryFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDirectoryFile.html
https://root.cern/root/html532/TDNDData.html:1345,Availability,error,error,1345,"m_t dt = kNone, void* d = 0, Int_t len = 0, Atom_t act = kNone); virtual~TDNDData(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TDNDData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDNDData.html
https://root.cern/root/html532/TDNDData.html:1429,Availability,error,error,1429," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TDNDData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDNDData.html
https://root.cern/root/html532/TDocDirective.html:1320,Availability,avail,available,1320,"umentation (through TDocParser), it checks for special; words (""begin_something"", ""end_something"", where the begin and end are the; significant part). THtml then searches for a TDocDirective which can handle; these tags (""whatever"" in the example), passes the text enclosed by these; tags to the directive, which in turn processes it. That way, HTML, latex, and C++ macros can be processed by THtml, e.g. to; generate plain HTML or GIF pictures. The classes reposinsible for parsing; that are TDocHtmlDirective, TDocLatexDirective, and TDocMacroDirective,; respecively. Directives can have optional parameters; these are passed as paranthesis; enclosed, comma delimited name=value pairs; see SetParameters(). You can implement your own directive simply by deriving from TDocDirective;; the tag corresponds to TDocDirective's name (e.g. ""HTML"" for ""begin_html""; ""end_html""). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* m",MatchSource.WIKI,root/html532/TDocDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocDirective.html
https://root.cern/root/html532/TDocDirective.html:2347,Availability,error,error,2347," voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual v",MatchSource.WIKI,root/html532/TDocDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocDirective.html
https://root.cern/root/html532/TDocDirective.html:2431,Availability,error,error,2431," TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; ",MatchSource.WIKI,root/html532/TDocDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocDirective.html
https://root.cern/root/html532/TDocDirective.html:1058,Usability,simpl,simply,1058,". Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocDirective. class TDocDirective: public TNamed. When THtml parses documentation (through TDocParser), it checks for special; words (""begin_something"", ""end_something"", where the begin and end are the; significant part). THtml then searches for a TDocDirective which can handle; these tags (""whatever"" in the example), passes the text enclosed by these; tags to the directive, which in turn processes it. That way, HTML, latex, and C++ macros can be processed by THtml, e.g. to; generate plain HTML or GIF pictures. The classes reposinsible for parsing; that are TDocHtmlDirective, TDocLatexDirective, and TDocMacroDirective,; respecively. Directives can have optional parameters; these are passed as paranthesis; enclosed, comma delimited name=value pairs; see SetParameters(). You can implement your own directive simply by deriving from TDocDirective;; the tag corresponds to TDocDirective's name (e.g. ""HTML"" for ""begin_html""; ""end_html""). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root/html532/TDocDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocDirective.html
https://root.cern/root/html532/TDocHtmlDirective.html:1592,Availability,error,error,1592,"::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTDocDirective::DeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const cha",MatchSource.WIKI,root/html532/TDocHtmlDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocHtmlDirective.html
https://root.cern/root/html532/TDocHtmlDirective.html:1676,Availability,error,error,1676,"ne); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTDocDirective::DeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; ",MatchSource.WIKI,root/html532/TDocHtmlDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocHtmlDirective.html
https://root.cern/root/html532/TDocHtmlDirective.html:379,Usability,simpl,simply,379,". TDocHtmlDirective. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocHtmlDirective. class TDocHtmlDirective: public TDocDirective. Process a ""begin_html"" / ""end_html"" block. Stop linking keywords and simply; copy the text enclosed by the directive to the output HTML file. Function Members (Methods); public:. TDocHtmlDirective(); TDocHtmlDirective(const TDocHtmlDirective&); virtual~TDocHtmlDirective(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTDocDirective::DeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ",MatchSource.WIKI,root/html532/TDocHtmlDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocHtmlDirective.html
https://root.cern/root/html532/TDocLatexDirective.html:2162,Availability,error,error,2162,"(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlignment() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; Int_tGetFontSize() const; virtual const char*TObject::GetIconName() const; TList*GetListOfLines() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); const char*GetSeparator() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject",MatchSource.WIKI,root/html532/TDocLatexDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocLatexDirective.html
https://root.cern/root/html532/TDocLatexDirective.html:2246,Availability,error,error,2246," TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlignment() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; Int_tGetFontSize() const; virtual const char*TObject::GetIconName() const; TList*GetListOfLines() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); const char*GetSeparator() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObje",MatchSource.WIKI,root/html532/TDocLatexDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocLatexDirective.html
https://root.cern/root/html532/TDocMacroDirective.html:2011,Availability,error,error,2011,"(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddLine(const TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const cha",MatchSource.WIKI,root/html532/TDocMacroDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocMacroDirective.html
https://root.cern/root/html532/TDocMacroDirective.html:2095,Availability,error,error,2095," TSubString& line); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetEndTag() const; virtual const char*TObject::GetIconName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Bool_tGetResult(TString& result); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; ",MatchSource.WIKI,root/html532/TDocMacroDirective.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocMacroDirective.html
https://root.cern/root/html532/TDocOutput.html:815,Availability,avail,available,815,". TDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocOutput. class TDocOutput: public TObject. THtml generated documentation is written to file by TDocOutput. So far only; output of HTML is implemented. Customization of the output should be done; with THtml's interfaces - TDocOutput should not be used nor re-implemented; directly. TDocOutput generates the index tables:; * classes (THtml invokes TClassDocOutput for each),; * inheritance hierarchy,; * types and typedefs,; * libraries,; * the product index, and; * the module index (including the links to per-module documentation).; It invokes AT&T's GraphViz tool (dot) if available; charts benefit a lot; from it. TDocOutput also writes all pages' header and footer, which can be customized; by calling THtml::SetHeader(), THtml::SetFooter(). Function Members (Methods); public:. TDocOutput(THtml& html); TDocOutput(const TDocOutput&); virtual~TDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModul",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:2733,Availability,error,error,2733,"GClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModuleIndex(); virtual voidCreateProductIndex(); virtual voidCreateTypeIndex(); virtual voidDecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidDecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetExtension() const; THtml*GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const ",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:2817,Availability,error,error,2817,"tmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModuleIndex(); virtual voidCreateProductIndex(); virtual voidCreateTypeIndex(); virtual voidDecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidDecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetExtension() const; THtml*GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const c",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:11172,Deployability,update,updated,11172,"Mixing classes are displayed several times. void CreateClassIndex(); Create index of all classes. void CreateModuleIndex(); Create the class index for each module, picking up documentation from the; module's TModuleDocInfo::GetInputPath() plus the (possibly relative); THtml::GetModuleDocPath(). Also creates the library dependency plot if dot; exists, see THtml::HaveDot(). void CreateProductIndex(); Fetch documentation from THtml::GetProductDocDir() and put it into the; product index page. void CreateClassTypeDefs(); Create a forwarding page for each typedef pointing to a class. void CreateTypeIndex(); Create index of all data types. void DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.Begin() is valid.; When inserting into str.String(), str.Begin() must be updated. void DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.""End()""; (i.e. str.Begin()+str.Length()) is valid.; When inserting into str.String(), str.Length() must be updated. void FixupAuthorSourceInfo(TString& authors); Special author treatment; called when TDocParser::fSourceInfo[kInfoAuthor] is set.; Modifies the author(s) description, which is a comma separated list of tokens; either in the format; (i) ""FirstName LastName "" or; (ii) ""FirstName LastName <link> more stuff""; The first one generates an XWho link (CERN compatible),; the second a http link (WORLD compatible), <link> being e.g.; <mailto:user@host.bla> or <http://www.host.bla/page>. Bool_t IsModified(TClass* classPtr, TDocOutput::EFileType type); Check if file is modified. Input: class",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:11576,Deployability,update,updated,11576,"etch documentation from THtml::GetProductDocDir() and put it into the; product index page. void CreateClassTypeDefs(); Create a forwarding page for each typedef pointing to a class. void CreateTypeIndex(); Create index of all data types. void DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.Begin() is valid.; When inserting into str.String(), str.Begin() must be updated. void DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.""End()""; (i.e. str.Begin()+str.Length()) is valid.; When inserting into str.String(), str.Length() must be updated. void FixupAuthorSourceInfo(TString& authors); Special author treatment; called when TDocParser::fSourceInfo[kInfoAuthor] is set.; Modifies the author(s) description, which is a comma separated list of tokens; either in the format; (i) ""FirstName LastName "" or; (ii) ""FirstName LastName <link> more stuff""; The first one generates an XWho link (CERN compatible),; the second a http link (WORLD compatible), <link> being e.g.; <mailto:user@host.bla> or <http://www.host.bla/page>. Bool_t IsModified(TClass* classPtr, TDocOutput::EFileType type); Check if file is modified. Input: classPtr - pointer to the class; type - file type to compare with; values: kSource, kInclude, kTree. Output: TRUE - if file is modified since last time; FALSE - if file is up to date. void NameSpace2FileName(TString& name); Replace ""::"" in name by ""__""; Replace ""<"", "">"", "" "", "","", ""~"", ""="" in name by ""_""; Replace ""A::X<A::Y>"" by ""A::X<-p0Y>"",; ""A::B::X<A::B::Y>"" by ""A::B::X<-p1Y>"", etc. void ProcessDocInDi",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:18194,Deployability,update,update,18194," user; provided header file will be replaced by the value of this method's; parameter ""title"" before written to the output file. %CLASS% is replaced by; the class name, %INCFILE% by the header file name as given by; TClass::GetDeclFileName() and %SRCFILE% by the source file name as given by; TClass::GetImplFileName(). If the header is written for a non-class page,; i.e. cls==0, lines containing %CLASS%, %INCFILE%, or %SRCFILE% will be; skipped. void WriteHtmlFooter(ostream& out, const char* dir, const char* lastUpdate, const char* author, const char* copyright, const char* footer); Write HTML footer. Internal method invoked by the overload. void WriteHtmlFooter(ostream& out, const char* dir = """", const char* lastUpdate = """", const char* author = """", const char* copyright = """"); Write HTML footer. Input: out - output file stream; dir - usually equal to """" or ""../"", depends of; current file directory position, i.e. if; file is in the fHtml->GetOutputDir(), then dir will be """"; lastUpdate - last update string; author - author's name; copyright - copyright note. Allows optional user provided footer to be written. Root.Html.Footer holds; the file name for this footer. For details see THtml::WriteHtmlHeader (here,; the ""+"" means the user's footer is written in front of Root's!) Occurences; of %AUTHOR%, %CHANGED%, %GENERATED%, and %COPYRIGHT% in the user's file are replaced by; their corresponding values (author, lastUpdate, today, and copyright) before; written to out.; If no author is set (author == """", e.g. for ClassIndex.html"") skip the whole; line of the footer template containing %AUTHOR%. Accordingly for %COPYRIGHT%. void WriteModuleLinks(ostream& out); Create a div containing links to all topmost modules. void WriteLineNumbers(ostream& out, Long_t nLines, const TString& infileBase) const; Create a div containing the line numbers (for a source listing) 1 to nLines.; Create links to the source file's line number and anchors, such that one can; jump to SourceFile.cxx.",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:448,Integrability,interface,interfaces,448,". TDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocOutput. class TDocOutput: public TObject. THtml generated documentation is written to file by TDocOutput. So far only; output of HTML is implemented. Customization of the output should be done; with THtml's interfaces - TDocOutput should not be used nor re-implemented; directly. TDocOutput generates the index tables:; * classes (THtml invokes TClassDocOutput for each),; * inheritance hierarchy,; * types and typedefs,; * libraries,; * the product index, and; * the module index (including the links to per-module documentation).; It invokes AT&T's GraphViz tool (dot) if available; charts benefit a lot; from it. TDocOutput also writes all pages' header and footer, which can be customized; by calling THtml::SetHeader(), THtml::SetFooter(). Function Members (Methods); public:. TDocOutput(THtml& html); TDocOutput(const TDocOutput&); virtual~TDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModul",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:10489,Integrability,depend,dependency,10489," to decide.; We generate HTML, so our extension is "".html"".; See THtml::Convert() for the other parameters. Bool_t CopyHtmlFile(const char* sourceName, const char* destName = """"); Copy file to HTML directory. Input: sourceName - source file name (fully qualified i.e. file system path); destName - optional destination name, if not; specified it would be the same; as the source file name. Output: TRUE if file is successfully copied, or; FALSE if it's not. NOTE: The destination directory is always fHtml->GetOutputDir(). void CreateHierarchy(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are displayed several times. void CreateClassIndex(); Create index of all classes. void CreateModuleIndex(); Create the class index for each module, picking up documentation from the; module's TModuleDocInfo::GetInputPath() plus the (possibly relative); THtml::GetModuleDocPath(). Also creates the library dependency plot if dot; exists, see THtml::HaveDot(). void CreateProductIndex(); Fetch documentation from THtml::GetProductDocDir() and put it into the; product index page. void CreateClassTypeDefs(); Create a forwarding page for each typedef pointing to a class. void CreateTypeIndex(); Create index of all data types. void DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.Begin() is valid.; When inserting into str.String(), str.Begin() must be updated. void DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); Add some colors etc to a source entity, contained in str.; The type of what's contained in str is given by type.; It's called e.g. by TDocParser::BeautifyLine().; This function should assume that only str.""End()""; (i.e. str.Begin()+str.Len",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:18063,Integrability,depend,depends,18063,"stead; of the standard header (USER). Any occurrence of ""%TITLE%"" (without the quotation marks) in the user; provided header file will be replaced by the value of this method's; parameter ""title"" before written to the output file. %CLASS% is replaced by; the class name, %INCFILE% by the header file name as given by; TClass::GetDeclFileName() and %SRCFILE% by the source file name as given by; TClass::GetImplFileName(). If the header is written for a non-class page,; i.e. cls==0, lines containing %CLASS%, %INCFILE%, or %SRCFILE% will be; skipped. void WriteHtmlFooter(ostream& out, const char* dir, const char* lastUpdate, const char* author, const char* copyright, const char* footer); Write HTML footer. Internal method invoked by the overload. void WriteHtmlFooter(ostream& out, const char* dir = """", const char* lastUpdate = """", const char* author = """", const char* copyright = """"); Write HTML footer. Input: out - output file stream; dir - usually equal to """" or ""../"", depends of; current file directory position, i.e. if; file is in the fHtml->GetOutputDir(), then dir will be """"; lastUpdate - last update string; author - author's name; copyright - copyright note. Allows optional user provided footer to be written. Root.Html.Footer holds; the file name for this footer. For details see THtml::WriteHtmlHeader (here,; the ""+"" means the user's footer is written in front of Root's!) Occurences; of %AUTHOR%, %CHANGED%, %GENERATED%, and %COPYRIGHT% in the user's file are replaced by; their corresponding values (author, lastUpdate, today, and copyright) before; written to out.; If no author is set (author == """", e.g. for ClassIndex.html"") skip the whole; line of the footer template containing %AUTHOR%. Accordingly for %COPYRIGHT%. void WriteModuleLinks(ostream& out); Create a div containing links to all topmost modules. void WriteLineNumbers(ostream& out, Long_t nLines, const TString& infileBase) const; Create a div containing the line numbers (for a source listing) 1 to nLines.; ",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:616,Modifiability,inherit,inheritance,616,". TDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocOutput. class TDocOutput: public TObject. THtml generated documentation is written to file by TDocOutput. So far only; output of HTML is implemented. Customization of the output should be done; with THtml's interfaces - TDocOutput should not be used nor re-implemented; directly. TDocOutput generates the index tables:; * classes (THtml invokes TClassDocOutput for each),; * inheritance hierarchy,; * types and typedefs,; * libraries,; * the product index, and; * the module index (including the links to per-module documentation).; It invokes AT&T's GraphViz tool (dot) if available; charts benefit a lot; from it. TDocOutput also writes all pages' header and footer, which can be customized; by calling THtml::SetHeader(), THtml::SetFooter(). Function Members (Methods); public:. TDocOutput(THtml& html); TDocOutput(const TDocOutput&); virtual~TDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModul",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:13346,Testability,test,test,13346,"ate. void NameSpace2FileName(TString& name); Replace ""::"" in name by ""__""; Replace ""<"", "">"", "" "", "","", ""~"", ""="" in name by ""_""; Replace ""A::X<A::Y>"" by ""A::X<-p0Y>"",; ""A::B::X<A::B::Y>"" by ""A::B::X<-p1Y>"", etc. void ProcessDocInDir(ostream& out, const char* indir, const char* outdir, const char* linkdir); Write links to files indir/*.txt, indir/*.html (non-recursive) to out.; If one of the files is called ""index.{html,txt}"" it will be; included in out (instead of copying it to outdir and generating a link; to linkdir). txt files are passed through Convert().; The files' links are sorted alphabetically. void ReferenceEntity(TSubString& str, TClass* entity, const char* comment = 0); Create a reference to a class documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclos",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:13443,Testability,test,test,13443,""","", ""~"", ""="" in name by ""_""; Replace ""A::X<A::Y>"" by ""A::X<-p0Y>"",; ""A::B::X<A::B::Y>"" by ""A::B::X<-p1Y>"", etc. void ProcessDocInDir(ostream& out, const char* indir, const char* outdir, const char* linkdir); Write links to files indir/*.txt, indir/*.html (non-recursive) to out.; If one of the files is called ""index.{html,txt}"" it will be; included in out (instead of copying it to outdir and generating a link; to linkdir). txt files are passed through Convert().; The files' links are sorted alphabetically. void ReferenceEntity(TSubString& str, TClass* entity, const char* comment = 0); Create a reference to a class documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin()",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:13889,Testability,test,test,13889,"ed through Convert().; The files' links are sorted alphabetically. void ReferenceEntity(TSubString& str, TClass* entity, const char* comment = 0); Create a reference to a class documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the ref",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:13986,Testability,test,test,13986,"& str, TClass* entity, const char* comment = 0); Create a reference to a class documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:14423,Testability,test,test,14423,"=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. Bool_t ReferenceIsRelative(const char* reference) const; Check whether reference is a relative reference, and can (or should); be prependen by relative paths. For HTML, check that it doesn't start; with ""http://"" or ""https://"". const char* ReplaceSpecialChars(char c); Replace ampersand, less-than and greater-than character",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:14520,Testability,test,test,14520,"str, TDataMember* entity, const char* comment = 0); Create a reference to a data member documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. Bool_t ReferenceIsRelative(const char* reference) const; Check whether reference is a relative reference, and can (or should); be prependen by relative paths. For HTML, check that it doesn't start; with ""http://"" or ""https://"". const char* ReplaceSpecialChars(char c); Replace ampersand, less-than and greater-than character, writing to out.; If 0 is returned, no replacement needs to be done. void ReplaceSpecialChars(TStr",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:14957,Testability,test,test,14957,"a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. Bool_t ReferenceIsRelative(const char* reference) const; Check whether reference is a relative reference, and can (or should); be prependen by relative paths. For HTML, check that it doesn't start; with ""http://"" or ""https://"". const char* ReplaceSpecialChars(char c); Replace ampersand, less-than and greater-than character, writing to out.; If 0 is returned, no replacement needs to be done. void ReplaceSpecialChars(TString& text, Ssiz_t& pos); Replace ampersand, less-than and greater-than character. Input: text - text where replacement will happen,; pos - index of char to be replaced; will point to next char to be; replaced when function returns. void ReplaceSpecialChars(TString& text); Replace ampersand, less-than and greater-than character. Input: text - text where replacement will happen,. void ReplaceSpecialChars(ostream& out, const char* str",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocOutput.html:15054,Testability,test,test,15054,"bString& str, TDataType* entity, const char* comment = 0); Create a reference to a type documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. void ReferenceEntity(TSubString& str, TMethod* entity, const char* comment = 0); Create a reference to a method documentation page.; str encloses the text to create the reference for (e.g. name of instance).; comment will be added e.g. as tooltip text.; After the reference is put into str.String(), str will enclose the reference; and the original text. Example:; Input:; str.String(): ""a gHtml test""; str.Begin(): 2; str.Length(): 5; Output:; str.String(): ""a <a href=""THtml.html"">gHtml</a> test""; str.Begin(): 2; str.Length(): 30. Bool_t ReferenceIsRelative(const char* reference) const; Check whether reference is a relative reference, and can (or should); be prependen by relative paths. For HTML, check that it doesn't start; with ""http://"" or ""https://"". const char* ReplaceSpecialChars(char c); Replace ampersand, less-than and greater-than character, writing to out.; If 0 is returned, no replacement needs to be done. void ReplaceSpecialChars(TString& text, Ssiz_t& pos); Replace ampersand, less-than and greater-than character. Input: text - text where replacement will happen,; pos - index of char to be replaced; will point to next char to be; replaced when function returns. void ReplaceSpecialChars(TString& text); Replace ampersand, less-than and greater-than character. Input: text - text where replacement will happen,. void ReplaceSpecialChars(ostream& out, const char* string); Replace ampersand, less-than and greater-than characters, writing to out. Input: out - output",MatchSource.WIKI,root/html532/TDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocOutput.html
https://root.cern/root/html532/TDocParser.html:2490,Availability,error,error,2490,") const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); virtual voidTObject::Copy(TObject& object) const; virtual voidDecorateKeywords(TString& text); virtual voidDecorateKeywords(ostream& out, const char* text); voidDecrementMethodCount(const char* name); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteDirectiveOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() co",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:2574,Availability,error,error,2574,"const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); virtual voidTObject::Copy(TObject& object) const; virtual voidDecorateKeywords(TString& text); virtual voidDecorateKeywords(ostream& out, const char* text); voidDecrementMethodCount(const char* name); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteDirectiveOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const cha",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:12381,Energy Efficiency,reduce,reduce,12381,"a members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output generated by prior runs of all known directives;; the output file names might have changes. void ExpandCPPLine(TString& line, Ssiz_t& pos); Expand preprocessor statements. Input: line - line containing the CPP statement,; pos - position of '#'. NOTE: Looks for the #include statements and; creates link to the corresponding file; if such file exists. void GetCurrentModule(TString& out_module) const; Return the name of module for which sources are currently parsed. Bool_t HandleDirective(TString& keyword, Ssiz_t& pos, TString& word, Ssiz_t& copiedToCommentUpTo); Process directives to the documentation engine, like ""Begin_Html"" / ""End_Html"",; ""Begin_Macro"" / ""End_Macro"", and ""Begin_Latex"" / ""End_Latex"". UInt_t InContext(Int_t context) const; checks whether we are in a parse context, return the entry closest; to the current context.; If context is a EParseContextFlag j",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:17485,Integrability,depend,depending,17485,"ource(ostream& out); Given fCurrentClass, look for methods in its source file,; and extract documentation to out, while beautifying the source; file in parallel. void LocateMethodsInHeaderInline(ostream& out); Given fCurrentClass, look for methods in its header file,; and extract documentation to out. void LocateMethodsInHeaderClassDecl(ostream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:2980,Security,access,access,2980,"dTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteDirectiveOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; UInt_tInContext(Int_t context) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:3155,Security,access,access,3155,"aw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; UInt_tInContext(Int_t context) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObje",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:3291,Security,access,access,3291,"ENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; UInt_tInContext(Int_t context) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsName(UChar_t c); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; static",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:9440,Security,access,access,9440,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:10405,Security,access,access,10405,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:11174,Security,access,accessible,11174,"ineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source info elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characte",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:11537,Security,access,access,11537,"arsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source info elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output genera",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:11675,Security,hash,hashing,11675,"nfo elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output generated by prior runs of all known directives;; the output file names might have changes. void ExpandCPPLine(TString& lin",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:11705,Security,hash,hash,11705,"nfo elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output generated by prior runs of all known directives;; the output file names might have changes. void ExpandCPPLine(TString& lin",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:17864,Security,access,access,17864,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:17898,Security,access,access,17898,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:18131,Security,access,access,18131,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:18169,Security,access,access,18169,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:18223,Security,access,access,18223,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:18261,Security,access,access,18261,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:452,Testability,test,testMainFrame,452,". TDocParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocParser. class TDocParser: public TObject. Parse C++ source or header, and extract documentation. Also handles special macros like. Picture; Source. {; TGMainFrame* f = new TGMainFrame(0, 100, 100);; f->SetName(""testMainFrame""n c's part of the name of the image; TGButton* b = new TGTextButton(f, ""Test Button"");; f->AddFrame(b);; f->MapSubwindows();; f->Resize(f->GetDefaultSize());. f->MapWindow();; return f; ; } ; or multiline Latex aligned at =:. ; even without alignment:; and what about running an external macro?. Picture; Source. TObject* testmacro() ; {; ; TH1* h = new TH1F(""h"", ""h"", 100, 0., 1.);; h->FillRandom(""gaus"",10000);; TCanvas* c=new TCanvas(""c"",""c"");; h->Draw();; ; return c;; }. and some nested stuff which doesn't work yet: . /* BEGIN_LATEX Wow,^{an}_{image}^{inside}_{a}^{html}_{block}; END_LATEX; */; . Function Members (Methods); public:. TDocParser(TDocOutput& docOutput); TDocParser(TClassDocOutput& docOutput, TClass* cl); virtual~TDocParser(); voidTObject::AbstractMethod(const char* method) const; static voidAnchorFromLine(const TString& line, TString& anchor); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); virtual voidTObject::Copy(TObject& object) const; virtual voidDecorateKeywords(TString& text); virtual voidDecorateKeywords(ostream& out, const char* text); voidDecrementMethodCount(const char* name); virtual voidTObject::Delete(O",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:788,Testability,test,testmacro,788,". TDocParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TDocParser. class TDocParser: public TObject. Parse C++ source or header, and extract documentation. Also handles special macros like. Picture; Source. {; TGMainFrame* f = new TGMainFrame(0, 100, 100);; f->SetName(""testMainFrame""n c's part of the name of the image; TGButton* b = new TGTextButton(f, ""Test Button"");; f->AddFrame(b);; f->MapSubwindows();; f->Resize(f->GetDefaultSize());. f->MapWindow();; return f; ; } ; or multiline Latex aligned at =:. ; even without alignment:; and what about running an external macro?. Picture; Source. TObject* testmacro() ; {; ; TH1* h = new TH1F(""h"", ""h"", 100, 0., 1.);; h->FillRandom(""gaus"",10000);; TCanvas* c=new TCanvas(""c"",""c"");; h->Draw();; ; return c;; }. and some nested stuff which doesn't work yet: . /* BEGIN_LATEX Wow,^{an}_{image}^{inside}_{a}^{html}_{block}; END_LATEX; */; . Function Members (Methods); public:. TDocParser(TDocOutput& docOutput); TDocParser(TClassDocOutput& docOutput, TClass* cl); virtual~TDocParser(); voidTObject::AbstractMethod(const char* method) const; static voidAnchorFromLine(const TString& line, TString& anchor); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConvert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); virtual voidTObject::Copy(TObject& object) const; virtual voidDecorateKeywords(TString& text); virtual voidDecorateKeywords(ostream& out, const char* text); voidDecrementMethodCount(const char* name); virtual voidTObject::Delete(O",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDocParser.html:10323,Usability,undo,undocumented,10323,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root/html532/TDocParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDocParser.html
https://root.cern/root/html532/TDOMParser.html:3802,Availability,error,error,3802,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTXMLParser::GetParseCode() const; const char*TXMLParser::GetParseCodeMessage(Int_t parseCode) const; Bool_tTXMLParser::GetReplaceEntities() const; Bool_tTXMLParser::GetStopOn",MatchSource.WIKI,root/html532/TDOMParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDOMParser.html
https://root.cern/root/html532/TDOMParser.html:3886,Availability,error,error,3886,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTXMLParser::GetParseCode() const; const char*TXMLParser::GetParseCodeMessage(Int_t parseCode) const; Bool_tTXMLParser::GetReplaceEntities() const; Bool_tTXMLParser::GetStopOnError() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html532/TDOMParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDOMParser.html
https://root.cern/root/html532/TDOMParser.html:9886,Availability,error,errorcodes,9886,"rClassName() const; virtual voidTXMLParser::InitializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TDOMParser(const TDOMParser&); TDOMParser&operator=(const TDOMParser&); Int_tParseContext(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TXMLDocument*fTXMLDocxmlDoc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDOMParser(); TDOMParser constructor. ~TDOMParser(); TDOMParser destructor, it calls ReleaseUnderlying(). void ReleaseUnderlying(); Release any existing document. Int_t ParseFile(const char* filename); Parse the XML file where filename is the XML file name.; It will create a TXMLDocument if the file is parsed without; any error. It returns parse code error in case of parse error,; see TXMLParser. Int_t ParseBuffer(const char* buffer, Int_t len); It parses a buffer, much like ParseFile(). Int_t ParseContext(); Creates a XML docu",MatchSource.WIKI,root/html532/TDOMParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TDOMParser.html
