id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,Load,Load,37,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:400,Performance,load,loads,400,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:465,Performance,load,loads,465,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:654,Performance,load,loads,654,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:909,Performance,load,load,909,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:975,Performance,load,load,975,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1209,Performance,load,load,1209,"ion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and term",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1370,Performance,load,load,1370,"is pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their success",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1376,Performance,load,loads,1376,"is pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their success",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1552,Performance,load,loads,1552,"s is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1648,Performance,load,loads,1648,"thing also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1673,Performance,perform,performance,1673,"thing also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1871,Performance,load,loads,1871,"xploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only con",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1954,Performance,load,load,1954,"al elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2023,Performance,load,load,2023,"al elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2433,Performance,load,loads,2433,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2525,Performance,load,loaded,2525,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2836,Security,access,accesses,2836,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:623,Usability,simpl,simplicity,623,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:62,Performance,load,loads,62,"// Equivalence class key, the initial tuple by which we group loads/stores.; // Loads/stores with different EqClassKeys are never merged.; //; // (We could in theory remove element-size from the this tuple. We'd just need; // to fix up the vector packing/unpacking code.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:80,Performance,Load,Loads,80,"// Equivalence class key, the initial tuple by which we group loads/stores.; // Loads/stores with different EqClassKeys are never merged.; //; // (We could in theory remove element-size from the this tuple. We'd just need; // to fix up the vector packing/unpacking code.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Load,3,/* Load/Store element size bits */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:132,Performance,load,loads,132,"// A Chain is a set of instructions such that:; // - All instructions have the same equivalence class, so in particular all are; // loads, or all are stores.; // - We know the address accessed by the i'th chain elem relative to the; // chain's leader instruction, which is the first instr of the chain in BB; // order.; //; // Chains have two canonical orderings:; // - BB order, sorted by Instr->comesBefore.; // - Offset order, sorted by OffsetFromLeader.; // This pass switches back and forth between these orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:184,Security,access,accessed,184,"// A Chain is a set of instructions such that:; // - All instructions have the same equivalence class, so in particular all are; // loads, or all are stores.; // - We know the address accessed by the i'th chain elem relative to the; // chain's leader instruction, which is the first instr of the chain in BB; // order.; //; // Chains have two canonical orderings:; // - BB order, sorted by Instr->comesBefore.; // - Offset order, sorted by OffsetFromLeader.; // This pass switches back and forth between these orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Integrability,depend,depends,37,"/// Reorders the instructions that I depends on (the instructions defining its; /// operands), to ensure they dominate I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:196,Usability,simpl,simpler,196,"// We could erase instrs right after vectorizing them, but that can mess up; // our BB iterators, and also can make the equivalence class keys point to; // freed memory. This is fixable, but it's simpler just to wait until we're; // done with the BB and erase all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:66,Performance,load,loads,66,"/// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores; /// in the same BB with the same value for getUnderlyingObject() etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:104,Security,access,access,104,"/// Runs the vectorizer on one chain, i.e. a subset of an equivalence class; /// where all instructions access a known, constant offset from the first; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:61,Performance,load,loads,61,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:131,Performance,load,loads,131,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:47,Safety,safe,safe,47,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:118,Safety,safe,safe,118,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:61,Security,access,accesses,61,"/// Splits the chain into subchains that make legal, aligned accesses.; /// Discards any length-1 subchains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:62,Performance,load,load,62,/// Converts the instrs in the chain into a single vectorized load or store.; /// Adds the old scalar loads/stores to ToErase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:102,Performance,load,loads,102,/// Converts the instrs in the chain into a single vectorized load or store.; /// Adds the old scalar loads/stores to ToErase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:60,Performance,load,load,60,/// Gets the element type of the vector that the chain will load or store.; /// This is nontrivial because the chain may contain elements of different; /// types; e.g. it's legal to have a chain that contains both i32 and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:64,Availability,down,down,64,"/// Determines whether ChainElem can be moved up (if IsLoad) or down (if; /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias; /// instructions.; ///; /// The map ChainElemOffsets must contain all of the elements in; /// [ChainBegin, ChainElem] and their offsets from some arbitrary base; /// address. It's ok if it contains additional entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:13,Performance,load,loads,13,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:110,Performance,load,load,110,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:151,Performance,load,load,151,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:209,Performance,load,load,209,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:263,Performance,load,load,263,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:379,Performance,load,load,379,"// Break up the BB if there are any instrs which aren't guaranteed to transfer; // execution to their successor.; //; // Consider, for example:; //; // def assert_arr_len(int n) { if (n < 2) exit(); }; //; // load arr[0]; // call assert_array_len(arr.length); // load arr[1]; //; // Even though assert_arr_len does not read or write any memory, we can't; // speculate the second load before the call. More info at; // https://github.com/llvm/llvm-project/issues/52950.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:143,Security,hash,hashtable,143,"// We know that elements in the chain with nonverlapping offsets can't; // alias, but AA may not be smart enough to figure this out. Use a; // hashtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:76,Availability,down,down,76,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,load,load,37,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:131,Performance,load,loads,131,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:10,Security,access,accesses,10,"// `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:275,Performance,load,load,275,"// The rules are:; // - If there are any pointer types in the chain, use an integer type.; // - Prefer an integer type if it appears in the chain.; // - Otherwise, use the first type in the chain.; //; // The rule about pointer types is a simplification when we merge e.g. a load; // of a ptr and a double. There's no direct conversion from a ptr to a; // double; it requires a ptrtoint followed by a bitcast.; //; // It's unclear to me if the other rules have any practical effect, but we do; // it to match this pass's previous behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:239,Usability,simpl,simplification,239,"// The rules are:; // - If there are any pointer types in the chain, use an integer type.; // - Prefer an integer type if it appears in the chain.; // - Otherwise, use the first type in the chain.; //; // The rule about pointer types is a simplification when we merge e.g. a load; // of a ptr and a double. There's no direct conversion from a ptr to a; // double; it requires a ptrtoint followed by a bitcast.; //; // It's unclear to me if the other rules have any practical effect, but we do; // it to match this pass's previous behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:164,Energy Efficiency,power,power,164,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:12,Usability,simpl,simple,12,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:24,Energy Efficiency,power,power,24,"// Note, VecElemTy is a power of 2, but might be less than one byte. For; // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case; // VecElemTy would be i4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:33,Energy Efficiency,power,powers,33,"// SizeBytes and VecElemBits are powers of 2, so they divide evenly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:8,Performance,load,load,8,// Is a load/store with this alignment allowed by TTI and at least as fast; // as an unvectorized load/store?; //; // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:98,Performance,load,load,98,// Is a load/store with this alignment allowed by TTI and at least as fast; // as an unvectorized load/store?; //; // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:92,Deployability,upgrade,upgrade,92,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:358,Deployability,upgrade,upgrade,358,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:12,Performance,load,loading,12,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:224,Testability,test,tests,224,"// If we're loading/storing from an alloca, align it if possible.; //; // FIXME: We eagerly upgrade the alignment, regardless of whether TTI; // tells us this is beneficial. This feels a bit odd, but it matches; // existing tests. This isn't *so* bad, because at most we align to 4; // bytes (current value of StackAdjustedAlignment).; //; // FIXME: We will upgrade the alignment of the alloca even if it turns out; // we can't vectorize for some other reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:14,Energy Efficiency,power,power,14,"// VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller; // than 1 byte (e.g. VecTy == <32 x i1>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:55,Deployability,upgrade,upgraded,55,"// If this is a load/store of an alloca, we might have upgraded the alloca's; // alignment earlier. Get the new alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:16,Performance,load,load,16,"// If this is a load/store of an alloca, we might have upgraded the alloca's; // alignment earlier. Get the new alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:50,Performance,load,load,50,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:132,Performance,load,loads,132,// Loads get hoisted to the location of the first load in the chain. We may; // also need to hoist the (transitive) operands of the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:218,Performance,load,load,218,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:264,Performance,load,load,264,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:313,Performance,load,load,313,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:350,Performance,load,load,350,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:418,Performance,load,loadv,418,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:426,Performance,load,load,426,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:473,Performance,load,loadv,473,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:509,Performance,load,loadv,509,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:558,Performance,load,loadv,558,"// Finally, we need to reorder the instrs in the BB so that the (transitive); // operands of VecInst appear before it. To see why, suppose we have; // vectorized the following code:; //; // ptr1 = gep a, 1; // load1 = load i32 ptr1; // ptr0 = gep a, 0; // load0 = load i32 ptr0; //; // We will put the vectorized load at the location of the earliest load in; // the BB, i.e. load1. We get:; //; // ptr1 = gep a, 1; // loadv = load <2 x i32> ptr0; // load0 = extractelement loadv, 0; // load1 = extractelement loadv, 1; // ptr0 = gep a, 0; //; // Notice that loadv uses ptr0, which is defined *after* it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:13,Performance,load,loads,13,// Invariant loads can always be reordered; by definition they are not; // clobbered by stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:3,Performance,Load,Loads,3,// Loads can be reordered with other loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:37,Performance,load,loads,37,// Loads can be reordered with other loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:38,Performance,load,loads,38,// Stores can be sunk below invariant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:235,Performance,load,loads,235,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:292,Performance,load,load,292,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:100,Security,access,accesses,100,"// If I is in the chain, we can tell whether it aliases ChainIt by checking; // what offset ChainIt accesses. This may be better than AA is able to do.; //; // We should really only have duplicate offsets for stores (the duplicate; // loads should be CSE'ed), but in case we have a duplicate load, we'll; // split the chain so we don't have to handle this case specially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:138,Safety,safe,safe,138,"// If both OpA and OpB are adds with NSW/NUW and with one of the operands; // being the same, we can guarantee that the transformation is safe if we can; // prove that OpA won't overflow when Ret added to the other operand of OpA.; // For example:; // %tmp7 = add nsw i32 %tmp2, %v0; // %tmp8 = sext i32 %tmp7 to i64; // ...; // %tmp11 = add nsw i32 %v0, 1; // %tmp12 = add nsw i32 %tmp2, %tmp11; // %tmp13 = sext i32 %tmp12 to i64; //; // Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.; // It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds; // 1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:116,Performance,load,load,116,"// When computing known bits, use the GEPs as context instructions, since; // they likely are in the same BB as the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:272,Security,access,accesses,272,"// The select's themselves are distinct instructions even if they share; // the same condition and evaluate to consecutive pointers for true and; // false values of the condition. Therefore using the select's themselves; // for grouping instructions would put consecutive accesses into different; // lists and they won't be even checked for being consecutive, and won't; // be vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:145,Performance,load,load,145,"// Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain; // functions are currently using an integer type for the vectorized; // load/store, and does not support casting between the integer type and a; // vector of pointers (e.g. i64 to <2 x i16*>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:15,Energy Efficiency,power,power-of-two,15,// Only handle power-of-two sized elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:29,Security,hash,hashtable,29,"// Machinery to build an MRU-hashtable of Chains.; //; // (Ideally this could be done with MapVector, but as currently implemented,; // moving an element to the front of a MapVector is O(n).)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:64,Performance,scalab,scalable,64,"// If the metadata doesn't explicitly specify whether to enable scalable; // vectorization, then decide based on the following criteria (increasing; // level of priority):; // - Target default; // - Metadata width; // - Force option (always overrides)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:64,Performance,scalab,scalable,64,"// If the width is set, but the metadata says nothing about the scalable; // property, then assume it concerns only a fixed-width UserVF.; // If width is not set, the flag takes precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:42,Performance,scalab,scalable,42,"// If the flag is set to force any use of scalable vectors, override the loop; // hints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectorization is disabled if no preference is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Deployability,Update,Update,3,// Update internal cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:19,Performance,cache,cache,19,// Update internal cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:123,Availability,error,errors,123,// FIXME: Add interleave.disable metadata. This will allow; // vectorize.disable to be used without disabling the pass and errors; // to differentiate between disabled vectorization and a width of 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,Availability,redundant,redundantly,1027,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:989,Integrability,depend,depend,989,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,Safety,redund,redundantly,1027,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:94,Modifiability,variab,variable,94,/// Check that the instruction has outside loop users and is not an; /// identified reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:227,Availability,mask,masked,227,"// FIXME: Currently, the set of symbolic strides is sometimes queried before; // it's collected. This happens from canVectorizeWithIfConvert, when the; // pointer is checked to reference consecutive elements suitable for a; // masked access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:234,Security,access,access,234,"// FIXME: Currently, the set of symbolic strides is sometimes queried before; // it's collected. This happens from canVectorizeWithIfConvert, when the; // pointer is checked to reference consecutive elements suitable for a; // masked access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:6,Modifiability,rewrite,rewriter,6,"/// A rewriter to build the SCEVs for each of the VF lanes in the expected; /// vectorized loop, which can then be compared to detect their uniformity. This; /// is done by replacing the AddRec SCEVs of the original scalar loop (TheLoop); /// with new AddRecs where the step is multiplied by StepMultiplier and Offset *; /// Step is added. Also checks if all sub-expressions are analyzable w.r.t.; /// uniformity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,Safety,detect,detect,127,"/// A rewriter to build the SCEVs for each of the VF lanes in the expected; /// vectorized loop, which can then be compared to detect their uniformity. This; /// is done by replacing the AddRec SCEVs of the original scalar loop (TheLoop); /// with new AddRecs where the step is multiplied by StepMultiplier and Offset *; /// Step is added. Also checks if all sub-expressions are analyzable w.r.t.; /// uniformity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:22,Modifiability,rewrite,rewrite,22,/// Loop for which to rewrite AddRecsFor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:213,Safety,avoid,avoid,213,/// Bail out if the expression does not contain an UDiv expression.; /// Uniform values which are not loop invariant require operations to strip; /// out the lowest bits. For now just look for UDivs and use it to avoid; /// re-writing UDIV-free expressions for other lanes to limit compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite AddRecs in TheLoop to step by VF and check if the expression for; // lane 0 matches the expressions for all other lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:60,Performance,load,loads,60,"// Note: There's nothing inherent which prevents predicated loads and; // stores from being uniform. The current lowering simply doesn't handle; // it; in particular, the cost model distinguishes scatter/gather from; // scalar w/predication, and we currently rely on the scalar path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:122,Usability,simpl,simply,122,"// Note: There's nothing inherent which prevents predicated loads and; // stores from being uniform. The current lowering simply doesn't handle; // it; in particular, the cost model distinguishes scatter/gather from; // scalar w/predication, and we currently rely on the scalar path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:77,Usability,simpl,simple,77,"// Check whether inner loops are uniform. At this point, we only support; // simple outer loops scenarios with uniform nested loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:254,Modifiability,variab,variable,254,"// Use the phi node with the widest type as induction. Use the last; // one if there are multiple (no good reason for doing this other; // than it is expedient). We've checked that it begins at zero and; // steps by one, so this is a canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,Safety,hazard,hazards,51,// Scan the instructions in the block and look for hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:193,Modifiability,variab,variables,193,"// If this PHINode is not in the header block, then we know that we; // can convert it to select during if-conversion. No need to check if; // the PHIs in this block are induction or reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,Integrability,depend,dependencies,127,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:113,Safety,Unsafe,Unsafe,113,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:248,Availability,avail,available,248,"// TODO: Instead of recording the AllowedExit, it would be good to; // record the complementary set: NotAllowedExit. These include (but may; // not be limited to):; // 1. Reduction phis as they represent the one-before-last value, which; // is not available when vectorized; // 2. Induction phis and increment when SCEV predicates cannot be used; // outside the loop - see addInductionPhi; // 3. Non-Phis with outside uses when SCEV predicates cannot be used; // outside the loop - see call to hasOutsideLoopUser in the non-phi; // handling below; // 4. FixedOrderRecurrence phis that can possibly be handled by; // extraction.; // By recording these, we can then reason about ways to vectorize each; // of these NotAllowedExit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:151,Availability,avail,available,151,// end of PHI handling; // We handle calls that:; // * Are debug info intrinsics.; // * Have a mapping to an IR intrinsic.; // * Have a vector version available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:19,Performance,load,loads,19,"// For nontemporal loads, check that a nontemporal vector version is; // supported on the target (arbitrarily try a vector of 2 elements).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:29,Safety,unsafe,unsafe,29,"// FP instructions can allow unsafe algebra, thus vectorizable by; // non-IEEE-754 compliant SIMD units.; // This applies to floating-point math operations and calls, not memory; // operations, shuffles, or casts, as they don't change precision or; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:10,Safety,safe,safely,10,// We can safely vectorize loops where instructions within the loop are; // used outside the loop only if the SCEV predicates within the loop is; // same as outside the loop. Allowing the exit means reusing the SCEV; // outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:130,Integrability,depend,dependence,130,"// For each invariant address, check its last stored value is the result; // of one of our reductions.; //; // We do not check if dependence with loads exists because they are; // currently rejected earlier in LoopAccessInfo::analyzeLoop. In case this; // behaviour changes we have to modify this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:146,Performance,load,loads,146,"// For each invariant address, check its last stored value is the result; // of one of our reductions.; //; // We do not check if dependence with loads exists because they are; // currently rejected earlier in LoopAccessInfo::analyzeLoop. In case this; // behaviour changes we have to modify this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:482,Testability,test,test,482,"// Earlier stores to this address are effectively deadcode.; // With opaque pointers it is possible for one pointer to be used with; // different sizes of stored values:; // store i32 0, ptr %x; // store i8 0, ptr %x; // The latest store doesn't complitely overwrite the first one in the; // example. That is why we have to make sure that types of stored; // values are same.; // TODO: Check that bitwidth of unhandled store is smaller then the; // one that overwrites it and add a test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:24,Security,validat,validate,24,// TODO: we should also validate against InvariantMemSets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:16,Availability,mask,masked,16,"// We can allow masked calls if there's at least one vector variant, even; // if we end up scalarizing due to the cost model calculations.; // TODO: Allow other calls if they have appropriate attributes... readonly; // and argmemonly?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:25,Availability,mask,masking,25,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:3,Performance,Load,Loads,3,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,Safety,safe,safe,51,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:42,Availability,mask,masking,42,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:58,Availability,mask,masked,58,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:108,Performance,load,load-blend-store,108,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:179,Performance,race condition,race conditions,179,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:134,Safety,safe,safe,134,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:320,Availability,fault,fault,320,"// A list of pointers which are known to be dereferenceable within scope of; // the loop body for each iteration of the loop which executes. That is,; // the memory pointed to can be dereferenced (with the access size implied by; // the value's type) unconditionally within the loop header without; // introducing a new fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:206,Security,access,access,206,"// A list of pointers which are known to be dereferenceable within scope of; // the loop body for each iteration of the loop which executes. That is,; // the memory pointed to can be dereferenced (with the access size implied by; // the value's type) unconditionally within the loop header without; // introducing a new fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,Safety,safe,safe,11,// Collect safe addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:185,Availability,fault,fault,185,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:248,Performance,load,loads,248,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:294,Performance,concurren,concurrency,294,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:60,Safety,safe,safe,60,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:68,Security,access,access,68,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:28,Testability,test,tests,28,"// Okay! We've done all the tests. If any have failed, return false. Otherwise; // we can vectorize, and at this point we don't have any other mem analysis; // which may limit our maximum vectorization factor, so just return true with; // no restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:67,Availability,mask,masking,67,// TODO: handle non-reduction outside users when tail is folded by masking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:36,Safety,safe,safely,36,// The list of pointers that we can safely read and write to remains empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,Availability,mask,masked,11,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:79,Availability,Mask,MaskedOp,79,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:48,Safety,avoid,avoid,48,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:655,Performance,optimiz,optimizes,655,"//===- LoopVectorizationPlanner.h - Planner for LoopVectorization ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides a LoopVectorizationPlanner class.; /// InnerLoopVectorizer vectorizes loops which contain only one basic; /// LoopVectorizationPlanner - drives the vectorization process after having; /// passed Legality checks.; /// The planner builds and optimizes the Vectorization Plans which record the; /// decisions how to vectorize the given loop. In particular, represent the; /// control-flow of the vectorized version, the replication of instructions that; /// are to be scalarized, and interleave access groups.; ///; /// Also provides a VPlan-based builder utility analogous to IRBuilder.; /// It provides an instruction-level API for generating VPInstructions while; /// abstracting away the Recipe manipulation details.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:907,Security,access,access,907,"//===- LoopVectorizationPlanner.h - Planner for LoopVectorization ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides a LoopVectorizationPlanner class.; /// InnerLoopVectorizer vectorizes loops which contain only one basic; /// LoopVectorizationPlanner - drives the vectorization process after having; /// passed Legality checks.; /// The planner builds and optimizes the Vectorization Plans which record the; /// decisions how to vectorize the given loop. In particular, represent the; /// control-flow of the vectorized version, the replication of instructions that; /// are to be scalarized, and interleave access groups.; ///; /// Also provides a VPlan-based builder utility analogous to IRBuilder.; /// It provides an instruction-level API for generating VPInstructions while; /// abstracting away the Recipe manipulation details.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:4,Usability,Clear,Clear,4,/// Clear the insertion point: created instructions will not be inserted into; /// a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:138,Performance,scalab,scalable,138,/// A class that represents two vectorization factors (initialized with 0 by; /// default). One for fixed-width vectorization and one for scalable; /// vectorization. This can be used by the vectorizer to choose from a range of; /// fixed and/or scalable VFs in order to find the most cost-effective VF to; /// vectorize with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:246,Performance,scalab,scalable,246,/// A class that represents two vectorization factors (initialized with 0 by; /// default). One for fixed-width vectorization and one for scalable; /// vectorization. This can be used by the vectorizer to choose from a range of; /// fixed and/or scalable VFs in order to find the most cost-effective VF to; /// vectorize with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,Performance,scalab,scalable,37,/// \return true if either fixed- or scalable VF is non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,Performance,scalab,scalable,37,/// \return true if either fixed- or scalable VF is a valid vector VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:20,Security,access,access,20,/// The interleaved access analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:130,Safety,avoid,avoided,130,"/// Plan how to best vectorize, return the best VF and its cost, or; /// std::nullopt if vectorization and interleaving should be avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:188,Safety,avoid,avoid,188,/// Generate the IR code for the vectorized loop captured in VPlan \p BestPlan; /// according to the best selected \p VF and \p UF.; ///; /// TODO: \p IsEpilogueVectorization is needed to avoid issues due to epilogue; /// vectorization re-using plans for both the main and epilogue vector loops.; /// It should be removed once the re-use issue has been fixed.; /// \p ExpandedSCEVs is passed during execution of the plan for epilogue loop; /// to re-use expansion results generated during main plan execution.; ///; /// Returns a mapping of SCEVs to their expanded IR values and a mapping for; /// the reduction resume values. Note that this is a temporary workaround; /// needed due to the current epilogue handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:612,Usability,resume,resume,612,/// Generate the IR code for the vectorized loop captured in VPlan \p BestPlan; /// according to the best selected \p VF and \p UF.; ///; /// TODO: \p IsEpilogueVectorization is needed to avoid issues due to epilogue; /// vectorization re-using plans for both the main and epilogue vector loops.; /// It should be removed once the re-use issue has been fixed.; /// \p ExpandedSCEVs is passed during execution of the plan for epilogue loop; /// to re-use expansion results generated during main plan execution.; ///; /// Returns a mapping of SCEVs to their expanded IR values and a mapping for; /// the reduction resume values. Note that this is a temporary workaround; /// needed due to the current epilogue handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:4,Testability,Test,Test,4,"/// Test a \p Predicate on a \p Range of VF's. Return the value of applying; /// \p Predicate on Range.Start, possibly decreasing Range.End such that the; /// returned value holds for the entire \p Range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,Energy Efficiency,power,power-of-,21,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,Energy Efficiency,power,power-of-,21,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop. This method creates VPlans using VPRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1945,Modifiability,variab,variable,1945,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:2066,Modifiability,Variab,Variable,2066,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1089,Performance,perform,performs,1089," the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:2196,Security,access,access,2196,"bility of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has three parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:348,Integrability,depend,depending,348,"// Option prefer-predicate-over-epilogue indicates that an epilogue is undesired,; // that predication is preferred, and this lists all options. I.e., the; // vectorizer will try to fold the tail-loop (epilogue) into the vector body; // and predicate the instructions accordingly. If tail-folding fails, there are; // different fallback strategies depending on these values:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masking,33,"/// An interleave-group may need masking if it resides in a block that needs; /// predication, or in order to mask away gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Availability,mask,mask,110,"/// An interleave-group may need masking if it resides in a block that needs; /// predication, or in order to mask away gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Performance,load,load,32,// Runtime interleave loops for load/store throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Performance,throughput,throughput,43,// Runtime interleave loops for load/store throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Testability,test,testing,32,// This flag enables the stress testing of the VPlan H-CFG construction in the; // VPlan-native vectorization path. It must be used in conjuction with; // -enable-vplan-native-path. -vplan-verify-hcfg can also be used to enable the; // verification of the H-CFGs built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Modifiability,variab,variables,82,// Likelyhood of bypassing the vectorized loop because assumptions about SCEV; // variables not overflowing do not hold. See `emitSCEVChecks`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:106,Energy Efficiency,allocate,allocated,106,/// A helper function that returns true if the given type is irregular. The; /// type is irregular if its allocated size doesn't equal the store size of an; /// element of the corresponding vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:285,Availability,avail,available,285,"/// A helper function that returns the reciprocal of the block probability of; /// predicated blocks. If we return X, we are assuming the predicated block; /// will execute once for every X iterations of the loop header.; ///; /// TODO: We should use actual block probability here, if available. Currently,; /// we always assume predicated blocks have a 50% chance of executing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Availability,avail,available,44,// Check if there is an expected trip count available from profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot use arbitrary shufflevectors (only splats), so; // must use intrinsics to interleave.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:468,Modifiability,variab,variables,468,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:863,Modifiability,variab,variables,863,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Performance,perform,performs,139,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:603,Performance,perform,perform,603,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:111,Availability,mask,masking,111,"/// Try to vectorize interleaved access group \p Group with the base address; /// given in \p Addr, optionally masking the vector operations if \p; /// BlockInMask is non-null. Use \p State to translate given VPValues to IR; /// values in the vectorized loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Security,access,access,33,"/// Try to vectorize interleaved access group \p Group with the base address; /// given in \p Addr, optionally masking the vector operations if \p; /// BlockInMask is non-null. Use \p State to translate given VPValues to IR; /// values in the vectorized loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Modifiability,variab,variable,44,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Usability,resume,resume,67,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:319,Usability,resume,resume,319,"/// Create a new phi node for the induction variable \p OrigPhi to resume; /// iteration count in the scalar epilogue, from where the vectorized loop; /// left off. \p Step is the SCEV-expanded induction step to use. In cases; /// where the loop skeleton is more complicated (i.e., epilogue vectorization); /// and the resume values can come from an additional bypass block, the \p; /// AdditionalBypass pair provides information about the bypass block and the; /// end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Deployability,update,update,82,/// Create the exit value of first order recurrences in the middle block and; /// update their users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Usability,resume,resume,56,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:249,Usability,resume,resume,249,"/// Create new phi nodes for the induction variables to resume iteration count; /// in the scalar epilogue, from where the vectorized loop left off.; /// In cases where the loop skeleton is more complicated (eg. epilogue; /// vectorization) and the resume values can come from an additional bypass; /// block, the \p AdditionalBypass pair provides information about the bypass; /// block and the end value on the edge from bypass to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:289,Performance,load,load,289,"/// Collect poison-generating recipes that may generate a poison value that is; /// used after vectorization, even when their operands are not poison. Those; /// recipes meet the following conditions:; /// * Contribute to the address computation of a recipe generating a widen; /// memory load/store (VPWidenMemoryInstructionRecipe or; /// VPInterleaveRecipe).; /// * Such a widen memory load/store has at least one underlying Instruction; /// that is in a basic block that needs predication and after vectorization; /// the generated instruction won't be predicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:388,Performance,load,load,388,"/// Collect poison-generating recipes that may generate a poison value that is; /// used after vectorization, even when their operands are not poison. Those; /// recipes meet the following conditions:; /// * Contribute to the address computation of a recipe generating a widen; /// memory load/store (VPWidenMemoryInstructionRecipe or; /// VPInterleaveRecipe).; /// * Such a widen memory load/store has at least one underlying Instruction; /// that is in a basic block that needs predication and after vectorization; /// the generated instruction won't be predicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:104,Usability,simpl,simplify,104,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Usability,usab,usable,163,/// A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies; /// dynamic knowledge to simplify SCEV expressions and converts them to a; /// more usable form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Performance,Cache,Cache,15,/// Assumption Cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Holds the end values for each induction variable. We save the end values; // so we can later fix-up the external users of the induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Modifiability,variab,variables,139,// Holds the end values for each induction variable. We save the end values; // so we can later fix-up the external users of the induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Performance,optimiz,optimizations,58,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Usability,guid,guided,46,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,optimiz,optimized,31,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:83,Performance,optimiz,optimizatios,83,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Usability,guid,guided,67,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:13,Usability,resume,resume,13,"// Holds the resume values for reductions in the loops, used to set the; // correct start value of reduction PHIs when vectorizing the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:117,Deployability,update,updated,117,/// Encapsulate information regarding vectorization of a loop and its epilogue.; /// This information is meant to be updated and used across two stages of; /// epilogue vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8,Integrability,interface,interface,8,"/// The interface for creating a vectorized skeleton using one of two; /// different strategies, each corresponding to one execution of the vplan; /// as described above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Deployability,update,updates,14,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:142,Safety,avoid,avoid,142,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:190,Safety,safe,safety,190,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,perform,performs,62,/// A specialized derived class of inner loop vectorizer that performs; /// vectorization of *main* loops in the process of vectorizing loops and their; /// epilogues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,interface,interface,19,/// Implements the interface for creating a vectorized skeleton using the; /// *main loop* strategy (ie the first pass of vplan execution).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:61,Performance,perform,performs,61,// A specialized derived class of inner loop vectorizer that performs; // vectorization of *epilogue* loops in the process of vectorizing loops and; // their epilogues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,interface,interface,19,/// Implements the interface for creating a vectorized skeleton using the; /// *epilogue loop* strategy (ie the second pass of vplan execution).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:100,Integrability,message,message,100,"/// Write a \p DebugMsg about vectorization to the debug output stream. If \p I; /// is passed, the message relates to that particular instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Performance,load,load,69,"// This recipe contributes to the address computation of a widen; // load/store. If the underlying instruction has poison-generating flags,; // drop them directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,Safety,predict,predict,232,/// LoopVectorizationCostModel - estimates the expected speedups due to; /// vectorization.; /// In many cases vectorization is not profitable. This can happen because of; /// a number of reasons. In this class we mainly attempt to predict the; /// expected speedup/slowdowns due to the supported instruction set. We use the; /// TargetTransformInfo to query the different backends for the cost of; /// different operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Performance,scalab,scalable,78,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:157,Safety,avoid,avoided,157,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:420,Availability,redundant,redundant,420,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:115,Integrability,depend,depends,115,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:182,Performance,Load,Load,182,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:414,Safety,avoid,avoid,414,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:420,Safety,redund,redundant,420,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Security,access,access,11,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:101,Availability,avail,available,101,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:143,Availability,mask,masking,143,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:270,Availability,avail,available,270,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:47,Integrability,depend,depending,47,"/// A call may be vectorized in different ways depending on whether we have; /// vectorized variants available and whether the target supports masking.; /// This function analyzes all calls in the function at the supplied VF,; /// makes a decision based on the costs of available options, and stores that; /// decision in a map for use in planning and plan execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Performance,concurren,concurrent,32,/// Holds the maximum number of concurrent live intervals in the loop.; /// The key is ClassID of target-provided register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,accesses,19,// For consecutive accesses with stride +1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,accesses,19,// For consecutive accesses with stride -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Modifiability,variab,variable,98,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:171,Modifiability,variab,variable,171,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Performance,optimiz,optimizable,42,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:155,Deployability,update,update,155,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:289,Deployability,update,update,289,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Modifiability,variab,variable,110,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:142,Modifiability,variab,variable,142,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:258,Modifiability,variab,variable,258,"// If the truncate is free for the given types, return false. Replacing a; // free truncate with an induction variable would add an induction variable; // update instruction to each iteration of the loop. We exclude from this; // check the primary induction variable since it will need an update; // instruction regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Modifiability,variab,variable,46,"// If the truncated value is not an induction variable, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,Integrability,depend,depend,73,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:322,Integrability,rout,routine,322,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,Performance,Load,Load,99,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,masked,48,/// Returns true if the target machine supports masked store operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:114,Security,access,access,114,/// Returns true if the target machine supports masked store operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,masked,48,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Performance,load,load,55,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Security,access,access,113,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:63,Availability,mask,masked,63,/// Returns true if the target machine can represent \p V as a masked gather; /// or scatter operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:74,Modifiability,variab,variables,74,/// Returns true if the target machine supports all of the reduction; /// variables found for the given VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Usability,simpl,simply,172,"/// Given costs for both strategies, return true if the scalar predication; /// lowering should be used for div/rem. This incorporates an override; /// option so it is not simply a cost comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,Availability,mask,masking,193,/// Returns true if \p I is an instruction which requires predication and; /// for which our chosen predication strategy is scalarization (i.e. we; /// don't have an alternate strategy such as masking available).; /// \p VF is the vectorization factor that will be used to vectorize \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:201,Availability,avail,available,201,/// Returns true if \p I is an instruction which requires predication and; /// for which our chosen predication strategy is scalarization (i.e. we; /// don't have an alternate strategy such as masking available).; /// \p VF is the vectorization factor that will be used to vectorize \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,avail,available,33,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:198,Performance,scalab,scalable,198,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:240,Safety,safe,safe-divisor,240,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Security,access,access,78,/// Returns true if \p I is a memory instruction with consecutive memory; /// access that can be widened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:137,Performance,load,loads,137,/// Returns true if \p I is a memory instruction in an interleaved-group; /// of memory accesses that can be vectorized with wide vector loads/stores; /// and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:88,Security,access,accesses,88,/// Returns true if \p I is a memory instruction in an interleaved-group; /// of memory accesses that can be vectorized with wide vector loads/stores; /// and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,Security,access,access,49,/// Check if \p Instr belongs to any interleaved access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Security,access,access,24,/// Get the interleaved access group that \p Instr belongs to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,Availability,mask,masked,46,/// Returns true if all loop blocks should be masked to fold tail loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:158,Energy Efficiency,power,power-of-,158,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Performance,scalab,scalable,81,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:190,Performance,scalab,scalable,190,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:255,Performance,scalab,scalable,255,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Safety,safe,safe,133,"/// \return the maximized element count based on the targets vector; /// registers and the loop trip-count, but limited to a maximum safe VF.; /// This is a helper function of computeFeasibleMaxVF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:30,Performance,scalab,scalable,30,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Safety,safe,safe,56,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Testability,log,logic,25,/// The cost-computation logic from getInstructionCost which provides; /// the vector type as an output parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Security,access,access,84,/// The cost computation for widening instruction \p I with consecutive; /// memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,Load,Load,29,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:85,Performance,Load,Load,85,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Performance,load,load,98,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Integrability,wrap,wrapper,84,/// Estimate the overhead of scalarizing an instruction. This is a; /// convenience wrapper for the type-based getScalarizationOverhead API.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:59,Availability,mask,masked,59,/// Returns true if an artificially high cost for emulated masked memrefs; /// should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Integrability,depend,dependence,163,"/// Records whether it is allowed to have the original scalar loop execute at; /// least once. This may be needed as a fallback loop in case runtime; /// aliasing/dependence checks fail, or to handle the tail/remainder; /// iterations when the trip count is unknown or doesn't divide by the VF,; /// or as a peel-loop to handle gaps in interleave-groups.; /// Under optsize and when the trip count is very small we don't allow any; /// iterations to execute in the scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,/// All blocks of loop are to be masked to fold tail of scalar iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:317,Security,access,accesses,317,"/// Collect the instructions that are uniform after vectorization. An; /// instruction is uniform if we represent it with a single scalar value in; /// the vectorized loop corresponding to each vector iteration. Examples of; /// uniform instructions include pointer operands of consecutive or; /// interleaved memory accesses. Note that although uniformity implies an; /// instruction will be scalar, the reverse is not true. In general, a; /// scalarized instruction will be represented by VF scalar values in the; /// vectorized loop, each corresponding to an iteration of the original; /// scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Performance,load,load,266,"/// Collect the instructions that are scalar after vectorization. An; /// instruction is scalar if it is known to be uniform or will be scalarized; /// during vectorization. collectLoopScalars should only add non-uniform nodes; /// to the list if they are used by a load/store instruction that is marked as; /// CM_Scalarize. Non-uniform scalarized instructions will be represented by; /// VF values in the vectorized loop, each corresponding to an iteration of; /// the original scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:262,Safety,safe,safe,262,"// Assume we can vectorize V (and hence we need extraction) if the; // scalars are not computed yet. This can happen, because it is called; // via getScalarizationOverhead from setCostBasedWideningDecision, before; // the scalars are collected. That should be a safe assumption in most; // cases, because we check if the operands have vectorizable types; // beforehand in LoopVectorizationLegality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Performance,cache,cache,15,/// Assumption cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Security,access,access,19,/// The interleave access information contains groups of interleaved accesses; /// with the same stride and close to each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Security,access,accesses,69,/// The interleave access information contains groups of interleaved accesses; /// with the same stride and close to each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:47,Deployability,update,update,47,"// Unhook the temporary block with the checks, update various places; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:220,Energy Efficiency,reduce,reduce,220,"// If the runtime memory checks are being created inside an outer loop; // we should find out if these checks are outer loop invariant. If so,; // the checks will likely be hoisted out and so the effective cost will; // reduce according to the outer loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:45,Energy Efficiency,reduce,reduce,45,// It seems reasonable to assume that we can reduce the effective; // cost of the checks even when we know nothing about the trip; // count. Assume that the outer loop executes at least twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Availability,avail,available,28,// Else use profile data if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,Integrability,depend,depending,151,"/// Adds the generated SCEVCheckBlock before \p LoopVectorPreHeader and; /// adjusts the branches to branch to the vector preheader or \p Bypass,; /// depending on the generated condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,Integrability,depend,depending,145,"/// Adds the generated MemCheckBlock before \p LoopVectorPreHeader and adjusts; /// the branches to branch to the vector preheader or \p Bypass, depending on; /// the generated condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Testability,test,testing,172,"// Collect inner loops and outer loops without irreducible control flow. For; // now, only collect outer loops that have explicit vectorization hints. If we; // are stress testing the VPlan H-CFG construction, we collect the outermost; // loop of every loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:244,Modifiability,inherit,inherited,244,// TODO: Collect inner loops inside marked outer loops in case; // vectorization fails for the outer loop. Do not invoke; // 'containsIrreducibleCFG' again for inner loops when the outer loop is; // already known to be reducible. We can use an inherited attribute for; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Usability,simpl,simplification,124,"// Note: the IR at this point is broken. We cannot use SE to create any new; // SCEV and then expand it, hoping that SCEV's simplification will give us; // a more optimal code. Unfortunately, attempt of doing so on invalid IR may; // lead to various SCEV crashes. So all we can do is to use builder and rely; // on InstCombine for future simplifications. Here we handle some trivial; // cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:338,Usability,simpl,simplifications,338,"// Note: the IR at this point is broken. We cannot use SE to create any new; // SCEV and then expand it, hoping that SCEV's simplification will give us; // a more optimal code. Unfortunately, attempt of doing so on invalid IR may; // lead to various SCEV crashes. So all we can do is to use builder and rely; // on InstCombine for future simplifications. Here we handle some trivial; // cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Modifiability,variab,variable,108,"/// For the given VF and UF and maximum trip count computed for the loop, return; /// whether the induction variable might overflow in the vectorized loop. If not,; /// then we know a runtime overflow check always evaluates to false and can be; /// removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:187,Modifiability,variab,variable,187,// We know the runtime overflow check is known false iff the (max) trip-count; // is known and (max) trip-count + (VF * UF) does not overflow in the type of; // the vector loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,"// Return whether we allow using masked interleave-groups (for dealing with; // strided loads/stores that reside in predicated blocks, or for dealing; // with gaps).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:88,Performance,load,loads,88,"// Return whether we allow using masked interleave-groups (for dealing with; // strided loads/stores that reside in predicated blocks, or for dealing; // with gaps).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Security,access,accesses,60,"// If an override option has been passed in for interleaved accesses, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:112,Performance,load,load,112,"// Try to vectorize the interleave group that \p Instr belongs to.; //; // E.g. Translate following interleaved load group (factor = 3):; // for (i = 0; i < N; i+=3) {; // R = Pic[i]; // Member of index 0; // G = Pic[i+1]; // Member of index 1; // B = Pic[i+2]; // Member of index 2; // ... // do something to R, G, B; // }; // To:; // %wide.vec = load <12 x i32> ; Read 4 tuples of R,G,B; // %R.vec = shuffle %wide.vec, poison, <0, 3, 6, 9> ; R elements; // %G.vec = shuffle %wide.vec, poison, <1, 4, 7, 10> ; G elements; // %B.vec = shuffle %wide.vec, poison, <2, 5, 8, 11> ; B elements; //; // Or translate following interleaved store group (factor = 3):; // for (i = 0; i < N; i+=3) {; // ... do something to R, G, B; // Pic[i] = R; // Member of index 0; // Pic[i+1] = G; // Member of index 1; // Pic[i+2] = B; // Member of index 2; // }; // To:; // %R_G.vec = shuffle %R.vec, %G.vec, <0, 1, 2, ..., 7>; // %B_U.vec = shuffle %B.vec, poison, <0, 1, 2, 3, u, u, u, u>; // %interleaved.vec = shuffle %R_G.vec, %B_U.vec,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11> ; Interleave R,G,B elements; // store <12 x i32> %interleaved.vec ; Write 4 tuples of R,G,B",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:348,Performance,load,load,348,"// Try to vectorize the interleave group that \p Instr belongs to.; //; // E.g. Translate following interleaved load group (factor = 3):; // for (i = 0; i < N; i+=3) {; // R = Pic[i]; // Member of index 0; // G = Pic[i+1]; // Member of index 1; // B = Pic[i+2]; // Member of index 2; // ... // do something to R, G, B; // }; // To:; // %wide.vec = load <12 x i32> ; Read 4 tuples of R,G,B; // %R.vec = shuffle %wide.vec, poison, <0, 3, 6, 9> ; R elements; // %G.vec = shuffle %wide.vec, poison, <1, 4, 7, 10> ; G elements; // %B.vec = shuffle %wide.vec, poison, <2, 5, 8, 11> ; B elements; //; // Or translate following interleaved store group (factor = 3):; // for (i = 0; i < N; i+=3) {; // ... do something to R, G, B; // Pic[i] = R; // Member of index 0; // Pic[i+1] = G; // Member of index 1; // Pic[i+2] = B; // Member of index 2; // }; // To:; // %R_G.vec = shuffle %R.vec, %G.vec, <0, 1, 2, ..., 7>; // %B_U.vec = shuffle %B.vec, poison, <0, 1, 2, 3, u, u, u, u>; // %interleaved.vec = shuffle %R_G.vec, %B_U.vec,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11> ; Interleave R,G,B elements; // store <12 x i32> %interleaved.vec ; Write 4 tuples of R,G,B",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:50,Performance,load,load,50,// Prepare for the vector type of the interleaved load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Availability,mask,masked,20,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:9,Modifiability,extend,extend,9,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:65,Security,access,access,65,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:265,Security,access,access,265,"// If the group is reverse, adjust the index to refer to the last vector lane; // instead of the first. We adjust the index from the first vector lane,; // rather than directly getting the pointer for lane VF - 1, because the; // pointer operand of the interleaved access is supposed to be uniform. For; // uniform instructions, we're only required to generate a value for the; // first vector lane in each unroll iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,load,load,29,// Vectorize the interleaved load group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:39,Performance,load,load,39,"// For each unroll part, create a wide load for the group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot use arbitrary shufflevectors (only splats),; // so must use intrinsics to deinterleave.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Performance,load,loads,84,"// For each member in the group, shuffle out the appropriate data from the; // wide loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:61,Performance,cache,cache,61,"// If we just cloned a new assumption, add it the assumption cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,masking,34,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:125,Availability,down,down,125,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:189,Availability,down,down,189,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:355,Energy Efficiency,power,power,355,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:524,Energy Efficiency,power,power,524,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:291,Integrability,wrap,wrap,291,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Modifiability,variab,variable,266,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:474,Performance,scalab,scalable,474,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Energy Efficiency,power,power-of-,31,"// vscale is not necessarily a power-of-2, which means we cannot guarantee; // an overflow to zero when updating induction variables and so an; // additional overflow check is required before entering the vector loop.; // Get the maximum unsigned value for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:123,Modifiability,variab,variables,123,"// vscale is not necessarily a power-of-2, which means we cannot guarantee; // an overflow to zero when updating induction variables and so an; // additional overflow check is required before entering the vector loop.; // Get the maximum unsigned value for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator for Bypass & LoopExit (if needed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator only if this is first RT check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:404,Deployability,update,update,404,"// Set up the middle block terminator. Two cases:; // 1) If we know that we must execute the scalar epilogue, emit an; // unconditional branch.; // 2) Otherwise, we must have a single unique exit block (due to how we; // implement the multiple exit case). In this case, set up a conditional; // branch from the middle block to the loop scalar preheader, and the; // exit block. completeLoopSkeleton will update the condition to use an; // iteration check, if required to decide whether to execute the remainder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,"// Update dominator for loop exit. During skeleton creation, only the vector; // pre-header and the middle block are created. The vector loop is entirely; // created during VPlan exection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:224,Integrability,depend,depend,224,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Modifiability,variab,variables,93,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Usability,resume,resume,19,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,cache,cached,29,// The trip counts should be cached by now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:386,Performance,Perform,Perform,386,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:188,Safety,avoid,avoid,188,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:338,Usability,simpl,simplify,338,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:394,Usability,simpl,simplification,394,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Modifiability,variab,variable,42,"// Fix up external users of the induction variable. At this point, we are; // in LCSSA form, with all external PHIs that use the IV having one input value,; // coming from the remainder loop. We need those PHIs to also have a correct; // value for the IV when arriving directly from the middle block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Usability,simpl,simplest,82,"// An external user of the penultimate value need to see EndValue - Step.; // The simplest way to get this is to recompute it from the constituent SCEVs,; // that is Start + (Step * (CRD - 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:174,Safety,avoid,avoid,174,"// One corner case we have to handle is two IVs ""chasing"" each-other,; // that is %IV2 = phi [...], [ %IV1, %latch ]; // In this case, if IV1 has an external use, we need to avoid adding both; // ""last value of IV1"" and ""penultimate value of IV2"". So, verify that we; // don't already have an incoming value for the middle block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Modifiability,variab,variable,56,// end anonymous namespace; ///Perform cse of induction variable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,Perform,Perform,31,// end anonymous namespace; ///Perform cse of induction variable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Perform,Perform,3,// Perform simple cse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Usability,simpl,simple,11,// Perform simple cse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:176,Deployability,update,update,176,"// TODO: Check VPLiveOuts to see if IV users need fixing instead of checking; // the cost model.; // If we inserted an edge from the middle block to the unique exit block,; // update uses outside the loop (phis) to account for the newly inserted; // edge.; // Fix-up external users of the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Modifiability,variab,variables,299,"// TODO: Check VPLiveOuts to see if IV users need fixing instead of checking; // the cost model.; // If we inserted an edge from the middle block to the unique exit block,; // update uses outside the loop (phis) to account for the newly inserted; // edge.; // Fix-up external users of the induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:105,Deployability,update,update,105,"// Fix LCSSA phis not already fixed earlier. Extracts may need to be generated; // in the exit block, so update the builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Availability,redundant,redundant,10,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Safety,redund,redundant,10,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Deployability,update,update,7,"// Set/update profile weights for the vector and remainder loops as original; // loop iterations are now distributed among them. Note that original loop; // represented by LoopScalarBody becomes remainder loop after vectorization.; //; // For cases like foldTailByMasking() and requiresScalarEpiloque() we may; // end up getting slightly roughened result but that should be OK since; // profile is not inherently precise anyway. Note also possible bypass of; // vector code caused by legality checks is ignored, assigning all the weight; // to the vector loop, optimistically.; //; // For scalable vectorization we can't know at compile time how many iterations; // of the loop are handled in one vector iteration, so instead assume a pessimistic; // vscale of '1'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:589,Performance,scalab,scalable,589,"// Set/update profile weights for the vector and remainder loops as original; // loop iterations are now distributed among them. Note that original loop; // represented by LoopScalarBody becomes remainder loop after vectorization.; //; // For cases like foldTailByMasking() and requiresScalarEpiloque() we may; // end up getting slightly roughened result but that should be OK since; // profile is not inherently precise anyway. Note also possible bypass of; // vector code caused by legality checks is ignored, assigning all the weight; // to the vector loop, optimistically.; //; // For scalable vectorization we can't know at compile time how many iterations; // of the loop are handled in one vector iteration, so instead assume a pessimistic; // vscale of '1'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:638,Integrability,depend,depends,638,"// This is the second phase of vectorizing first-order recurrences. An; // overview of the transformation is described below. Suppose we have the; // following loop.; //; // for (int i = 0; i < n; ++i); // b[i] = a[i] - a[i - 1];; //; // There is a first-order recurrence on ""a"". For this loop, the shorthand; // scalar IR looks like:; //; // scalar.ph:; // s_init = a[-1]; // br scalar.body; //; // scalar.body:; // i = phi [0, scalar.ph], [i+1, scalar.body]; // s1 = phi [s_init, scalar.ph], [s2, scalar.body]; // s2 = a[i]; // b[i] = s2 - s1; // br cond, scalar.body, ...; //; // In this example, s1 is a recurrence because it's value depends on the; // previous iteration. In the first phase of vectorization, we created a; // vector phi v1 for s1. We now complete the vectorization and produce the; // shorthand vector IR shown below (for VF = 4, UF = 1).; //; // vector.ph:; // v_init = vector(..., ..., ..., a[-1]); // br vector.body; //; // vector.body; // i = phi [0, vector.ph], [i+4, vector.body]; // v1 = phi [v_init, vector.ph], [v2, vector.body]; // v2 = a[i, i+1, i+2, i+3];; // v3 = vector(v1(3), v2(0, 1, 2)); // b[i, i+1, i+2, i+3] = v2 - v3; // br cond, vector.body, middle.block; //; // middle.block:; // x = v2(3); // br scalar.ph; //; // scalar.ph:; // s_init = phi [x, middle.block], [a[-1], otherwise]; // br scalar.body; //; // After execution completes the vector loop, we extract the next value of; // the recurrence (x) to use as the initial value in the scalar loop.; // Extract the last vector element in the middle block. This will be the; // initial value for the recurrence when jumping to the scalar loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:168,Deployability,update,update,168,"// Extract the second last element in the middle block if the; // Phi is used outside the loop. We need to extract the phi itself; // and not the last element (the phi update in the current iteration). This; // will be the value when jumping to the exit block from the; // LoopMiddleBlock, when the scalar loop is not run at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:185,Performance,load,load,185,"// We can't sink an instruction if it is a phi node, is not in the loop,; // may have side effects or may read from memory.; // TODO Could dor more granular checking to allow sinking a load past non-store instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:184,Performance,scalab,scalable,184,"// This avoids any chances of creating a REPLICATE recipe during planning; // since that would result in generation of scalarized code during execution,; // which is not supported for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8,Safety,avoid,avoids,8,"// This avoids any chances of creating a REPLICATE recipe during planning; // since that would result in generation of scalarized code during execution,; // which is not supported for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:77,Security,access,accesses,77,// These sets are used to seed the analysis with pointers used by memory; // accesses that will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:105,Performance,load,loads,105,// A helper that returns true if the use of Ptr by MemAccess will be scalar.; // The pointer operands of loads and stores will be scalar as long as the; // memory access is not a gather or scatter operation. The value operand of a; // store will remain scalar if the store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Security,access,access,163,// A helper that returns true if the use of Ptr by MemAccess will be scalar.; // The pointer operands of loads and stores will be scalar as long as the; // memory access is not a gather or scatter operation. The value operand of a; // store will remain scalar if the store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:36,Security,access,access,36,"// A helper that evaluates a memory access's use of a pointer. If the use will; // be a scalar use and the pointer is only used by memory accesses, we place; // the pointer in ScalarPtrs. Otherwise, the pointer is placed in; // PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:138,Security,access,accesses,138,"// A helper that evaluates a memory access's use of a pointer. If the use will; // be a scalar use and the pointer is only used by memory accesses, we place; // the pointer in ScalarPtrs. Otherwise, the pointer is placed in; // PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:95,Security,access,accesses,95,"// If the use of the pointer will be a scalar use, and all users of the; // pointer are memory accesses, place the pointer in ScalarPtrs. Otherwise,; // place the pointer in PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Security,access,accesses,205,"// We seed the scalars analysis with three classes of instructions: (1); // instructions marked uniform-after-vectorization and (2) bitcast,; // getelementptr and (pointer) phi instructions used by memory accesses; // requiring a scalar use.; //; // (1) Add to the worklist all instructions that have been identified as; // uniform-after-vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:146,Performance,load,loads,146,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Security,access,accesses,89,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:204,Security,access,accesses,204,// (2) Add to the worklist all bitcast and getelementptr instructions used by; // memory accesses requiring a scalar use. The pointer operands of loads and; // stores will be scalar as long as the memory accesses is not a gather or; // scatter operation. The value operand of a store will remain scalar if the; // store is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:112,Modifiability,variab,variable,112,// Insert the forced scalars.; // FIXME: Currently VPWidenPHIRecipe() often creates a dead vector; // induction variable when the PHI user is scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Deployability,update,update,110,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Modifiability,variab,variable,16,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Modifiability,variab,variable,78,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:101,Modifiability,variab,variable,101,// An induction variable will remain scalar if all users of the induction; // variable and induction variable update remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Modifiability,variab,variable,53,"// If tail-folding is applied, the primary induction variable will be used; // to feed a vector compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Performance,load,load,81,// Returns true if \p Indvar is a pointer induction that is used directly by; // load/store instruction \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable are scalar after; // vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:52,Deployability,update,update,52,// Determine if all users of the induction variable update instruction are; // scalar after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable update instruction are; // scalar after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Deployability,update,update,34,// The induction variable and its update instruction will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Modifiability,variab,variable,17,// The induction variable and its update instruction will remain scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:147,Performance,scalab,scalable,147,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Safety,safe,safe-divisor,33,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Safety,avoid,avoid,55,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:126,Safety,safe,safe-divisor,126,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:36,Safety,safe,safe,36,"// Can we prove this instruction is safe to unconditionally execute?; // If not, we must use some form of predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Performance,load,load,20,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:501,Performance,load,loads,501,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:453,Safety,safe,safety,453,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Performance,scalab,scalable,33,// Scalarization isn't legal for scalable vector types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,allocate,allocated,24,"// If the instruction's allocated size doesn't equal it's type size, it; // requires padding and will be scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:12,Availability,mask,masking,12,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:54,Availability,mask,masking,54,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:161,Availability,mask,masking,161,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Performance,load,load-access,221,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:270,Performance,load,load,270,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:226,Security,access,access,226,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Security,access,access,299,"// Check if masking is required.; // A Group may need masking for one of two reasons: it resides in a block that; // needs predication, or it was decided to use masking to deal with gaps; // (either a gap at the end of a load-access that may result in a speculative; // load, or any gaps in a store-access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Availability,mask,masked,6,"// If masked interleaving is required, we expect that the user/target had; // enabled it, because otherwise it either wouldn't have been created or; // it should have been invalidated by the CostModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,allocate,allocated,24,"// If the instruction's allocated size doesn't equal it's type size, it; // requires padding and will be scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:297,Performance,optimiz,optimize,297,"// Add uniform instructions demanding lane 0 to the worklist. Instructions; // that are scalar with predication must not be considered uniform after; // vectorization, because that would create an erroneous replicating region; // where only a single instance out of VF should be formed.; // TODO: optimize such seldom cases if found important, see PR40816.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Performance,perform,perform,28,"// Return true if all lanes perform the same memory operation, and we can; // thus chose to execute only one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Load,Loading,3,// Loading the same address always produces the same result - at least; // assuming aliasing and ordering which have already been checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Security,access,access,58,"// Returns true if Ptr is the pointer operand of a memory access instruction; // I, I is known to not require scalarization, and the pointer is not also; // stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:355,Deployability,update,update,355,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,Integrability,depend,dependence,193,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:260,Modifiability,variab,variable,260,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:323,Modifiability,variab,variable,323,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:346,Modifiability,variab,variable,346,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:444,Modifiability,variab,variables,444,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable are uniform after; // vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:52,Deployability,update,update,52,// Determine if all users of the induction variable update instruction are; // uniform after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variable,43,// Determine if all users of the induction variable update instruction are; // uniform after vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Deployability,update,update,34,// The induction variable and its update instruction will remain uniform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Modifiability,variab,variable,17,// The induction variable and its update instruction will remain uniform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid specializing for stride==1 instead of bailing out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Performance,scalab,scalable,98,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:334,Performance,scalab,scalable,334,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Testability,Test,Test,3,"// Test that the loop-vectorizer can legalize all operations for this MaxVF.; // FIXME: While for scalable vectors this is currently sufficient, this should; // be replaced by a more detailed mechanism that filters out specific VFs,; // instead of invalidating vectorization for a whole set of VFs based on the; // MaxVF.; // Disable scalable vectorization if the loop contains unsupported reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Performance,scalab,scalable,11,// Disable scalable vectorization if the loop contains any instructions; // with element types not supported for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Performance,scalab,scalable,113,// Disable scalable vectorization if the loop contains any instructions; // with element types not supported for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Integrability,depend,dependence,43,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:38,Safety,safe,safe,38,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Integrability,depend,dependence,24,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Integrability,depend,dependence,221,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Safety,safe,safe,19,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:157,Security,access,accesses,157,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Safety,safe,safe,25,"// If `VF=vscale x N` is safe, then so is `VF=N`",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:35,Performance,scalab,scalable,35,"// Only clamp if the UserVF is not scalable. If the UserVF is scalable, it; // is better to ignore the hint and let the compiler choose a suitable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,scalab,scalable,62,"// Only clamp if the UserVF is not scalable. If the UserVF is scalable, it; // is better to ignore the hint and let the compiler choose a suitable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:244,Availability,mask,mask,244,"// The only loops we can vectorize without a scalar epilogue, are loops with; // a bottom-test and a single exiting block. We'd have to handle the fact; // that not every instruction executes on the last iteration. This will; // require a lane mask which varies through the vector loop body. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:90,Testability,test,test,90,"// The only loops we can vectorize without a scalar epilogue, are loops with; // a bottom-test and a single exiting block. We'd have to handle the fact; // that not every instruction executes on the last iteration. This will; // require a lane mask which varies through the vector loop body. (TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Availability,mask,masking,78,"// If there was a tail-folding hint/switch, but we can't fold the tail by; // masking, fallback to a vectorization with a scalar epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,Availability,mask,mask,98,// Now try the tail folding; // Invalidate interleave groups that require an epilogue if we can't mask; // the interleave-group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Avoid,Avoid,3,// Avoid tail folding if the trip count is known to be a multiple of any VF; // we choose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Availability,mask,masking,156,"// If we don't know the precise trip count, or if the trip count that we; // found modulo the vectorization factor is not zero, try to fold the tail; // by masking.; // FIXME: look for a smaller MaxVF that does divide TC rather than masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:233,Availability,mask,masking,233,"// If we don't know the precise trip count, or if the trip count that we; // found modulo the vectorization factor is not zero, try to fold the tail; // by masking.; // FIXME: look for a smaller MaxVF that does divide TC rather than masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Availability,mask,masking,78,"// If there was a tail-folding hint/switch, but we can't fold the tail by; // masking, fallback to a vectorization with a scalar epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,Energy Efficiency,power,power,21,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:137,Energy Efficiency,power,powers,137,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Integrability,depend,dependence,37,// Ensure MaxVF is a power of 2; the dependence distance bound may not be.; // Note that both WidestRegister and WidestType may not be a powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,Safety,avoid,avoid,136,"// When a scalar epilogue is required, at least one iteration of the scalar; // loop has to execute. Adjust MaxTripCount accordingly to avoid picking a; // max VF that results in a dead vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:165,Energy Efficiency,power,power,165,"// If upper bound loop trip count (TC) is known at compile time there is no; // point in choosing VF greater than TC (as done in the loop below). Select; // maximum power of two which doesn't exceed TC. If MaxVectorElementCount is; // scalable, we only fall back on a fixed VF when the TC is less than or; // equal to the known number of lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:235,Performance,scalab,scalable,235,"// If upper bound loop trip count (TC) is known at compile time there is no; // point in choosing VF greater than TC (as done in the loop below). Select; // maximum power of two which doesn't exceed TC. If MaxVectorElementCount is; // scalable, we only fall back on a fixed VF when the TC is less than or; // equal to the known number of lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:149,Performance,load,load,149,"// Invalidate any widening decisions we might have made, in case the loop; // requires prediction (decided later), but we have already made some; // load/store widening decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,Safety,predict,prediction,87,"// Invalidate any widening decisions we might have made, in case the loop; // requires prediction (decided later), but we have already made some; // load/store widening decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:50,Performance,scalab,scalable,50,// Improve estimate for the vector width if it is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Performance,tune,tuned,58,"// Assume vscale may be larger than 1 (or the value being tuned for),; // so that scalable vectorization is slightly favorable over fixed-width; // vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Performance,scalab,scalable,82,"// Assume vscale may be larger than 1 (or the value being tuned for),; // so that scalable vectorization is slightly favorable over fixed-width; // vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Safety,avoid,avoid,6,// To avoid the need for FP division:; // (CostA / A.Width) < (CostB / B.Width); // <=> (CostA * B.Width) < (CostB * A.Width),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Performance,load,load,53,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:66,Performance,load,load,66,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:162,Performance,load,load,162,"// For a list of ordered instruction-vf pairs:; // [(load, vf1), (load, vf2), (store, vf1)]; // Group the instructions together to emit separate remarks for:; // load (vf1, vf2); // store (vf1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:127,Performance,load,load,127,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:140,Performance,load,load,140,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:197,Performance,load,load,197,"// If the next instruction is different, or if there are no other pairs,; // emit a remark for the collated subset. e.g.; // [(load, vf1), (load, vf2))]; // to emit:; // remark: invalid costs for 'load' at VF=(vf, vf2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Security,audit,auditted,44,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Security,audit,auditted,133,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:150,Testability,test,tested,150,"// Epilogue vectorization code has not been auditted to ensure it handles; // non-latch exits properly. It may be fine, but it needs auditted and; // tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Testability,log,logic,93,"// Not really a cost consideration, but check for unsupported cases here to; // simplify the logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:80,Usability,simpl,simplify,80,"// Not really a cost consideration, but check for unsupported cases here to; // simplify the logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,Performance,scalab,scalable,62,// Skip candidate VFs with widths >= the estimate runtime VF (scalable; // vectors) or the VF of the main loop (fixed vectors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:9,Modifiability,extend,extend,9,// TODO: extend to support scalable VFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,scalab,scalable,27,// TODO: extend to support scalable VFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:168,Modifiability,variab,variables,168,"// For in-loop reductions, no element types are added to ElementTypesInLoop; // if there are no loads/stores in the loop. In this case, check through the; // reduction variables to determine the maximum width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:96,Performance,load,loads,96,"// For in-loop reductions, no element types are added to ElementTypesInLoop; // if there are no loads/stores in the loop. In this case, check through the; // reduction variables to determine the maximum width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Performance,Load,Loads,16,"// Only examine Loads, Stores and PHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:51,Deployability,Update,Update,51,// Examine PHI nodes that are reduction variables. Update the type to; // account for the recurrence type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Modifiability,variab,variables,40,// Examine PHI nodes that are reduction variables. Update the type to; // account for the recurrence type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Energy Efficiency,reduce,reduce,89,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:568,Energy Efficiency,reduce,reduce,568,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:498,Integrability,depend,dependency,498,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:183,Safety,predict,predict,183,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:74,Security,expose,expose,74,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:322,Integrability,depend,dependences,322,"// Do not interleave loops with a relatively small known or estimated trip; // count. But we will interleave when InterleaveSmallLoopScalarReduction is; // enabled, and the code has scalar reductions(HasReductions && VF = 1),; // because with the above conditions interleaving can expose ILP and break; // cross iteration dependences for reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:281,Security,expose,expose,281,"// Do not interleave loops with a relatively small known or estimated trip; // count. But we will interleave when InterleaveSmallLoopScalarReduction is; // enabled, and the code has scalar reductions(HasReductions && VF = 1),; // because with the above conditions interleaving can expose ILP and break; // cross iteration dependences for reductions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:128,Availability,avail,available,128,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:421,Availability,down,down,421,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:721,Availability,mask,masking,721,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:451,Energy Efficiency,power,power,451,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:473,Energy Efficiency,power,power,473,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:591,Energy Efficiency,power,power,591,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:683,Integrability,wrap,wraps,683,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:655,Modifiability,variab,variable,655,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:506,Usability,simpl,simplify,506,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Modifiability,variab,variable,29,// Don't count the induction variable as interleaved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,Energy Efficiency,reduce,reduce,49,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:94,Security,expose,expose,94,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Performance,load,load,26,// Interleave until store/load ports (estimated by max interleave count) are; // saturated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Security,expose,expose,120,"// If there are scalar reductions and TTI has enabled aggressive; // interleaving for reductions, we will interleave to expose ILP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,Availability,alive,alive,102,"// This function calculates the register usage by measuring the highest number; // of values that are alive at a single location. Obviously, this is a very; // rough estimation. We scan the loop in a topological order in order and; // assign a number to each instruction. We use RPO to ensure that defs are; // met before their users. We assume that each instruction that has in-loop; // users starts an interval. We record every time that an in-loop value is; // used, so we have a list of the first and last occurrences of each; // instruction. Next, we transpose this data structure into a multi map that; // holds the list of intervals that *end* at a specific location. This multi; // map allows us to perform a linear search. We scan the instructions linearly; // and record each time that a new interval starts, by placing it in a set.; // If we find this value in the multi-map then we remove it from the set.; // The max register usage is the maximum size of the set.; // We also search for instructions that are defined outside the loop, but are; // used inside the loop. We need this number separately from the max-interval; // usage number because when we unroll, loop-invariant values do not take; // more register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:707,Performance,perform,perform,707,"// This function calculates the register usage by measuring the highest number; // of values that are alive at a single location. Obviously, this is a very; // rough estimation. We scan the loop in a topological order in order and; // assign a number to each instruction. We use RPO to ensure that defs are; // met before their users. We assume that each instruction that has in-loop; // users starts an interval. We record every time that an in-loop value is; // used, so we have a list of the first and last occurrences of each; // instruction. Next, we transpose this data structure into a multi map that; // holds the list of intervals that *end* at a specific location. This multi; // map allows us to perform a linear search. We scan the instructions linearly; // and record each time that a new interval starts, by placing it in a set.; // If we find this value in the multi-map then we remove it from the set.; // The max register usage is the maximum size of the set.; // We also search for instructions that are defined outside the loop, but are; // used inside the loop. We need this number separately from the max-interval; // usage number because when we unroll, loop-invariant values do not take; // more register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,Availability,mask,masked,33,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:364,Availability,mask,masked,364,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:422,Availability,Mask,Masked,422,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:503,Availability,Mask,Masked,503,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:241,Deployability,deploy,deployed,241,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Performance,load,load,40,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:371,Performance,load,load,371,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:429,Performance,Load,Load,429,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:315,Safety,avoid,avoid,315,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,Usability,guid,guides,87,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:340,Usability,simpl,simply,340,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:172,Availability,mask,masked,172,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:28,Performance,scalab,scalable,28,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Testability,log,logic,124,"// Do not apply discount if scalable, because that would lead to; // invalid scalarization costs.; // Do not apply discount logic if hacked cost is needed; // for emulated masked memrefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:249,Safety,avoid,avoid,249,"// We only attempt to scalarize instructions forming a single-use chain; // from the original predicated block that would otherwise be vectorized.; // Although not strictly necessary, we give up on instructions we know will; // already be scalar to avoid traversing chains that are unlikely to be; // beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:149,Availability,mask,masked,149,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Performance,load,load,156,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:605,Testability,assert,asserting,605,"// If any of the instruction's operands are uniform after vectorization,; // the instruction cannot be scalarized. This prevents, for example, a; // masked load from being scalarized.; //; // We assume we will only emit a value for lane zero of an instruction; // marked uniform after vectorization, rather than VF identical values.; // Thus, if we scalarize an instruction that uses a uniform, we would; // create uses of values corresponding to the lanes we aren't emitting code; // for. This behavior can be changed by allowing getScalarValue to clone; // the lane zero values for uniforms rather than asserting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:122,Integrability,depend,dependence,122,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:113,Modifiability,variab,variable,113,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Security,Access,Access,17,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:54,Security,access,access,54,/// Gets Address Access SCEV after verifying that the access pattern; /// is loop invariant except the induction variable dependence.; ///; /// This SCEV can be sent to the Target in order to estimate the address; /// calculation cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Modifiability,variab,variable,108,// We are looking for a gep with all loop invariant indices except for one; // which should be an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,Security,access,access,151,// NOTE: PtrTy is a vector to signal `TTI::getAddressComputationCost`; // that it is being called from this specific place.; // Figure out whether the access is strided and get the stride value; // if it's known in compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,load,load,27,"// If we have a predicated load/store, it will need extra i1 extracts and; // conditional branches, but may not be executed for each vector lane. Scale; // the cost by the probability of executing the predicated block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,masked,34,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Security,access,access,53,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:209,Availability,down,down,209,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,Energy Efficiency,reduce,reduce,81,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Energy Efficiency,reduce,reduce,116,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:141,Energy Efficiency,reduce,reduce,141,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Energy Efficiency,reduce,reduce,163,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:363,Testability,test,test,363,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Testability,Test,Test,3,"// Test if the found instruction is a reduction, and if not return an invalid; // cost specifying the parent to use the original cost modelling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,"// Matched reduce.add(ext(mul(ext(A), ext(B))); // Note that the extend opcodes need to all match, or if A==B they will have; // been converted to zext(mul(sext(A), sext(A))) as it is known positive,; // which is equally fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:65,Modifiability,extend,extend,65,"// Matched reduce.add(ext(mul(ext(A), ext(B))); // Note that the extend opcodes need to all match, or if A==B they will have; // been converted to zext(mul(sext(A), sext(A))) as it is known positive,; // which is equally fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,// Matched reduce(ext(A)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:132,Energy Efficiency,reduce,reduce,132,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:187,Energy Efficiency,reduce,reduce,187,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Energy Efficiency,reduce,reduce,11,// Matched reduce.add(mul()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:238,Deployability,update,update,238,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Performance,scalab,scalable,69,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:186,Performance,scalab,scalable,186,"// <vscale x 1 x iN> is assumed to be profitable over iN because; // scalable registers are a distinct register class from scalar ones.; // If we ever find a target which wants to lower scalable vectors; // back to scalars, we'll need to update this code to explicitly; // ask TTI about the register class uses for each part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Performance,scalab,scalable,41,"// There is no mechanism yet to create a scalable scalarization loop,; // so this is currently Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Energy Efficiency,efficient,efficient,24,// Some targets support efficient element stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Deployability,update,update,44,// TODO: We should generate better code and update the cost model for; // predicated uniform stores. Today they are treated as any other; // predicated store (see added test cases in; // invariant-store-vectorization.ll).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:169,Testability,test,test,169,// TODO: We should generate better code and update the cost model for; // predicated uniform stores. Today they are treated as any other; // predicated store (see added test cases in; // invariant-store-vectorization.ll).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,Integrability,depend,depends,232,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Performance,load,loads,55,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:220,Testability,log,logic,220,"// We have dedicated lowering for unpredicated uniform loads and; // stores. Note that even with tail folding we know that at least; // one lane is active (i.e. generalized predication is not possible; // here), and the logic below depends on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors, a uniform memop load is always; // uniform-by-parts and we know how to scalarize that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Performance,load,load,41,"// For scalable vectors, a uniform memop load is always; // uniform-by-parts and we know how to scalarize that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Load,Load,3,// Load: Scalar load + broadcast; // Store: Scalar store + isLoopInvariantStoreValue ? 0 : extract; // FIXME: This cost is a significant under-estimate for tail folded; // memory ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:16,Performance,load,load,16,// Load: Scalar load + broadcast; // Store: Scalar store + isLoopInvariantStoreValue ? 0 : extract; // FIXME: This cost is a significant under-estimate for tail folded; // memory ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:167,Availability,failure,failure,167,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:134,Performance,scalab,scalable,134,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:195,Safety,abort,abort,195,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,Availability,down,down,56,"// Choose better solution for the current VF,; // write down this decision and use it during vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Performance,load,load,22,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,Performance,optimiz,optimize,266,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,Safety,avoid,avoids,136,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:152,Performance,load,loaded,152,"// Setting the desired widening decision should ideally be handled in; // by cost functions, but since this involves the task of finding out; // if the loaded register is involved in an address computation, it is; // instead changed here when we know this is the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,load,load,23,// Scalarize a widened load of address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Performance,load,loads,44,// Scalarize an interleave group of address loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Availability,avail,available,22,// Search through any available variants for one we can use at this VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Availability,mask,mask,15,// Must take a mask argument if one is required,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Availability,mask,mask,37,// Add in the cost of synthesizing a mask if one wasn't required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,Performance,perform,perform,78,// Find the cost of an intrinsic; some targets may have instructions that; // perform the operation without needing an actual call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Integrability,depend,depends,89,"// We mark this instruction as zero-cost because the cost of GEPs in; // vectorized code depends on whether the corresponding memory instruction; // is scalarized or not. Therefore, we handle GEPs with the memory; // instruction cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Performance,scalab,scalable,29,// Not possible to scalarize scalable vector with predicated instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Safety,safe,safe,26,"// We've proven all lanes safe to speculate, fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Detect,Detect,3,// Detect reduction patterns,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:39,Performance,Load,Load,39,// Computes the CastContextHint from a Load/Store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:59,Performance,Load,LoadInst,59,"// For Z/Sext, the context is the operand, which must be a LoadInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,// We optimize the truncation of induction variables having constant; // integer steps. The cost of these truncations is the same as the scalar; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,Performance,optimiz,optimize,6,// We optimize the truncation of induction variables having constant; // integer steps. The cost of these truncations is the same as the scalar; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Safety,Detect,Detect,3,// Detect reduction patterns,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:38,Performance,scalab,scalable,38,"// We cannot easily widen alloca to a scalable alloca, as; // the result would need to be a vector of pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,Modifiability,variab,variables,32,// Find all stores to invariant variables. Since they are going to sink; // outside the loop we do not need calculate cost for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,Safety,detect,detection,73,// Ignore type-promoting instructions we identified during reduction; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:71,Safety,detect,detection,71,// Ignore type-casting instructions we identified during induction; // detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,Performance,scalab,scalable,31,"// This function will select a scalable VF if the target supports scalable; // vectors and a fixed one otherwise.; // TODO: we could return a pair of values that specify the max VF and; // min VF, to be used in `buildVPlans(MinVF, MaxVF)` instead of; // `buildVPlans(VF, VF)`. We cannot do it because VPLAN at the moment; // doesn't have a cost model that can choose which plan to execute if; // more than one is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:66,Performance,scalab,scalable,66,"// This function will select a scalable VF if the target supports scalable; // vectors and a fixed one otherwise.; // TODO: we could return a pair of values that specify the max VF and; // min VF, to be used in `buildVPlans(MinVF, MaxVF)` instead of; // `buildVPlans(VF, VF)`. We cannot do it because VPLAN at the moment; // doesn't have a cost model that can choose which plan to execute if; // more than one is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:247,Deployability,pipeline,pipeline,247,"// Outer loop handling: They may require CFG and instruction level; // transformations before even evaluating whether vectorization is profitable.; // Since we cannot modify the incoming IR, we need to build VPlan upfront in; // the vectorization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:41,Testability,test,testing,41,// Make sure we have a VF > 1 for stress testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Testability,test,testing,26,"// For VPlan build stress testing, we bail out after VPlan construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:90,Modifiability,variab,variable,90,// TODO: This fixup should instead be modeled in VPlan.; // Fix the scalar loop reduction variable with the incoming reduction sum; // from the vector body and from the backedge value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Perform,Perform,3,// Perform the actual loop transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Integrability,depend,dependent,20,"// 0. Generate SCEV-dependent code into the preheader, including TripCount,; // before making any changes to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,Performance,optimiz,optimization,79,//===------------------------------------------------===//; //; // Notice: any optimization or new instruction that go; // into the code below should also be implemented in; // the cost-model.; //; //===------------------------------------------------===//; // 2. Copy and widen instructions from the old loop into the new loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Usability,resume,resume,25,// 2.5 Collect reduction resume values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:349,Deployability,update,updated,349,"// Generate the iteration count check for the main loop, *after* the check; // for the epilogue loop, so that the path-length is shorter for the case; // that goes directly through the vector epilogue. The longer-path length for; // the main loop is compensated for, by the gain from vectorizing the larger; // trip count. Note: the branch will get updated later on when we vectorize; // the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,Modifiability,variab,variable,26,// Generate the induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:18,Usability,resume,resume,18,// Skip induction resume value creation here because they will be created in; // the second pass for the scalar loop. The induction resume values for the; // inductions in the epilogue loop are created before executing the plan for; // the epilogue loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:132,Usability,resume,resume,132,// Skip induction resume value creation here because they will be created in; // the second pass for the scalar loop. The induction resume values for the; // inductions in the epilogue loop are created before executing the plan for; // the epilogue loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Deployability,Update,Update,3,// Update dominator for Bypass & LoopExit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:138,Deployability,update,update,138,"// For loops with multiple exits, there's no edge from the middle block; // to exit blocks (as the epilogue must run) and thus no need to update; // the immediate dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,Safety,safe,safe,99,// Save the trip count so we don't have to regenerate it in the; // vec.epilog.iter.check. This is safe to do because the trip count; // generated here dominates the vector epilog iter check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,Deployability,update,update,120,"// If there is an epilogue which must run, there's no edge from the; // middle block to exit blocks and thus no need to update the immediate; // dominator of the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Deployability,Update,Update,163,// The vec.epilog.iter.check block may contain Phi nodes from inductions or; // reductions which merge control-flow from the latch block and the middle; // block. Update the incoming values here and move the Phi into the preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Usability,resume,resume,14,// Generate a resume induction for the vector epilogue and put it in the; // vector epilogue preheader,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Modifiability,variab,variables,43,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:336,Modifiability,variab,variable,336,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:125,Testability,test,test,125,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Usability,resume,resume,22,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:305,Usability,resume,resume,305,"// Generate induction resume values. These variables save the new starting; // indexes for the scalar loop. They are used to test if there are any tail; // iterations left once the vector loop has completed.; // Note that when the vectorized epilogue is skipped due to iteration count; // check, then the resume value for the induction variable comes from; // the trip count of the main vector loop, hence passing the AdditionalBypass; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:201,Modifiability,extend,extending,201,"/// Build VPlans for the full range of feasible VF's = {\p MinVF, 2 * \p MinVF,; /// 4 * \p MinVF, ..., \p MaxVF} by repeatedly building a VPlan for a sub-range; /// of VF's starting at a given VF and extending it as much as possible. Each; /// vectorization decision can potentially shorten this sub-range during; /// buildVPlan().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:12,Performance,cache,cached,12,// Look for cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,Availability,mask,mask,139,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,Safety,Avoid,Avoid,145,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,Availability,mask,mask,22,"// Otherwise block in-mask is all-one, no need to AND.; // The condition is 'SrcMask && EdgeMask', which is equivalent to; // 'select i1 SrcMask, i1 EdgeMask, i1 false'.; // The select version does not introduce new UB if SrcMask is false and; // EdgeMask is poison. Using 'and' here introduces undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Availability,mask,mask,60,"// When not folding the tail, use nullptr to model all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,Availability,mask,mask,67,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,Integrability,wrap,wrap,124,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:14,Performance,cache,cached,14,// Return the cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,Availability,mask,mask,11,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Availability,mask,mask,34,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:68,Availability,mask,masked,68,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,Availability,mask,mask,133,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,Performance,load,load,79,// All-one mask is modelled as no-mask following the convention for masked; // load/store/gather/scatter. Initialize BlockMask to no-mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,Availability,mask,mask,21,// This is the block mask. We OR all incoming edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Availability,Mask,Mask,3,// Mask of predecessor is all-one so mask of block is too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:37,Availability,mask,mask,37,// Mask of predecessor is all-one so mask of block is too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,Security,access,access,43,// Determine if the pointer operand of the access is either consecutive or; // reverse consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:207,Integrability,wrap,wrap,207,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:237,Integrability,depend,depend,237,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Modifiability,variab,variable,82,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:326,Modifiability,variab,variable,326,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Performance,optimiz,optimize,116,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:351,Performance,optimiz,optimized,351,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:299,Performance,optimiz,optimizations,299,"// We know that all PHIs in non-header blocks are converted into selects, so; // we don't have to worry about the insertion order and we can just use the; // builder. At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:261,Usability,simpl,simple,261,"// We know that all PHIs in non-header blocks are converted into selects, so; // we don't have to worry about the insertion order and we can just use the; // builder. At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,perform,perform,23,// Is it beneficial to perform intrinsic call compared to lib call?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:405,Availability,mask,mask,405,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Integrability,depend,depending,40,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,Availability,mask,mask,40,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:163,Availability,mask,mask,163,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:218,Availability,mask,mask,218,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:248,Availability,mask,mask,248,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:293,Availability,avail,available,293,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:344,Availability,mask,mask,344,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:383,Availability,mask,mask,383,"// We have 2 cases that would require a mask:; // 1) The block needs to be predicated, either due to a conditional; // in the scalar loop or use of an active lane mask with; // tail-folding, and we use the appropriate mask for the block.; // 2) No mask is required for the block, but the only available; // vector variant at this VF requires a mask, so we synthesize an; // all-true mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Safety,safe,safe,19,"// If not provably safe, use a select to form a safe divisor before widening the; // div/rem operation itself. Otherwise fall through to general handling below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Safety,safe,safe,48,"// If not provably safe, use a select to form a safe divisor before widening the; // div/rem operation itself. Otherwise fall through to general handling below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:199,Performance,scalab,scalable,199,"// Even if the instruction is not marked as uniform, there are certain; // intrinsic calls that can be effectively treated as such, so we check for; // them here. Conservatively, we only do this for scalable vectors, since; // for fixed-width VFs we can always fall back on full scalarization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors if one of the operands is variant then we still; // want to mark as uniform, which will generate one instruction for just; // the first lane of the vector. We can't scalarize the call in the same; // way as for fixed-width vectors because we don't know how many lanes; // there are.; //; // The reasons for doing it this way for scalable vectors are:; // 1. For the assume intrinsic generating the instruction for the first; // lane is still be better than not generating any at all. For; // example, the input may be a splat across all lanes.; // 2. For the lifetime start/end intrinsics the pointer operand only; // does anything useful when the input comes from a stack object,; // which suggests it should always be uniform. For non-stack objects; // the effect is to poison the object, which still allows us to; // remove the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:353,Performance,scalab,scalable,353,"// For scalable vectors if one of the operands is variant then we still; // want to mark as uniform, which will generate one instruction for just; // the first lane of the vector. We can't scalarize the call in the same; // way as for fixed-width vectors because we don't know how many lanes; // there are.; //; // The reasons for doing it this way for scalable vectors are:; // 1. For the assume intrinsic generating the instruction for the first; // lane is still be better than not generating any at all. For; // example, the input may be a splat across all lanes.; // 2. For the lifetime start/end intrinsics the pointer operand only; // does anything useful when the input comes from a stack object,; // which suggests it should always be uniform. For non-stack objects; // the effect is to poison the object, which still allows us to; // remove the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Availability,mask,mask,60,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:97,Availability,Mask,Masked,97,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:241,Availability,mask,mask,241,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:242,Energy Efficiency,efficient,efficient,242,"// TODO: Currently fixed-order recurrences are modeled as chains of; // first-order recurrences. If there are no users of the intermediate; // recurrences in the chain, the fixed order recurrence should be modeled; // directly, enabling more efficient codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,optimiz,optimize,7,// Now optimize the initial VPlan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7,Performance,scalab,scalable,7,"// For scalable vectors, the only interleave factor currently supported; // is 2 since we require the (de)interleave2 intrinsics instead of; // shufflevectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Usability,simpl,simplified,19,"// If Instr can be simplified to an existing VPValue, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:269,Availability,mask,mask,269,"// VPHeaderPHIRecipes must be kept in the phi section of HeaderVPBB. In; // the following cases, VPHeaderPHIRecipes may be created after non-phi; // recipes and need to be moved to the phi section of HeaderVPBB:; // * tail-folding (non-phi recipes computing the header mask are; // introduced earlier than regular header phi recipes, and should appear; // after them); // * Optimizing truncates to VPWidenIntOrFpInductionRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:374,Performance,Optimiz,Optimizing,374,"// VPHeaderPHIRecipes must be kept in the phi section of HeaderVPBB. In; // the following cases, VPHeaderPHIRecipes may be created after non-phi; // recipes and need to be moved to the phi section of HeaderVPBB:; // * tail-folding (non-phi recipes computing the header mask are; // introduced earlier than regular header phi recipes, and should appear; // after them); // * Optimizing truncates to VPWidenIntOrFpInductionRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:96,Security,access,accessing,96,"// From this point onwards, VPlan-to-VPlan transformations may change the plan; // in ways that accessing values using original IR values is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:247,Deployability,pipeline,pipeline,247,"// Outer loop handling: They may require CFG and instruction level; // transformations before even evaluating whether vectorization is profitable.; // Since we cannot modify the incoming IR, we need to build VPlan upfront in; // the vectorization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,Integrability,wrap,wrap,102,"// Tail folding is not supported for outer loops, so the induction increment; // is guaranteed to not wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:57,Availability,down,down,57,"// Visit operation ""Links"" along the reduction chain top-down starting from; // the phi until LoopExitValue. We keep track of the previous item; // (PreviousLink) to tell which of the two operands of a Link will remain; // scalar and which will be reduced. For minmax by select(cmp), Link will be; // the select instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:248,Energy Efficiency,reduce,reduced,248,"// Visit operation ""Links"" along the reduction chain top-down starting from; // the phi until LoopExitValue. We keep track of the previous item; // (PreviousLink) to tell which of the two operands of a Link will remain; // scalar and which will be reduced. For minmax by select(cmp), Link will be; // the select instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,Availability,mask,mask,48,// Index of the first operand which holds a non-mask vector operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Availability,mask,masking,24,"// If tail is folded by masking, introduce selects between the phi; // and the live-out instruction of each reduction, at the beginning of the; // dedicated latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:84,Modifiability,extend,extend,84,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Performance,perform,performed,34,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Usability,resume,resume,205,"// TODO: At the moment ComputeReductionResult also drives creation of the; // bc.merge.rdx phi nodes, hence it needs to be created unconditionally here; // even for in-loop reductions, until the reduction resume value handling is; // also modeled in VPlan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,Performance,perform,performed,24,"// A pointer induction, performed by using a gep",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:17,Deployability,update,update,17,"// Add induction update using an incorrect block temporarily. The phi node; // will be fixed after VPlan execution. Note that at this point the latch; // block cannot be used, as it does not exist yet.; // TODO: Model increment value in VPlan, by turning the recipe into a; // multi-def and a subclass of VPHeaderPHIRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Performance,load,load,27,// Attempt to issue a wide load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Availability,Mask,Mask,3,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,Availability,mask,masks,55,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:95,Availability,mask,mask,95,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:110,Availability,mask,mask,110,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Deployability,update,update,20,// We don't want to update the value in the map as it might be used in; // another expression. So don't call resetVectorValue(StoredVal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Performance,load,loads,10,// Handle loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:23,Performance,load,load,23,"// Add metadata to the load, but setVectorValue to the reverse shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,Integrability,depend,depends,53,"// Determine how to lower the scalar epilogue, which depends on 1) optimising; // for minimum code-size, 2) predicate compiler options, 3) loop hints forcing; // predication, and 4) a TTI hook that analyses whether the loop is suitable; // for predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:286,Availability,reliab,reliably,286,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:253,Integrability,depend,dependency,253,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,Security,access,accessible,205,"// 1) OptSize takes precedence over all other options, i.e. if this is set,; // don't look at hints or options, and don't request a scalar epilogue.; // (For PGSO, as shouldOptimizeForSize isn't currently accessible from; // LoopAccessInfo (due to code dependency and not being able to reliably get; // PSI/BFI from a loop analysis under NPM), we cannot suppress the collection; // of strides in LoopAccessInfo::analyzeLoop() and vectorize without; // versioning when the vectorization is forced, unlike hasOptSize. So revert; // back to the old way and vectorize with versioning when forced. See D81345.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:116,Deployability,pipeline,pipeline,116,"// Process the loop in the VPlan-native vectorization path. This path builds; // VPlan upfront in the vectorization pipeline, which allows to apply; // VPlan-to-VPlan transformations from the very beginning without modifying the; // input LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:86,Availability,Mask,Masked,86,"// If we are stress testing VPlan builds, do not attempt to generate vector; // code. Masked vector code generation support will follow soon.; // Also, do not attempt to vectorize if no vector code will be produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Testability,test,testing,20,"// If we are stress testing VPlan builds, do not attempt to generate vector; // code. Masked vector code generation support will follow soon.; // Also, do not attempt to vectorize if no vector code will be produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Safety,avoid,avoid,42,// Mark the loop as already vectorized to avoid vectorizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:170,Performance,perform,performance,170,// Emit a remark if there are stores to floats that required a floating point; // extension. If the vectorized loop was generated with floating point there; // will be a performance penalty from the conversion overhead and the change in; // the vector width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:1043,Performance,perform,performed,1043,"// First, compute the minimum iteration count required so that the vector; // loop outperforms the scalar loop.; // The total cost of the scalar loop is; // ScalarC * TC; // where; // * TC is the actual trip count of the loop.; // * ScalarC is the cost of a single scalar iteration.; //; // The total cost of the vector loop is; // RtC + VecC * (TC / VF) + EpiC; // where; // * RtC is the cost of the generated runtime checks; // * VecC is the cost of a single vector iteration.; // * TC is the actual trip count of the loop; // * VF is the vectorization factor; // * EpiCost is the cost of the generated epilogue, including the cost; // of the remaining scalar operations.; //; // Vectorization is profitable once the total vector cost is less than the; // total scalar cost:; // RtC + VecC * (TC / VF) + EpiC < ScalarC * TC; //; // Now we can compute the minimum required trip count TC as; // (RtC + EpiC) / (ScalarC - (VecC / VF)) < TC; //; // For now we assume the epilogue cost EpiC = 0 for simplicity. Note that; // the computations are performed on doubles, not integers and the result; // is rounded up, hence we get an upper estimate of the TC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:996,Usability,simpl,simplicity,996,"// First, compute the minimum iteration count required so that the vector; // loop outperforms the scalar loop.; // The total cost of the scalar loop is; // ScalarC * TC; // where; // * TC is the actual trip count of the loop.; // * ScalarC is the cost of a single scalar iteration.; //; // The total cost of the vector loop is; // RtC + VecC * (TC / VF) + EpiC; // where; // * RtC is the cost of the generated runtime checks; // * VecC is the cost of a single vector iteration.; // * TC is the actual trip count of the loop; // * VF is the vectorization factor; // * EpiCost is the cost of the generated epilogue, including the cost; // of the remaining scalar operations.; //; // Vectorization is profitable once the total vector cost is less than the; // total scalar cost:; // RtC + VecC * (TC / VF) + EpiC < ScalarC * TC; //; // Now we can compute the minimum required trip count TC as; // (RtC + EpiC) / (ScalarC - (VecC / VF)) < TC; //; // For now we assume the epilogue cost EpiC = 0 for simplicity. Note that; // the computations are performed on doubles, not integers and the result; // is rounded up, hence we get an upper estimate of the TC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:159,Integrability,depend,dependent,159,"// Second, compute a minimum iteration count so that the cost of the; // runtime checks is only a fraction of the total scalar loop cost. This; // adds a loop-dependent bound on the overhead incurred if the runtime; // checks fail. In case the runtime checks fail, the cost is RtC + ScalarC; // * TC. To bound the runtime check to be a fraction 1/X of the scalar; // cost, compute; // RtC < ScalarC * TC * (1 / X) ==> RtC * X / ScalarC < TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:233,Integrability,message,messages,233,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:180,Performance,optimiz,optimization,180,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:259,Performance,Optimiz,OptimizationRemarkAnalysis,259,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:312,Performance,Optimiz,OptimizationRemark,312,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:335,Performance,Optimiz,OptimizationRemarkMissed,335,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:311,Deployability,pipeline,pipeline,311,"// Entrance to the VPlan-native vectorization path. Outer loops are processed; // here. They may require CFG and instruction level transformations before; // even evaluating whether vectorization is profitable. Since we cannot modify; // the incoming IR, we need to build VPlan upfront in the vectorization; // pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,Security,access,accesses,60,"// If an override option has been passed in for interleaved accesses, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:30,Security,access,accesses,30,// Analyze interleaved memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:89,Performance,optimiz,optimized,89,// Check the function attributes and profiles to find out if this function; // should be optimized for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:92,Performance,optimiz,optimizing,92,"// Check the loop for a trip count threshold: vectorize loops with a tiny trip; // count by optimizing for size, to minimize overheads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:35,Energy Efficiency,efficient,efficient,35,"// Predicate tail-folded loops are efficient even when the loop; // iteration count is low. However, setting the epilogue policy to; // `CM_ScalarEpilogueNotAllowedLowTripLoop` prevents vectorizing loops; // with runtime checks. It's more effective to let; // `areRuntimeChecksProfitable` determine if vectorization is beneficial; // for the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,Safety,unsafe,unsafe,44,"// Check if the target supports potentially unsafe FP vectorization.; // FIXME: Add a check for the type of safety issue (denormal, signaling); // for the target we're vectorizing for, to make sure none of the; // additional fp-math flags can help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:108,Safety,safe,safety,108,"// Check if the target supports potentially unsafe FP vectorization.; // FIXME: Add a check for the type of safety issue (denormal, signaling); // for the target we're vectorizing for, to make sure none of the; // additional fp-math flags can help.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,Integrability,message,messages,27,// Identify the diagnostic messages that should be produced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,Safety,avoid,avoided,34,"// Tell the user interleaving was avoided up-front, despite being explicitly; // requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,Integrability,message,messages,19,"// Emit diagnostic messages, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:278,Usability,resume,resume,278,"// Re-use the trip count and steps expanded for the main loop, as; // skeleton creation needs it as a value that dominates both the scalar; // and vector epilogue loops; // TODO: This is a workaround needed for epilogue vectorization and it; // should be removed once induction resume value creation is done; // directly in VPlan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:135,Deployability,update,updated,135,"// Ensure that the start values for any VPWidenIntOrFpInductionRecipe,; // VPWidenPointerInductionRecipe and VPReductionPHIRecipes are updated; // before vectorizing the epilogue loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,Usability,resume,resume,25,// TODO: Move setting of resume values to prepareToExecute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:93,Deployability,update,update,93,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,Usability,resume,resume,20,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:156,Usability,resume,resume,156,// Create induction resume values for both widened pointer and; // integer/fp inductions and update the start value of the induction; // recipes to use the resume value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Safety,avoid,avoid,42,// Mark the loop as already vectorized to avoid vectorizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,Usability,simpl,simplified,42,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:69,Usability,simpl,simplification,69,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:221,Usability,simpl,simplify,221,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,Usability,simpl,simplify,58,"// For the inner loops we actually process, form LCSSA to simplify the; // transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,Usability,simpl,simplification,82,// Making CFG changes likely means a loop got vectorized. Indicate that; // extra simplification passes should be run.; // TODO: MadeCFGChanges is not a prefect proxy. Extra passes should only; // be run if runtime checks have been added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:647,Performance,perform,performs,647,"//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:437,Safety,detect,detects,437,"//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Performance,optimiz,optimization,56,"// NOTE: If AllowHorRdxIdenityOptimization is true, the optimization will run; // even if we match a reduction but do not vectorize in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduling,23,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Safety,avoid,avoid,62,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Testability,benchmark,benchmarks,107,// Limit the number of alias checks. The limit is chosen so that; // it has no negative effect on the llvm benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Performance,load,load,68,// Another limit for the alias checks: The maximum distance between load/store; // instructions where alias checks are done.; // This limit is useful for very large basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Energy Efficiency,Schedul,ScheduleRegionSizeBudget,11,"/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling; /// regions to be handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Energy Efficiency,schedul,scheduling,65,"/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling; /// regions to be handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:313,Safety,avoid,avoids,313,/// Predicate for the element types that the SLP vectorizer supports.; ///; /// The most important thing to filter here are types which are invalid in LLVM; /// vectors. We also filter target specific types which have absolutely no; /// meaningful vectorization path such as x86_fp80 and ppc_f128. This just; /// avoids spending time checking the cost model and realizing that they will; /// be inevitably scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,/// Specifies the way the mask should be analyzed for undefs/poisonous elements; /// in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:100,Availability,mask,mask,100,/// Specifies the way the mask should be analyzed for undefs/poisonous elements; /// in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Availability,mask,mask,84,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:122,Availability,mask,mask,122,"///< The mask is expected to be for permutation of 1-2 vectors,; ///< check for the mask elements for the first argument (mask; ///< indices are in range [0:VF)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Availability,mask,mask,82,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Availability,mask,mask,121,"///< The mask is expected to be for permutation of 2 vectors, check; ///< for the mask elements for the second argument (mask indices; ///< are in range [VF:2*VF))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,///< Consider undef mask elements (-1) as placeholders for; ///< future shuffle elements and mark them as ones as being used; ///< in future. Non-undef elements are considered as unused since; ///< they're already marked as used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:236,Availability,mask,mask,236,///< Consider undef mask elements (-1) as placeholders for; ///< future shuffle elements and mark them as ones as being used; ///< in future. Non-undef elements are considered as unused since; ///< they're already marked as used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:54,Availability,mask,mask,54,// namespace; /// Prepares a use bitset for the given mask either for the first argument or; /// for the second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:141,Availability,mask,masked,141,"/// Checks if the given value is actually an undefined constant vector.; /// Also, if the \p UseMask is not empty, tries to check if the non-masked; /// elements actually mask the insertelement buildvector, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:171,Availability,mask,mask,171,"/// Checks if the given value is actually an undefined constant vector.; /// Also, if the \p UseMask is not empty, tries to check if the non-masked; /// elements actually mask the insertelement buildvector, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:817,Availability,Mask,Mask,817,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:846,Availability,Mask,Mask,846,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:939,Availability,mask,mask,939,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:944,Safety,detect,detection,944,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduling,60,"// end anonymous namespace; /// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is \p; /// OpValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Performance,perform,perform,97,// Check for compatible operands. If the corresponding operands are not; // compatible - need to perform alternate vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Security,access,access,43,/// \returns the AA location that is being access by the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Performance,load,load,65,/// \returns True if the instruction is not a volatile or atomic load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Availability,Mask,Mask,16,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:122,Availability,mask,mask,122,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:74,Modifiability,Extend,ExtendingManyInputs,74,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Modifiability,extend,extended,31,// Check if input scalars were extended to match the size of other node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:215,Safety,avoid,avoid,215,/// Order may have elements assigned special value (size) which is out of; /// bounds. Such indices only appear on places which correspond to undef values; /// (see canReuseExtract for details) and used in order to avoid undef values; /// have effect on operands ordering.; /// The first loop below simply finds all unused indices and then the next loop; /// nest assigns these indices for undef values positions.; /// As an example below Order has two undef positions and they have assigned; /// values 3 and 7 respectively:; /// before: 6 9 5 4 9 2 1 0; /// after: 6 3 5 4 7 2 1 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:299,Usability,simpl,simply,299,/// Order may have elements assigned special value (size) which is out of; /// bounds. Such indices only appear on places which correspond to undef values; /// (see canReuseExtract for details) and used in order to avoid undef values; /// have effect on operands ordering.; /// The first loop below simply finds all unused indices and then the next loop; /// nest assigns these indices for undef values positions.; /// As an example below Order has two undef positions and they have assigned; /// values 3 and 7 respectively:; /// before: 6 9 5 4 9 2 1 0; /// after: 6 3 5 4 7 2 1 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Availability,Mask,Mask,65,/// Reorders the list of scalars in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all operands are either not instructions; /// or phi nodes or instructions from different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Energy Efficiency,schedul,scheduling,87,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all operands are either not instructions; /// or phi nodes or instructions from different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all users are phi nodes or instructions; /// from the different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Energy Efficiency,schedul,scheduling,87,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all users are phi nodes or instructions; /// from the different blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Energy Efficiency,schedul,scheduling,51,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Energy Efficiency,schedul,scheduling,88,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:147,Energy Efficiency,schedul,scheduled,147,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:67,Energy Efficiency,schedul,scheduling,67,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:159,Energy Efficiency,schedul,scheduling,159,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:200,Energy Efficiency,schedul,scheduling,200,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Energy Efficiency,schedul,scheduling,98,"/// Construct a vectorizable tree that starts at \p Roots, ignoring users for; /// the purpose of scheduling and extraction in the \p UserIgnoreLst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clear,4,/// Clear the internal data structures that are created by 'buildTree'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Perform,Perform,4,/// Perform LICM and CSE on the newly generated gather sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:213,Performance,Load,Loads,213,"/// Checks if the specified gather tree entry \p TE can be represented as a; /// shuffled vector entry + (possibly) permutation with other gathers. It; /// implements the checks only for possibly ordered scalars (Loads,; /// ExtractElement, ExtractValue), which can be part of the graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Performance,load,loads,9,/// Sort loads into increasing pointers offsets to allow greater clustering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:354,Modifiability,extend,extend,354,/// Reorders the current graph to the most profitable order starting from the; /// root node to the leaf nodes. The best order is chosen only from the nodes; /// of the same size (vectorization factor). Smaller nodes are considered; /// parts of subgraph with smaller VF and they are reordered independently. We; /// can make it because we still need to extend smaller nodes to the wider VF; /// and we can merge reordering shuffles with the widening shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,Energy Efficiency,reduce,reduce,139,"/// Reorders the current graph to the most profitable order starting from; /// leaves to the root. It allows to rotate small subgraphs and reduce the; /// number of reshuffles if the leaf nodes use the same order. In this case we; /// can merge the orders and just shuffle user node instead of shuffling its; /// operands. Plus, even the leaf nodes have different orders, it allows to; /// sink reordering in the graph closer to the root node and merge it later; /// during analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:222,Performance,load,loaded,222,"/// \return The vector element size in bits to use when vectorizing the; /// expression tree ending at \p V. If V is a store, the size is the width of; /// the stored value. Otherwise, the size is the width of the largest loaded; /// value reaching V. This method is used by the vectorizer to calculate; /// vectorization factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Performance,load,loaded,63,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,load,89,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:119,Performance,Load,Load,119,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:168,Performance,optimiz,optimizer,168,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:372,Performance,load,load,372,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:408,Performance,optimiz,optimizer,408,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:352,Usability,undo,undo,352,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Performance,load,loaded,64,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Performance,load,load,90,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:120,Performance,Load,Load,120,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:169,Performance,optimiz,optimizer,169,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:373,Performance,load,load,373,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:409,Performance,optimiz,optimizer,409,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:353,Usability,undo,undo,353,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:466,Performance,load,loads,466,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:710,Performance,Load,Loads,710,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:756,Performance,load,load,756,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:768,Performance,load,load,768,"// The hard-coded scores listed here are not very important, though it shall; // be higher for better matches to improve the resulting cost. When; // computing the scores of matching one sub-tree with another, we are; // basically counting the number of values that are matching. So even if all; // scores are set to 1, we would still get a decent matching result.; // However, sometimes we have to break ties. For example we may have to; // choose between matching loads vs matching opcodes. This is what these; // scores are helping us with: they provide the order of preference. Also,; // this is important if the scalar is externally used or used in another; // tree entry node in the different lane.; /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Performance,load,load,13,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Performance,throughput,throughput,192,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:239,Performance,load,load,239,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Load,Loads,4,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Performance,load,load,47,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:61,Performance,load,load,61,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Availability,mask,masked,25,/// A load candidate for masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:6,Performance,load,load,6,/// A load candidate for masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Performance,load,load,20,// A broadcast of a load can be cheaper on some targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Availability,mask,masked,62,// The distance is too large - still may be profitable to use masked; // loads/gathers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Performance,load,loads,73,// The distance is too large - still may be profitable to use masked; // loads/gathers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Energy Efficiency,power,power-,107,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,loads,38,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Safety,detect,detect,19,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Performance,optimiz,optimized,98,// Extracts from consecutive indexes of the same vector better score as; // the extracts could be optimized away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Safety,avoid,avoid,58,// Note: Only consider instructions with <= 2 operands to avoid; // complexity explosion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:673,Performance,load,loads,673,"/// Go through the operands of \p LHS and \p RHS recursively until; /// MaxLevel, and return the cummulative score. \p U1 and \p U2 are; /// the users of \p LHS and \p RHS (that is \p LHS and \p RHS are operands; /// of \p U1 and \p U2), except at the beginning of the recursion where; /// these are set to nullptr.; ///; /// For example:; /// \verbatim; /// A[0] B[0] A[1] B[1] C[0] D[0] B[1] A[1]; /// \ / \ / \ / \ /; /// + + + +; /// G1 G2 G3 G4; /// \endverbatim; /// The getScoreAtLevelRec(G1, G2) function will try to match the nodes at; /// each level recursively, accumulating the score. It starts from matching; /// the additions at level 0, then moves on to the loads (level 1). The; /// score of G1 and G2 is higher than G1 and G3, because {A[0],A[1]} and; /// {B[0],B[1]} match with LookAheadHeuristics::ScoreConsecutiveLoads, while; /// {A[0],C[0]} has a score of LookAheadHeuristics::ScoreFail.; /// Please note that the order of the operands does not matter, as we; /// evaluate the score of all profitable combinations of operands. In; /// other words the score of G1 and G4 is the same as G1 and G2. This; /// heuristic is based on ideas described in:; /// Look-ahead SLP: Auto-vectorization in the presence of commutative; /// operations, CGO 2018 by Vasileios Porpodas, Rodrigo C. O. Rocha,; /// Lus F. W. Ges",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:162,Performance,load,loads,162,"// If reached MaxLevel,; // or if V1 and V2 are not instructions,; // or if they are SPLAT,; // or if they are not consecutive,; // or if profitable to vectorize loads or extractelements, early return; // the current cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:172,Safety,avoid,avoid,172,"/// For each operand we need (i) the value, and (ii) the opcode that it; /// would be attached to if the expression was in a left-linearized form.; /// This is required to avoid illegal operand reordering.; /// For example:; /// \verbatim; /// 0 Op1; /// |/; /// Op1 Op2 Linearized + Op2; /// \ / ----------> |/; /// - -; ///; /// Op1 - Op2 (0 + Op1) - Op2; /// \endverbatim; ///; /// Value Op1 is attached to a '+' operation, and Op2 to a '-'.; ///; /// Another way to think of this is to track all the operations across the; /// path from the operand all the way to the root of the tree and to; /// calculate the operation that corresponds to this path. For example, the; /// path from Op2 to the root crosses the RHS of the '-', therefore the; /// corresponding operation is a '-' (which matches the one in the; /// linearized tree, as shown above).; ///; /// For lack of a better term, we refer to this operation as Accumulated; /// Path Operation (APO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:113,Safety,safe,safely,113,"/// TreeEntries only allow a single opcode, or an alternate sequence of; /// them (e.g, +, -). Therefore, we can safely use a boolean value for the; /// APO. It is set to 'true' if 'V' is attached to an inverse operation; /// in the left-linearized form (e.g., Sub/Div), and 'false' otherwise; /// (e.g., Add/Mul)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:257,Performance,load,load,257,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:285,Performance,load,load,285,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:303,Security,access,accessing,303,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Performance,load,loads,14,///< Matching loads to consecutive memory addresses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears the used flag for all entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:334,Energy Efficiency,power,power-of-,334,"/// \param Lane lane of the operands under analysis.; /// \param OpIdx operand index in \p Lane lane we're looking the best; /// candidate for.; /// \param Idx operand index of the current candidate value.; /// \returns The additional score due to possible broadcasting of the; /// elements in the lane. It is more profitable to have power-of-2 unique; /// elements in the lane, it will be vectorized with higher probability; /// after removing duplicates. Currently the SLP vectorizer supports only; /// vectorization of the power-of-2 number of unique scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:526,Energy Efficiency,power,power-of-,526,"/// \param Lane lane of the operands under analysis.; /// \param OpIdx operand index in \p Lane lane we're looking the best; /// candidate for.; /// \param Idx operand index of the current candidate value.; /// \returns The additional score due to possible broadcasting of the; /// elements in the lane. It is more profitable to have power-of-2 unique; /// elements in the lane, it will be vectorized with higher probability; /// after removing duplicates. Currently the SLP vectorizer supports only; /// vectorization of the power-of-2 number of unique scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Safety,avoid,avoid,52,// Set the minimum score for splat-like sequence to avoid setting; // failed state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,power,power-of-,112,"// Track if the operand must be marked as used. If the operand is set to; // Score 1 explicitly (because of non power-of-2 unique scalars, we may; // want to reestimate the operands again on the following iterations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Usability,simpl,simple,56,"// std::pair<unsigned, unsigned> is used to implement a simple voting; // algorithm and choose the lane with the least number of operands that; // can freely move about or less profitable because it already has the; // most optimal set of operands. The first unsigned is a counter for; // voting, the second unsigned is the counter of lanes with instructions; // with same/alternate opcodes and same parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Security,Hash,Hash,4,"/// Hash for the actual operands ordering.; /// Used to count operands, actually their position id and opcode; /// value. It is used in the voting mechanism to find the lane with the; /// least number of operands that can freely move about or less profitable; /// because it already has the most optimal set of operands. Can be; /// replaced with SmallVector<unsigned> instead but hash code is faster; /// and requires less memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:381,Security,hash,hash,381,"/// Hash for the actual operands ordering.; /// Used to count operands, actually their position id and opcode; /// value. It is used in the voting mechanism to find the lane with the; /// least number of operands that can freely move about or less profitable; /// because it already has the most optimal set of operands. Can be; /// replaced with SmallVector<unsigned> instead but hash code is faster; /// and requires less memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:206,Safety,avoid,avoid,206,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:244,Usability,simpl,simply,244,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:444,Performance,perform,performed,444,"// Our tree has just 3 nodes: the root and two operands.; // It is therefore trivial to get the APO. We only need to check the; // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or; // RHS operand. The LHS operand of both add and sub is never attached; // to an inversese operation in the linearized form, therefore its APO; // is false. The RHS is true only if VL[Lane] is an inverse operation.; // Since operand reordering is performed on groups of commutative; // operations or alternating sequences (e.g., +, -), we can safely; // tell the inverse operations by checking commutativity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:540,Safety,safe,safely,540,"// Our tree has just 3 nodes: the root and two operands.; // It is therefore trivial to get the APO. We only need to check the; // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or; // RHS operand. The LHS operand of both add and sub is never attached; // to an inversese operation in the linearized form, therefore its APO; // is false. The RHS is true only if VL[Lane] is an inverse operation.; // Since operand reordering is performed on groups of commutative; // operations or alternating sequences (e.g., +, -), we can safely; // tell the inverse operations by checking commutativity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears the data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Performs,3,// Performs operand reordering for 2 or more operands.; // The original operands are in OrigOps[OpIdx][Lane].; // The reordered operands are returned in 'SortedOps[OpIdx][Lane]'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:183,Energy Efficiency,power,power,183,// Check that we don't have same operands. No need to reorder if operands; // are just perfect diamond or shuffled diamond match. Do not do it only; // for possible broadcasts or non-power of 2 number of scalars (just for; // now).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Energy Efficiency,power,power-,48,// TODO: Check if we can remove a check for non-power-2 number of; // scalars after full support of non-power-2 vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Energy Efficiency,power,power-,104,// TODO: Check if we can remove a check for non-power-2 number of; // scalars after full support of non-power-2 vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Performance,perform,perform,77,"// If the initial strategy fails for any of the operand indexes, then we; // perform reordering again in a second pass. This helps avoid assigning; // high priority to the failed strategy, and should improve reordering for; // the non-failed operand indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,Safety,avoid,avoid,131,"// If the initial strategy fails for any of the operand indexes, then we; // perform reordering again in a second pass. This helps avoid assigning; // high priority to the failed strategy, and should improve reordering for; // the non-failed operand indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Safety,avoid,avoid,118,"// Check if no need to reorder operands since they're are perfect or; // shuffled diamond match.; // Need to do it to avoid extra external use cost counting for; // shuffled matches, which may cause regressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Energy Efficiency,reduce,reduced,35,/// Checks if the provided list of reduced values was checked already for; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Energy Efficiency,reduce,reduced,21,/// Adds the list of reduced values to list of already checked values for the; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clear,4,/// Clear the list of the analyzed reduction root instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:322,Performance,load,loads,322,"/// Check if the operands on the edges \p Edges of the \p UserTE allows; /// reordering (i.e. the operands can be reordered because they have only one; /// user and reordarable).; /// \param ReorderableGathers List of all gather nodes that require reordering; /// (e.g., gather of extractlements or partially vectorizable loads).; /// \param GatherOps List of gather operand nodes for \p UserTE that require; /// reordering, subset of \p NonVectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Availability,Mask,Mask,111,/// Checks if the given \p TE is a gather node with clustered reused scalars; /// and reorders it per given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Safety,avoid,avoid,124,"/// Vectorize a single entry in the tree.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Safety,avoid,avoid,170,"/// Vectorize a single entry in the tree, the \p Idx-th operand of the entry; /// \p E.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Performance,optimiz,optimization,170,"/// Create a new vector from a list of scalar values. Produces a sequence; /// which exploits values reused across lanes, and arranges the inserts; /// for ease of later optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,Performance,optimiz,optimization,170,"/// Create a new vector from a list of scalar values. Produces a sequence; /// which exploits values reused across lanes, and arranges the inserts; /// for ease of later optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Energy Efficiency,schedul,scheduling,86,"/// Returns the instruction in the bundle, which can be used as a base point; /// for scheduling. Usually it is the last instruction in the bundle, except; /// for the case when all operands are external (in this case, it is the first; /// instruction in the list).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt; /// was successful, the matched scalars are replaced by poison values in \p VL; /// for future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt; /// was successful, the matched scalars are replaced by poison values in \p VL; /// for future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:413,Availability,Mask,Mask,413,"/// Checks if the gathered \p VL can be represented as a single register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations. Must form single-register vector.; /// \returns ShuffleKind, if gathered values can be represented as shuffles of; /// previous tree entries. \p Part of \p Mask is filled with the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:445,Availability,mask,mask,445,"/// Checks if the gathered \p VL can be represented as a single register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations. Must form single-register vector.; /// \returns ShuffleKind, if gathered values can be represented as shuffles of; /// previous tree entries. \p Part of \p Mask is filled with the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:388,Availability,Mask,Mask,388,"/// Checks if the gathered \p VL can be represented as multi-register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations.; /// \returns per-register series of ShuffleKind, if gathered values can be; /// represented as shuffles of previous tree entries. \p Mask is filled with; /// the shuffle mask (also on per-register base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:425,Availability,mask,mask,425,"/// Checks if the gathered \p VL can be represented as multi-register; /// shuffle(s) of previous tree entries.; /// \param TE Tree entry checked for permutation.; /// \param VL List of scalars (a subset of the TE scalar), checked for; /// permutations.; /// \returns per-register series of ShuffleKind, if gathered values can be; /// represented as shuffles of previous tree entries. \p Mask is filled with; /// the shuffle mask (also on per-register base).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,/// \returns Common mask for reorder indices and reused scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:141,Performance,load,load,141,/// Do we need to gather this sequence or vectorize it; /// (either with vector instruction or with scatter/gather; /// intrinsics for store/load)?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:137,Performance,perform,performs,137,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,Safety,avoid,avoid,98,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,mask,47,/// Reorders operands of the node to the given mask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:55,Availability,Mask,Mask,55,/// Reorders operands of the node to the given mask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduling,32,"/// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is; /// \p OpValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Availability,mask,mask,20,/// Build a shuffle mask for graph entry which represents a merge of main; /// and alternate operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Availability,mask,mask,35,// Reorder scalars and build final mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the scheduler bundle to point to this TreeEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,scheduler,14,// Update the scheduler bundle to point to this TreeEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Energy Efficiency,schedul,scheduling,121,/// Checks if the specified list of the instructions/values can be vectorized; /// and fills required data before actual scheduling of the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Integrability,depend,depending,26,"/// List of gather nodes, depending on other gather/vector nodes, which should; /// be emitted after the vector instruction emission process to correctly; /// handle order of the vector instructions and shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Security,access,access,35,/// Checks if two instructions may access the same memory.; ///; /// \p Loc1 is the location of \p Inst1. It is passed explicitly because it; /// is invariant in the calling loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Performance,cache,cache,47,// First check if the result is already in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,cache,cache,27,// Store the result in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Cache,Cache,4,/// Cache for alias results.; /// TODO: consider moving this to the AliasAnalysis itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Cache,Cache,3,// Cache for pointerMayBeCaptured calls inside AA. This is preserved; // globally through SLP because we don't perform any action which; // invalidates capture results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Performance,perform,perform,111,// Cache for pointerMayBeCaptured calls inside AA. This is preserved; // globally through SLP because we don't perform any action which; // invalidates capture results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:267,Energy Efficiency,allocate,allocated,267,"/// Temporary store for deleted instructions. Instructions will be deleted; /// eventually when the BoUpSLP is destructed. The deferral is required to; /// ensure that there are no incorrect collisions in the AliasCache, which; /// can happen if a new instruction is allocated at the same address as a; /// previously deleted instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Security,hash,hashes,11,/// Set of hashes for the list of reduction values already being analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,/// Contains all scheduling relevant data for an instruction.; /// A ScheduleData either represents a single instruction or a member of an; /// instruction bundle (= a group of instructions which is combined into a; /// vector instruction).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:69,Energy Efficiency,Schedul,ScheduleData,69,/// Contains all scheduling relevant data for an instruction.; /// A ScheduleData either represents a single instruction or a member of an; /// instruction bundle (= a group of instructions which is combined into a; /// vector instruction).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Integrability,depend,dependency,29,// The initial value for the dependency counters. It means that the; // dependencies are not calculated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:72,Integrability,depend,dependencies,72,// The initial value for the dependency counters. It means that the; // dependencies are not calculated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Integrability,depend,dependency,24,/// Returns true if the dependency information has been calculated.; /// Note that depenendency validity can vary between instructions within; /// a single bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,schedul,scheduling,36,"/// Returns true if it is ready for scheduling, i.e. it has no more; /// unscheduled depending instructions/bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:85,Integrability,depend,depending,85,"/// Returns true if it is ready for scheduling, i.e. it has no more; /// unscheduled depending instructions/bundles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:39,Integrability,depend,dependencies,39,"/// Modifies the number of unscheduled dependencies for this instruction,; /// and returns the number of remaining dependencies for the containing; /// bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:115,Integrability,depend,dependencies,115,"/// Modifies the number of unscheduled dependencies for this instruction,; /// and returns the number of remaining dependencies for the containing; /// bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Integrability,depend,dependencies,35,/// Sets the number of unscheduled dependencies to the number of; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Integrability,depend,dependencies,70,/// Sets the number of unscheduled dependencies to the number of; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Integrability,depend,dependency,15,/// Clears all dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Clear,Clears,4,/// Clears all dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:45,Energy Efficiency,schedul,schedule,45,/// Opcode of the current instruction in the schedule data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:116,Energy Efficiency,schedul,scheduling,116,"/// Single linked list of all memory instructions (e.g. load, store, call); /// in the block - until the end of the scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Performance,load,load,56,"/// Single linked list of all memory instructions (e.g. load, store, call); /// in the block - until the end of the scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:8,Integrability,depend,dependent,8,/// The dependent memory instructions.; /// This list is derived on demand in calculateDependencies().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:166,Availability,fault,fault,166,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Energy Efficiency,schedul,scheduled,110,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Integrability,depend,dependent,65,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,Performance,load,load,235,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Energy Efficiency,Schedul,ScheduleData,9,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,schedul,scheduling,40,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Energy Efficiency,Schedul,SchedulingRegionID,91,/// This ScheduleData is in the current scheduling region if this matches; /// the current SchedulingRegionID of BlockScheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Integrability,depend,dependencies,18,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Integrability,depend,dependent,110,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:226,Integrability,depend,dependencies,226,"/// The number of dependencies. Constitutes of the number of users of the; /// instruction plus the number of dependent memory instructions (if any).; /// This value is calculated on demand.; /// If InvalidDeps, the number of dependencies is not calculated yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:67,Energy Efficiency,schedul,scheduled,67,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:164,Energy Efficiency,schedul,scheduling,164,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Integrability,depend,dependencies,18,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Integrability,depend,dependencies,51,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:219,Integrability,Depend,Dependencies,219,"/// The number of dependencies minus the number of dependencies of scheduled; /// instructions. As soon as this is zero, the instruction/bundle gets ready; /// for scheduling.; /// Note that this is negative as long as Dependencies is not calculated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduled,32,/// True if this instruction is scheduled (or considered as scheduled in the; /// dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduled,60,/// True if this instruction is scheduled (or considered as scheduled in the; /// dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:69,Energy Efficiency,schedul,schedules,69,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:400,Energy Efficiency,schedul,scheduling,400,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:449,Energy Efficiency,schedul,scheduled,449,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:608,Energy Efficiency,Schedul,ScheduleData,608,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:858,Energy Efficiency,schedul,scheduling,858,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:874,Energy Efficiency,Schedul,ScheduleData,874,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:894,Energy Efficiency,allocate,allocated,894,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:952,Energy Efficiency,schedul,scheduling,952,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:797,Integrability,depend,dependencies,797,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,schedule,22,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Energy Efficiency,schedul,scheduling,75,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,scheduling,14,"// Make a new scheduling region, i.e. all existing ScheduleData is not; // in the new region yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Energy Efficiency,Schedul,ScheduleData,51,"// Make a new scheduling region, i.e. all existing ScheduleData is not; // in the new region yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid lookup if can't possibly be in map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,schedul,scheduled,28,/// Marks an instruction as scheduled and puts all dependent ready; /// instructions into the ready-list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,Integrability,depend,dependent,51,/// Marks an instruction as scheduled and puts all dependent ready; /// instructions into the ready-list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Integrability,depend,dependencies,28,// Handle the def-use chain dependencies.; // Decrement the unscheduled counter and insert to ready list if ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after; // decrementing, so we can put the dependent instruction; // into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after; // decrementing, so we can put the dependent instruction; // into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:300,Energy Efficiency,schedul,scheduler,300,// Since vectorization tree is being built recursively this assertion; // ensures that the tree entry has all operands set before reaching; // this code. Couple of exceptions known at the moment are extracts; // where their second (immediate) operand is not added. Since; // immediates do not affect scheduler behavior this is considered; // okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Testability,assert,assertion,60,// Since vectorization tree is being built recursively this assertion; // ensures that the tree entry has all operands set before reaching; // this code. Couple of exceptions known at the moment are extracts; // where their second (immediate) operand is not added. Since; // immediates do not affect scheduler behavior this is considered; // okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Availability,failure,failure,27,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Safety,avoid,avoid,15,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Testability,assert,assertions,40,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Security,access,access,107,"// If BundleMember is a stand-alone instruction, no operand reordering; // has taken place, so we directly access its operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Integrability,depend,dependencies,21,// Handle the memory dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Integrability,depend,dependencies,22,// Handle the control dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Integrability,depend,dependencies,33,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,dependent,88,"// There are no more unscheduled dependencies after decrementing,; // so we can put the dependent instruction into the ready list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Energy Efficiency,schedul,scheduling,64,/// Put all instructions into the ReadyList which are ready for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,Schedul,ScheduleData,28,/// Build a bundle from the ScheduleData nodes corresponding to the; /// scalar instruction for each lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:46,Energy Efficiency,schedul,scheduled,46,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Energy Efficiency,schedul,scheduling,192,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:290,Energy Efficiency,schedul,scheduled,290,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:81,Integrability,depend,dependencies,81,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates schedule data chunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,/// Allocates schedule data chunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Energy Efficiency,schedul,scheduling,16,/// Extends the scheduling region so that V is inside the region.; /// \returns true if the region size is within the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Modifiability,Extend,Extends,4,/// Extends the scheduling region so that V is inside the region.; /// \returns true if the region size is within the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Energy Efficiency,Schedul,ScheduleData,19,/// Initialize the ScheduleData structures for new instructions in the; /// scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Energy Efficiency,schedul,scheduling,76,/// Initialize the ScheduleData structures for new instructions in the; /// scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Deployability,Update,Updates,4,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Integrability,depend,dependency,16,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:95,Integrability,depend,depend,95,/// Updates the dependency information of a bundle and of all instructions/; /// bundles which depend on the original bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,schedul,scheduling,32,/// Sets all instruction in the scheduling region to un-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,Energy Efficiency,schedul,scheduled,56,/// Sets all instruction in the scheduling region to un-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Energy Efficiency,Schedul,ScheduleData,33,/// Simple memory allocation for ScheduleData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Usability,Simpl,Simple,4,/// Simple memory allocation for ScheduleData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,Schedul,ScheduleData,18,/// The size of a ScheduleData array in ScheduleDataChunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,Schedul,ScheduleDataChunks,40,/// The size of a ScheduleData array in ScheduleDataChunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:81,Energy Efficiency,Schedul,ScheduleDataChunks,81,"/// The allocator position in the current chunk, which is the last entry; /// of ScheduleDataChunks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,Schedul,ScheduleData,13,"/// Attaches ScheduleData to Instruction.; /// Note that the mapping survives during all vectorization iterations, i.e.; /// ScheduleData structures are recycled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:125,Energy Efficiency,Schedul,ScheduleData,125,"/// Attaches ScheduleData to Instruction.; /// Note that the mapping survives during all vectorization iterations, i.e.; /// ScheduleData structures are recycled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,Schedul,ScheduleData,13,/// Attaches ScheduleData to Instruction with the leading key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduling,23,/// The ready-list for scheduling (only used for the dry-run).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Energy Efficiency,schedul,scheduling,33,/// The first instruction of the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Energy Efficiency,schedul,scheduling,38,/// The first instruction _after_ the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Energy Efficiency,schedul,scheduling,50,/// The first memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Security,access,accessing,21,/// The first memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:49,Energy Efficiency,schedul,scheduling,49,/// The last memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Security,access,accessing,20,/// The last memory accessing instruction in the scheduling region; /// (can be null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:59,Energy Efficiency,schedul,scheduling,59,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Integrability,depend,dependence,104,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Performance,optimiz,optimize,91,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Energy Efficiency,schedul,scheduling,28,/// The current size of the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,schedul,scheduling,37,/// The maximum size allowed for the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,schedul,scheduling,18,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:116,Energy Efficiency,Schedul,ScheduleData,116,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:178,Energy Efficiency,Schedul,SchedulingRegionID,178,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:230,Energy Efficiency,Schedul,SchedulingRegionID,230,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:252,Energy Efficiency,Schedul,ScheduleData,252,"/// The ID of the scheduling region. For a new vectorization iteration this; /// is incremented which ""removes"" all ScheduleData from the region.; /// Make sure that the initial SchedulingRegionID is greater than the; /// initial SchedulingRegionID in ScheduleData (which is 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Energy Efficiency,schedul,scheduling,24,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Performance,Perform,Performs,4,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Performance,perform,performed,79,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Energy Efficiency,schedul,scheduling,35,/// List of users to ignore during scheduling and that don't need extracting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:256,Modifiability,extend,extended,256,"/// A map of scalar integer values to the smallest bit width with which they; /// can legally be represented. The values map to (width, signed) pairs,; /// where ""width"" indicates the minimum bit width and ""signed"" is True if the; /// value must be signed-extended, rather than zero-extended, back to its; /// original width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Modifiability,extend,extended,283,"/// A map of scalar integer values to the smallest bit width with which they; /// can legally be represented. The values map to (width, signed) pairs,; /// where ""width"" indicates the minimum bit width and ""signed"" is True if the; /// value must be signed-extended, rather than zero-extended, back to its; /// original width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,Availability,Mask,Mask,64,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Availability,mask,mask,103,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:174,Availability,mask,mask,174,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:211,Availability,Mask,Mask,211,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Availability,Mask,Mask,58,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:195,Availability,Mask,Mask,195,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:271,Usability,clear,cleared,271,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Performance,load,loads,42,/// Tracks the state we can represent the loads in the given sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Performance,load,loads,33,"/// Checks if the given array of loads can be represented as a vectorized,; /// scatter or just simple gather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Usability,simpl,simple,96,"/// Checks if the given array of loads can be represented as a vectorized,; /// scatter or just simple gather.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Performance,load,loads,17,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Performance,load,loads,92,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Usability,simpl,simple,41,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Performance,load,loads,25,// Check that the sorted loads are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Security,access,access,33,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Simpl,Simple,3,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,clear,clear,42,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,Energy Efficiency,allocate,allocated,107,// For each of the bases sort the pointers by Offset and check if any of the; // base become consecutively allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Availability,mask,mask,96,"// Check if reuse shuffle indices can be improved by reordering.; // For this, check that reuse mask is ""clustered"", i.e. each scalar values; // is used once in each submask of size <number_of_scalars>.; // Example: 4 scalar values.; // ReuseShuffleIndices mask: 0, 1, 2, 3, 3, 2, 0, 1 - clustered.; // 0, 1, 2, 3, 3, 3, 1, 0 - not clustered, because; // element 3 is used twice in the second submask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:257,Availability,mask,mask,257,"// Check if reuse shuffle indices can be improved by reordering.; // For this, check that reuse mask is ""clustered"", i.e. each scalar values; // is used once in each submask of size <number_of_scalars>.; // Example: 4 scalar values.; // ReuseShuffleIndices mask: 0, 1, 2, 3, 3, 2, 0, 1 - clustered.; // 0, 1, 2, 3, 3, 3, 1, 0 - not clustered, because; // element 3 is used twice in the second submask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Availability,mask,mask,24,"/// Checks if the given mask is a ""clustered"" mask with the same clusters of; /// size \p Sz, which are not identity submasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:46,Availability,mask,mask,46,"/// Checks if the given mask is a ""clustered"" mask with the same clusters of; /// size \p Sz, which are not identity submasks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Availability,mask,mask,18,// Reorder reuses mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,mask,60,// Clear reorder since it is going to be applied to the new mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear reorder since it is going to be applied to the new mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,// Fill the reuses mask with the identity submasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,error,error,32,// FIXME: Workaround for syntax error reported by MSVC buildbots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,loads,89,"// Find all reorderable nodes with the given VF.; // Currently the are vectorized stores,loads,extracts + some gathering of; // extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Availability,mask,mask,14,// The opcode mask selects between the two opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Modifiability,extend,extend,48,"// No need to reorder this nodes, still need to extend and to use shuffle,; // just need to merge reordering shuffle and the reuse shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Availability,mask,mask,29,"// Stores actually store the mask, not the order, need to invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:30,Availability,mask,masks,30,// Need to reorder the reuses masks of the operands with smaller VF to; // be able to find the match between the graph nodes and scalar; // operands of the given node during vectorization/cost estimation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update ordering of the operands with the smaller VF than the given; // one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Performance,load,loads,52,"// Build correct orders for extract{element,value}, loads and; // stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Safety,avoid,avoid,84,// Apply reversed order to keep the original ordering of the reused; // elements to avoid extra reorder indices shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:284,Availability,mask,mask,284,"// Add ScatterVectorize nodes to the list of operands, where just; // reordering of the scalars is required. Similar to the gathers, so; // simply add to the list of gathered ops.; // If there are reused scalars, process this node as a regular vectorize; // node, just reorder reuses mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:140,Usability,simpl,simply,140,"// Add ScatterVectorize nodes to the list of operands, where just; // reordering of the scalars is required. Similar to the gathers, so; // simply add to the list of gathered ops.; // If there are reused scalars, process this node as a regular vectorize; // node, just reorder reuses mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:87,Performance,load,loads,87,"// Find all reorderable leaf nodes with the given VF.; // Currently the are vectorized loads,extracts without alternate operands +; // some gathering of extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Integrability,depend,dependency,124,// Build a map between user nodes and their operands order to speedup; // search. The graph currently does not provide this dependency directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Availability,mask,mask,29,"// Stores actually store the mask, not the order, need to invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Safety,avoid,avoid,86,// Check if users allow reordering.; // Currently look up just 1 level of operands to avoid increase of; // the compile time.; // Profitable to reorder if definitely more operands allow; // reordering rather than those with natural order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Modifiability,Extend,Extend,70,// For now just keep one store per pointer object per lane.; // TODO: Extend this to support multiple stores per pointer per lane,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,Safety,avoid,avoid,131,"// We check whether the stores in StoreVec can form a vector by sorting them; // and checking whether they are consecutive.; // To avoid calling getPointersDiff() while sorting we create a vector of; // pairs {store, offset from first} and sort this instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:93,Energy Efficiency,schedul,scheduling,93,"/// \return true if the specified list of values has only one instruction that; /// requires scheduling, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:109,Safety,detect,detection,109,/// Generates key/subkey pair for the given value to provide effective sorting; /// of the values and better detection of the vectorizable values sequences. The; /// keys/subkeys can be used for better sorting of the values themselves (keys); /// and in values subgroups (subkeys).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,loads,12,// Sort the loads by the distance between the pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Energy Efficiency,allocate,allocated,42,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,simpl,simple,42,// Make sure all stores in the bundle are simple - we can't vectorize; // atomic or volatile stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Performance,load,load,60,"// Gather if we hit the RecursionMaxDepth, unless this is a load (or z/sext of; // a load), in which case peek through to include it in the tree, without; // ballooning over-budget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:85,Performance,load,load,85,"// Gather if we hit the RecursionMaxDepth, unless this is a load (or z/sext of; // a load), in which case peek through to include it in the tree, without; // ballooning over-budget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Performance,scalab,scalable,16,// Don't handle scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,Usability,simpl,simple,62,"// If all of the operands are identical or constant we have a simple solution.; // If we deal with insert/extract instructions, they all must have constant; // indices, otherwise we should gather them, not try to vectorize.; // If alternate op node with 2 elements with gathered operands - do not; // vectorize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Energy Efficiency,schedul,schedulable,80,// Check that all of the users of the scalars that we want to vectorize are; // schedulable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Energy Efficiency,schedul,scheduling,118,// Don't go into unreachable blocks. They may contain instructions with; // dependency cycles which confuse the final scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Integrability,depend,dependency,76,// Don't go into unreachable blocks. They may contain instructions with; // dependency cycles which confuse the final scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:186,Safety,avoid,avoid,186,"// Don't go into catchswitch blocks, which can happen with PHIs.; // Such blocks can only have PHIs and the catchswitch. There is no; // place to insert a shuffle if we need to, so just avoid that issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform specific checks for each particular instruction kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Safety,avoid,avoid,35,// Keeps the reordered operands to avoid code duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Modifiability,extend,extending,86,"// This is a special case, as it does not gather, but at the same time; // we are not extending buildTree_rec() towards the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Modifiability,extend,extending,86,"// This is a special case, as it does not gather, but at the same time; // we are not extending buildTree_rec() towards the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,load,27,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Performance,load,load,38,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Performance,load,load,75,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,Performance,load,loads,121,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:231,Performance,load,loading,231,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,"// Check that a vectorized load would load the same memory as a scalar; // load. For example, we don't want to vectorize loads that are smaller; // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM; // treats loading/storing it as an i8 struct. If we vectorize loads/stores; // from such a struct, we read/write packed bits disagreeing with the; // unvectorized version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,loads,12,// Original loads are consecutive and does not require reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Availability,mask,masked,48,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Performance,load,loads,31,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,Availability,mask,masked,48,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Performance,load,loads,31,// Vectorizing non-consecutive loads with `llvm.masked.gather`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,avoid,avoid,73,// Need to cast all indices to the same type before vectorization to; // avoid crash.; // Required to be able to find correct matches between different gather; // nodes and reuse the vectorized values rather than trying to gather them; // again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Performance,load,load,12,// Check if load can be rewritten as load of vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,load,37,// Check if load can be rewritten as load of vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:207,Security,access,access,207,"// Assign to all items the initial value E + 1 so we can check if the extract; // instruction index was used already.; // Also, later we can check that all the indices are used and we have a; // consecutive access in the extract instructions, by checking that no; // element of CurrentOrder still has value E + 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Availability,mask,mask,18,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:106,Availability,mask,mask,106,/// Checks if the mask is an identity mask.; /// \param IsStrict if is true the function returns false if mask size does; /// not match vector size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,masks,33,"/// Tries to combine 2 different masks into single one.; /// \param LocalVF Vector length of the permuted input vector. \p Mask may; /// change the size of the vector, \p LocalVF is the original size of the; /// shuffled vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:123,Availability,Mask,Mask,123,"/// Tries to combine 2 different masks into single one.; /// \param LocalVF Vector length of the permuted input vector. \p Mask may; /// change the size of the vector, \p LocalVF is the original size of the; /// shuffled vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,Availability,mask,mask,192,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:424,Availability,mask,mask,424,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:515,Availability,mask,mask,515,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:643,Availability,mask,mask,643,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:900,Availability,mask,mask,900,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:991,Availability,mask,mask,991,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1190,Availability,Mask,Mask,1190,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1295,Availability,Mask,Mask,1295,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1310,Availability,mask,mask,1310,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1415,Deployability,update,updated,1415,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,reduce,reduce,37,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1078,Usability,simpl,simple,1078,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,"// Remember the identity or broadcast mask, if it is not a resizing; // shuffle. If no better candidates are found, this Op and Mask will be; // used in the final shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:128,Availability,Mask,Mask,128,"// Remember the identity or broadcast mask, if it is not a resizing; // shuffle. If no better candidates are found, this Op and Mask will be; // used in the final shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Availability,mask,mask,17,// Store current mask in the IdentityMask so later we did not lost; // this info if IdentityOp is selected as the best candidate for the; // permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Availability,Mask,Mask,83,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:199,Availability,mask,mask,199,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:234,Availability,mask,mask,234,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:314,Availability,mask,mask,314,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:444,Availability,mask,mask,444,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:480,Availability,mask,mask,480,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Availability,mask,mask,10,// Update mask and mark undef elems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update mask and mark undef elems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear known poison elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:126,Availability,Mask,Mask,126,"// namespace; /// Returns the cost of the shuffle instructions with the given \p Kind, vector; /// type \p Tp and optional \p Mask. Adds SLP-specifc cost estimation for insert; /// subvector pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,masks,19,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,Energy Efficiency,reduce,reduce,346,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,loads,37,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Performance,load,loads,76,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Performance,load,loads,94,"// Improve gather cost for gather of loads, if we can group some of the; // loads into vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Performance,load,loads,23,// Mark the vectorized loads so that we don't vectorize them; // again.; // TODO: better handling of loads with reorders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:101,Performance,load,loads,101,// Mark the vectorized loads so that we don't vectorize them; // again.; // TODO: better handling of loads with reorders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,Performance,load,loads,29,// Get the cost for gathered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:34,Performance,load,loads,34,// Exclude potentially vectorized loads from list of gathered; // scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Performance,load,loads,27,// The cost for vectorized loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Variab,VariableMask,2,/*VariableMask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Availability,Mask,Mask,2,/*Mask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,Mask,Mask,47,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Availability,mask,mask,80,"/// Adds the cost of reshuffling \p E1 and \p E2 (if present), using given; /// mask \p Mask, register number \p Part, that includes \p SliceSize; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Availability,Mask,Mask,88,"/// Adds the cost of reshuffling \p E1 and \p E2 (if present), using given; /// mask \p Mask, register number \p Part, that includes \p SliceSize; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:187,Availability,Mask,Mask,187,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:222,Availability,Mask,Mask,222,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:272,Safety,avoid,avoid,272,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Availability,mask,mask,90,// Found non-matching nodes - need to estimate the cost for the matched; // and transform mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Availability,mask,mask,9,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,mask,26,// Empty mask or identity mask are free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:237,Safety,avoid,avoid,237,"// If all users of instruction are going to be vectorized and this; // instruction itself is not going to be vectorized, consider this; // instruction as dead and remove its cost from the final cost of the; // vectorized tree.; // Also, avoid adjusting the cost for extractelements with multiple uses; // in different graph entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Integrability,depend,dependency,79,/// Checks if the specified entry \p E needs to be delayed because of its; /// dependency nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Adds 2 input vectors and the mask for their shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Safety,avoid,avoid,32,// FIXME: Need to find a way to avoid use of getNullValue here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Extend,ExtendingManyInputs,2,/*ExtendingManyInputs=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Deployability,update,update,58,"// If we have computed a smaller type for the expression, update VecTy so; // that the costs will be accurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Availability,mask,mask,38,// For stores the order is actually a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:146,Performance,load,loads,146,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:191,Performance,load,loads,191,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:254,Performance,load,load,254,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:283,Performance,load,loads,283,// Here we differentiate two cases: (1) when Ptrs represent a regular; // vectorization tree node (as they are pointer arguments of scattered; // loads) or (2) when Ptrs are the arguments of loads or stores being; // vectorized as plane wide unit-stride load/store since all the; // loads/stores are known to be from/to adjacent locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Performance,load,load,83,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:252,Performance,load,load,252,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:403,Performance,load,loads,403,// Case 2: estimate costs for pointer related costs when vectorizing to; // a wide load/store.; // Scalar cost is estimated as a set of pointers with known relationship; // between them.; // For vector code we will use BasePtr as argument for the wide load/store; // but we also need to account all the instructions which are going to; // stay in vectorized code due to uses outside of these scalar; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Usability,simpl,simplicity,7,// For simplicity assume Ptr to stay in vectorized code if it's not a; // GEP instruction. We don't care since it's cost considered free.; // TODO: We should check for any uses outside of vectorizable tree; // rather than just single use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Availability,mask,masked,83,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,loads,37,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Performance,load,load,97,// Case 1: Ptrs are the arguments of loads that we are going to transform; // into masked gather load intrinsic.; // All the scalar GEPs will be removed as a result of vectorization.; // For any external uses of some lanes extract element instructions will; // be generated (which cost is estimated separately).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Safety,safe,safely,19,"// Check if we can safely insert a subvector. If it is not possible, just; // generate a whole-sized vector and shuffle the source vector and the new; // subvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:39,Availability,mask,mask,39,// Align OffsetBeg to generate correct mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:2,Modifiability,Variab,VariableMask,2,/*VariableMask=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Availability,mask,masked,26,// If this node generates masked gather load then it is not a terminal node.; // Hence address operand cost is estimated separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Performance,load,load,40,// If this node generates masked gather load then it is not a terminal node.; // Hence address operand cost is estimated separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,error,error,32,// FIXME: Workaround for syntax error reported by MSVC buildbots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Usability,clear,clear,11,// Need to clear CommonCost since the final shuffle cost is included into; // vector cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Availability,mask,mask,14,// The opcode mask selects between the two opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Modifiability,extend,extended,28,// Check if the input is an extended load of the required or/shift expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Performance,load,load,37,// Check if the input is an extended load of the required or/shift expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:204,Energy Efficiency,reduce,reduce,204,"// Require that the total load bit width is a legal integer type.; // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.; // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Performance,load,load,26,"// Require that the total load bit width is a legal integer type.; // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.; // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Performance,load,load,77,// Everything matched - assume that we can fold the whole sequence using; // load combining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Performance,load,load-combined,92,// Peek through a final sequence of stores and check if all operations are; // likely to be load-combined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update LiveValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,masks,60,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:144,Availability,mask,masks,144,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:264,Availability,mask,mask,264,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:378,Availability,mask,masks,378,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:541,Availability,mask,mask,541,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:604,Availability,mask,mask,604,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:641,Availability,mask,mask,641,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:662,Availability,mask,masks,662,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:748,Availability,mask,masks,748,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:70,Performance,perform,performs,70,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:296,Performance,perform,perform,296,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:547,Performance,perform,perform,547,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:678,Performance,perform,perform,678,"// namespace; /// Does the analysis of the provided shuffle masks and performs the requested; /// actions on the vectors with the given shuffle masks. It tries to do it in; /// several steps.; /// 1. If the Base vector is not undef vector, resizing the very first mask to; /// have common VF and perform action for 2 input vectors (including non-undef; /// Base). Other shuffle masks are combined with the resulting after the 1 stage; /// and processed as a shuffle of 2 elements.; /// 2. If the Base is undef vector and have only 1 shuffle mask, perform the; /// action only for 1 vector with the given mask, if it is not the identity; /// mask.; /// 3. If > 2 masks are used, perform the remaining shuffle actions for 2; /// vectors, combing the masks properly between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Availability,mask,mask,103,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:128,Availability,mask,mask,128,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:49,Performance,perform,perform,49,"// Base is undef and only 1 vector is shuffled - perform the action only for; // single vector, if the mask is not the identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Availability,mask,mask,12,// Identity mask is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Performance,perform,perform,57,"// Base is undef and at least 2 input vectors shuffled - perform 2 vectors; // shuffles step by step, combining shuffle between the steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,masks,47,// Perform requested actions for the remaining masks/vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform requested actions for the remaining masks/vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,Safety,detect,detect,83,"// If found user is an insertelement, do not calculate extract cost but try; // to detect it as a final shuffled/identity match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,// Build the mask for the vectorized insertelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Modifiability,rewrite,rewrite,17,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:78,Modifiability,extend,extend,78,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:200,Modifiability,extend,extend,200,"// If we plan to rewrite the tree in a smaller type, we will need to sign; // extend the extracted value back to the original type. Here, we account; // for the extract and the added cost of the sign extend if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Energy Efficiency,reduce,reduced,7,"// Add reduced value cost, if resized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt was; /// successful, the matched scalars are replaced by poison values in \p VL for; /// future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Performance,perform,perform,22,// Check if better to perform a shuffle of 2 vectors or just of a single; // vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Availability,mask,mask,31,"// Restore unused scalars from mask, if some of the extractelements were not; // selected for shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,Safety,detect,detected,173,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt was; /// successful, the matched scalars are replaced by poison values in \p VL for; /// future analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:389,Energy Efficiency,schedul,scheduled,389,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:269,Integrability,depend,dependency,269,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:637,Integrability,depend,dependency,637,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:694,Integrability,depend,dependency,694,"// Argument InsertPt is an instruction where vector code for some other; // tree entry (one that shares one or more scalars with TE) is going to be; // generated. This lambda returns true if insertion point of vector code; // for the TE dominates that point (otherwise dependency is the other way; // around). The other node is not limited to be of a gather kind. Gather; // nodes are not scheduled and their vector code is inserted before their; // first user. If user is PHI, that is supposed to be at the end of a; // predecessor block. Otherwise it is the last instruction among scalars of; // the user node. So, instead of checking dependency between instructions; // themselves, we check dependency between their insertion points for vector; // code (since each scalar instruction ends up as a lane of a vector; // instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:95,Integrability,depend,depend,95,// If the user instruction is used for some reason in different; // vectorized nodes - make it depend on index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:88,Integrability,depend,depends,88,"// Check if the user node of the TE comes after user node of TEPtr,; // otherwise TEPtr depends on TE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Safety,avoid,avoid,21,// Keep the order to avoid non-determinism.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear undef scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Safety,avoid,avoid,35,// Keep the order of tree nodes to avoid non-determinism.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Safety,avoid,avoid,27,"// Same, keep the order to avoid non-determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,// Build a shuffle mask for better cost estimation and vector emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:205,Availability,mask,mask,205,"// Fix the entry number for the given scalar. If it is the first entry, set; // Pair.first to 0, otherwise to 1 (currently select at max 2 nodes).; // These indices are used when calculating final shuffle mask as the vector; // offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,mask,19,"// Build the final mask, check for the identity shuffle, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,Availability,mask,mask,27,// Clear the corresponding mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear the corresponding mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Usability,Clear,Clear,3,// Clear undef scalars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform operand reordering on the instructions in VL and return the reordered; // operands in Left and Right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,Energy Efficiency,schedul,scheduled,91,// Set the insert point to the beginning of the basic block if the entry; // should not be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Energy Efficiency,schedul,scheduled,77,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Energy Efficiency,schedul,schedule,175,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:271,Energy Efficiency,Schedul,ScheduleData,271,"// Find the last instruction. The common case should be that BB has been; // scheduled, and the last instruction is VL.back(). So we start with; // VL.back() and iterate over schedule data until we reach the end of the; // bundle. The end of the bundle is marked by null ScheduleData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:132,Availability,avail,available,132,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:119,Energy Efficiency,Schedul,ScheduleData,119,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:324,Energy Efficiency,Schedul,ScheduleData,324,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:359,Energy Efficiency,schedul,scheduling,359,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:199,Safety,abort,aborts,199,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:181,Performance,optimiz,optimize,181,// List of instructions/lanes from current block and/or the blocks which are; // part of the current loop. These instructions will be inserted at the end to; // make it possible to optimize loops and hoist invariant instructions out of; // the loops body with better chances for success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Availability,mask,masks,19,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:547,Availability,mask,mask,547,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:779,Availability,mask,mask,779,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1028,Availability,mask,mask,1028,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1285,Availability,mask,mask,1285,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,Energy Efficiency,reduce,reduce,346,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,/// Combined mask for all applied operands and masks. It is built during; /// analysis and actual emission of shuffle vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,mask,masks,47,/// Combined mask for all applied operands and masks. It is built during; /// analysis and actual emission of shuffle vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:184,Availability,mask,mask,184,"/// List of operands for the shuffle vector instruction. It hold at max 2; /// operands, if the 3rd is going to be added, the first 2 are combined into; /// shuffle with \p CommonMask mask, the first operand sets to be the; /// resulting shuffle and the second operand sets to be the newly added; /// operand. The \p CommonMask is transformed in the proper way after that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Availability,mask,mask,60,/// Creates shufflevector for the 2 operands with the given mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Availability,mask,mask,68,"/// Creates permutation of the single vector operand with the given mask, if; /// it is not identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:101,Availability,mask,mask,101,"/// Creates permutation of the single vector operand with the given mask, if; /// it is not identity mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,Availability,Mask,Mask,47,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,"// Perform multi-register vector shuffle, joining them into a single virtual; // long vector.; // Need to shuffle each part independently and then insert all this parts; // into a long virtual vector register, forming the original vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Integrability,depend,dependency,79,/// Checks if the specified entry \p E needs to be delayed because of its; /// dependency nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:59,Availability,mask,mask,59,/// Adds 2 input vectors (in form of tree entries) and the mask for their; /// shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:61,Availability,mask,mask,61,/// Adds single input vector (in form of tree entry) and the mask for its; /// shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Availability,mask,mask,33,/// Adds 2 input vectors and the mask for their shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Availability,mask,mask,42,/// Adds another one input vector and the mask for the shuffling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,Availability,mask,mask,139,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,Performance,perform,performed,84,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:171,Availability,mask,mask,171,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:370,Energy Efficiency,adapt,adapt,370,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:574,Energy Efficiency,reduce,reduced,574,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:370,Modifiability,adapt,adapt,370,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Deployability,update,update,11,"// Need to update the operand gather node, if actually the operand is not a; // vectorized node, but the buildvector/gather node, which matches one of; // the vectorized nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Availability,mask,mask,11,// Build a mask out of the reorder indices and reorder scalars per this; // mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:76,Availability,mask,mask,76,// Build a mask out of the reorder indices and reorder scalars per this; // mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Availability,mask,mask,15,// Restore the mask for previous partially matched values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Usability,simpl,simple,50,"// For undef values, try to replace them with the simple broadcast.; // We can do it if the broadcasted value is guaranteed to be; // non-poisonous, or by freezing the incoming scalar value first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Availability,mask,mask,43,"// Replace the undef by the poison, in the mask it is replaced by; // non-poisoned scalar already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,Availability,mask,mask,52,// Generate constants for final shuffle and build a mask for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,Availability,down,down,97,// Loads are inserted at the head of the tree because we don't want to; // sink them all the way down past store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Load,Loads,3,// Loads are inserted at the head of the tree because we don't want to; // sink them all the way down past store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:45,Performance,load,loads,45,// Use the minimum alignment of the gathered loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Availability,mask,mask,35,/// The parent vectors and shuffle mask for the given list of inserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,scheduled,22,// All blocks must be scheduled before any instructions are inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:66,Energy Efficiency,schedul,scheduling,66,"// Clean Entry-to-LastInstruction table. It can be affected after scheduling,; // need to rebuild it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:54,Integrability,depend,dependencies,54,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Safety,avoid,avoid,41,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:156,Integrability,depend,dependencies,156,"// If user is a PHI node, its vector code have to be inserted right before; // block terminator. Since the node was delayed, there were some unresolved; // dependencies at the moment when stab instruction was emitted. In a case; // when any of these dependencies turn out an operand of another PHI, coming; // from this same block, position of a stab instruction will become invalid.; // The is because source vector that supposed to feed this gather node was; // inserted at the end of the block [after stab instruction]. So we need; // to adjust insertion point again to the end of block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:250,Integrability,depend,dependencies,250,"// If user is a PHI node, its vector code have to be inserted right before; // block terminator. Since the node was delayed, there were some unresolved; // dependencies at the moment when stab instruction was emitted. In a case; // when any of these dependencies turn out an operand of another PHI, coming; // from this same block, position of a stab instruction will become invalid.; // The is because source vector that supposed to feed this gather node was; // inserted at the end of the block [after stab instruction]. So we need; // to adjust insertion point again to the end of block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Testability,stub,stub,15,"// Replace the stub vector node, if it was used before for one of the; // buildvector nodes already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Modifiability,extend,extend,22,"// If necessary, sign-extend or zero-extend ScalarRoot; // to the larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Modifiability,extend,extend,37,"// If necessary, sign-extend or zero-extend ScalarRoot; // to the larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:152,Deployability,update,update,152,"// If User == nullptr, the Scalar remains as scalar in vectorized; // instructions or is used as extra arg. Generate ExtractElement instruction; // and update the record for this scalar in ExternallyUsedValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,Deployability,update,update,15,// Required to update internally referenced instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Availability,mask,mask,13,// Build the mask for the vectorized insertelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform shuffling of the vectorize tree entries for better handling of; // external extracts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,mask,mask,32,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Availability,mask,mask,75,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,Usability,simpl,simple,42,// Do not create shuffle if the mask is a simple identity; // non-resizing mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,Performance,queue,queue,50,// Make a list of all reachable blocks in our CSE queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:161,Availability,mask,mask,161,"// Less defined shuffles can be replaced by the more defined copies.; // Between two shuffles one is less defined if it has the same vector operands; // and its mask indeces are the same as in the first one or undefs. E.g.; // shuffle %0, poison, <0, 0, 0, undef> is less defined than shuffle %0,; // poison, <0, 0, 0, 0>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Availability,mask,mask,32,// Count trailing undefs in the mask to check the final number of used; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Performance,Perform,Perform,3,// Perform O(N^2) search over the gather/shuffle sequences and merge identical; // instructions. TODO: We can further optimize this scan if we split the; // instructions into different buckets based on the insert lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Performance,optimiz,optimize,118,// Perform O(N^2) search over the gather/shuffle sequences and merge identical; // instructions. TODO: We can further optimize this scan if we split the; // instructions into different buckets based on the insert lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Energy Efficiency,schedul,scheduling,63,// Groups the instructions to a bundle (which is then a single scheduling entity); // and schedules instructions until the bundle gets ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Energy Efficiency,schedul,schedules,90,// Groups the instructions to a bundle (which is then a single scheduling entity); // and schedules instructions until the bundle gets ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,"// No need to schedule PHIs, insertelement, extractelement and extractvalue; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,Energy Efficiency,schedul,scheduling,7,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:160,Integrability,depend,dependencies,160,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,schedul,schedule,14,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:184,Energy Efficiency,schedul,schedule,184,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:238,Energy Efficiency,schedul,schedule,238,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,Integrability,depend,dependencies,75,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:160,Integrability,depend,dependencies,160,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,Energy Efficiency,schedul,scheduling,22,// Make sure that the scheduling region contains all; // instructions of the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Energy Efficiency,schedul,scheduling,10,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:321,Energy Efficiency,schedul,scheduling,321,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:163,Integrability,depend,dependencies,163,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:250,Integrability,depend,dependencies,250,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,Energy Efficiency,schedul,scheduled,23,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,Energy Efficiency,schedul,scheduled,86,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:155,Energy Efficiency,schedul,schedule,155,// A bundle member was scheduled as single instruction before and now; // needs to be scheduled as part of the bundle. We just get rid of the; // existing schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new ScheduleData for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,Schedul,ScheduleData,18,// Allocate a new ScheduleData for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Availability,down,down,17,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:120,Energy Efficiency,schedul,scheduling,120,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate data for non-schedulable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,schedul,schedulable,36,// No need to allocate data for non-schedulable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the linked list of memory accessing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Security,access,accessing,36,// Update the linked list of memory accessing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Integrability,depend,dependencies,24,// Handle def-use chain dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Integrability,depend,dependend,94,// Any instruction which isn't safe to speculate at the beginning of the; // block is control dependend on any early exit or non-willreturn call; // which proceeds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,Safety,safe,safe,31,// Any instruction which isn't safe to speculate at the beginning of the; // block is control dependend on any early exit or non-willreturn call; // which proceeds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Integrability,depend,dependent,40,// Everything past here must be control dependent on I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,Energy Efficiency,schedul,scheduled,60,"// If we have an inalloc alloca instruction, it needs to be scheduled; // after any preceeding stacksave. We also need to prevent any alloca; // from reordering above a preceeding stackrestore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Integrability,depend,dependent,41,"// Any allocas past here must be control dependent on I, and I; // must be memory dependend on BundleMember->Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Integrability,depend,dependend,82,"// Any allocas past here must be control dependent on I, and I; // must be memory dependend on BundleMember->Inst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:82,Performance,load,loads,82,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:243,Performance,load,loads,243,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:148,Safety,Avoid,Avoiding,148,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Integrability,depend,dependency,11,// Add the dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Integrability,depend,dependencies,21,// Handle the memory dependencies (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,Energy Efficiency,reduce,reduce,25,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Energy Efficiency,reduce,reduce,96,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,Safety,abort,aborts,235,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:146,Energy Efficiency,reduce,reduced,146,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Integrability,depend,dependencies,175,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:275,Integrability,depend,dependencies,275,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:372,Integrability,depend,dependencies,372,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:455,Integrability,depend,dependency,455,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:504,Integrability,depend,dependencies,504,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:552,Safety,abort,abort,552,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,Energy Efficiency,schedul,scheduling,37,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:77,Energy Efficiency,schedul,scheduling,77,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,schedul,scheduling,112,"// A key point - if we got here, pre-scheduling was able to find a valid; // scheduling of the sub-graph of the scheduling window which consists; // of all vector bundles and their transitive users. As such, we do not; // need to reschedule anything *outside of* that subgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Energy Efficiency,schedul,scheduling,16,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:142,Energy Efficiency,schedul,schedule,142,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:338,Energy Efficiency,schedul,schedule,338,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:315,Integrability,depend,dependence,315,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Deployability,update,updated,38,// Ensure that all dependency data is updated (for nodes in the sub-graph); // and fill the ready-list with initial instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Integrability,depend,dependency,19,// Ensure that all dependency data is updated (for nodes in the sub-graph); // and fill the ready-list with initial instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,schedul,scheduling,17,"// Do the ""real"" scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Energy Efficiency,schedul,scheduled,12,"// Move the scheduled instruction(s) to their dedicated places, if not; // there yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,schedul,schedulable,18,// Check that all schedulable entities got scheduled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Energy Efficiency,schedul,scheduled,43,// Check that all schedulable entities got scheduled,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Energy Efficiency,schedul,scheduling,19,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,Performance,load,loads,68,"// If V is not a store, we can traverse the expression tree to find loads; // that feed it. The type of the loaded value may indicate a more suitable; // width than V's type. We want to base the vector element size on the width; // of memory operations where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:108,Performance,load,loaded,108,"// If V is not a store, we can traverse the expression tree to find loads; // that feed it. The type of the loaded value may indicate a more suitable; // width than V's type. We want to base the vector element size on the width; // of memory operations where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Performance,load,loads,63,"// Traverse the expression tree in bottom-up order looking for loads. If we; // encounter an instruction we don't yet handle, we give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,Deployability,update,update,41,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Performance,load,load,35,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:89,Performance,load,loaded,89,"// If the current instruction is a load, update MaxWidth to reflect the; // width of the loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,Security,access,access,35,"// If we didn't encounter a memory access in the expression tree, or if we; // gave up for some reason, just return the width of V. Otherwise, return the; // maximum width we found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:125,Safety,safe,safe,125,// The maximum bit width required to represent all the values that can be; // demoted without loss of precision. It would be safe to truncate the roots; // of the expression to this width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Modifiability,extend,extended,33,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:92,Modifiability,extend,extended,92,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:176,Modifiability,extend,extend,176,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:164,Safety,safe,safely,164,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:193,Modifiability,extend,extend,193,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:301,Modifiability,extend,extend,301,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:725,Modifiability,extend,extending,725,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:181,Safety,safe,safely,181,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,Energy Efficiency,power,power-of-two,36,// Round MaxBitWidth up to the next power-of-two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:103,Deployability,Update,Update,103,// A general note: the vectorizer must use BoUpSLP::eraseInstruction() to; // delete instructions.; // Update DFS numbers now so that we can use them for ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Usability,clear,clear,21,// Start new block - clear the list of reduction roots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:156,Performance,load,loads,156,// Vectorize the index computations of getelementptr instructions. This; // is primarily intended to catch gather-like idioms ending at; // non-consecutive loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Energy Efficiency,power,power-of-,94,// FIXME: Is division-by-2 the correct step? Should we assert that the; // register size is a power-of-2?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:55,Testability,assert,assert,55,// FIXME: Is division-by-2 the correct step? Should we assert that the; // register size is a power-of-2?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:439,Energy Efficiency,reduce,reduce,439,"// Stores pair (first: index of the store into Stores array ref, address of; // which taken as base, second: sorted set of pairs {index, dist}, which are; // indices of stores in the set and their store location distances relative to; // the base address).; // Need to store the index of the very first store separately, since the set; // may be reordered after the insertion and the first store may be moved. This; // container allows to reduce number of calls of getPointersDiff() function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1594,Integrability,depend,dependencies,1594,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:324,Testability,log,logic,324,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1450,Testability,log,logic,1450,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,Safety,avoid,avoid,43,// Try to vectorize the first found set to avoid duplicate analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,Energy Efficiency,reduce,reduced,21,/// List of possibly reduced values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,Energy Efficiency,reduce,reduced,9,/// Maps reduced value to the corresponding reduction operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Performance,optimiz,optimization,18,/// Checks if the optimization of original scalar identity operations on; /// matched horizontal reductions is enabled and allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,Safety,safe,safe,33,"// And/or are potentially poison-safe logical patterns like:; // select x, y, false; // select x, true, y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,Testability,log,logical,38,"// And/or are potentially poison-safe logical patterns like:; // select x, y, false; // select x, true, y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Safety,safe,safe,10,"// Poison-safe 'or' takes the form: select X, true, Y; // To make that work with the normal operand processing, we skip the; // true value operand.; // TODO: Change the code and data structures to handle this without a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Testability,Log,Logical,3,// Logical or/and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:237,Performance,optimiz,optimizeGatherSequence,237,"// Try harder: look for min/max pattern based on instructions producing; // same values such as: select ((cmp Inst1, Inst2), Inst1, Inst2).; // During the intermediate stages of SLP, it's very common to have; // pattern like this (since optimizeGatherSequence is run only once; // at the end):; // %1 = extractelement <2 x i32> %a, i32 0; // %2 = extractelement <2 x i32> %a, i32 1; // %cond = icmp sgt i32 %1, %2; // %3 = extractelement <2 x i32> %a, i32 0; // %4 = extractelement <2 x i32> %a, i32 1; // %select = select i1 %cond, i32 %3, i32 %4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:53,Energy Efficiency,reduce,reduced,53,/// Expected number of uses for reduction operations/reduced values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,Energy Efficiency,reduce,reduced,90,"// Iterate through all the operands of the possible reduction tree and; // gather all the reduced values, sorting them by their value id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,Energy Efficiency,reduce,reduced,112,"// Checks if the operands of the \p TreeN instruction are also reduction; // operations or should be treated as reduced values or an extra argument,; // which is not part of the reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Energy Efficiency,reduce,reduced,124,"// If the edge is not an instruction, or it is different from the main; // reduction opcode or has too many uses - possible reduced value.; // Also, do not try to reduce const values, if the operation is not; // foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:163,Energy Efficiency,reduce,reduce,163,"// If the edge is not an instruction, or it is different from the main; // reduction opcode or has too many uses - possible reduced value.; // Also, do not try to reduce const values, if the operation is not; // foldable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,Energy Efficiency,reduce,reduced,18,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:79,Energy Efficiency,reduce,reduce,79,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:226,Performance,load,loads,226,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,Energy Efficiency,reduce,reduced,104,// Sort values by the total number of values kinds to start the reduction; // from the longest possible reduced values sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,Energy Efficiency,reduce,reduced,12,// Sort the reduced values by number of same/alternate opcode and/or pointer; // operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Energy Efficiency,reduce,reduce,57,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:80,Energy Efficiency,power,power-of-,80,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:99,Safety,safe,safely,99,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Energy Efficiency,reduce,reduced,13,// Track the reduced values in case if they are replaced by extractelement; // because of the vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:57,Testability,log,log,57,"// The same extra argument may be used several times, so log each attempt; // to use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,// Update the final value in the reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,reduce,reduced,17,"// Need to track reduced vals, they may be changed during vectorization of; // subvectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,Energy Efficiency,reduce,reduced,32,// List of the values that were reduced in other trees as part of gather; // nodes and thus requiring extract if fully vectorized in other trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Performance,optimiz,optimization,58,// Check if we support repeated scalar values processing (optimization of; // original scalar identity operations on matched horizontal reductions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,Energy Efficiency,reduce,reduced,24,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:129,Energy Efficiency,reduce,reduced,129,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:327,Performance,perform,performed,327,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Integrability,Depend,Dependency,3,"// Dependency in tree of the reduction ops - drop this attempt, try; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Deployability,Update,Update,3,"// Update LocalExternallyUsedValues for the scalar, replaced by; // extractelement instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,safe,safe,73,"// To prevent poison from leaking across what used to be sequential,; // safe, scalar boolean logic operations, the reduction operand must be; // frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Testability,log,logic,94,"// To prevent poison from leaking across what used to be sequential,; // safe, scalar boolean logic operations, the reduction operand must be; // frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:40,Energy Efficiency,reduce,reduced,40,"// Emit code to correctly handle reused reduced values, if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,Energy Efficiency,reduce,reduced,20,// Count vectorized reduced values to exclude them from final reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,Safety,avoid,avoid,63,"// Reorder operands of bool logical op in the natural order to avoid; // possible problem with poison propagation. If not possible to reorder; // (both operands are originally RHS), emit an extra freeze instruction; // for the LHS operand.; // I.e., if we have original code like this:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 RHS, i1 ?, i1 false; // Then, we swap LHS/RHS to create a new op that matches the poison; // semantics of the original code.; // If we have original code like this and both values could be poison:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 ?, i1 RHS, i1 false; // Then, we must freeze LHS in the new op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Testability,log,logical,28,"// Reorder operands of bool logical op in the natural order to avoid; // possible problem with poison propagation. If not possible to reorder; // (both operands are originally RHS), emit an extra freeze instruction; // for the LHS operand.; // I.e., if we have original code like this:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 RHS, i1 ?, i1 false; // Then, we swap LHS/RHS to create a new op that matches the poison; // semantics of the original code.; // If we have original code like this and both values could be poison:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 ?, i1 RHS, i1 false; // Then, we must freeze LHS in the new op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,Integrability,depend,dependencies,124,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,Safety,avoid,avoid,118,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,Safety,safe,safe,73,"// To prevent poison from leaking across what used to be; // sequential, safe, scalar boolean logic operations, the; // reduction operand must be frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:94,Testability,log,logic,94,"// To prevent poison from leaking across what used to be; // sequential, safe, scalar boolean logic operations, the; // reduction operand must be frozen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,Testability,Assert,Assert,110,"// The original scalar reduction is expected to have no remaining; // uses outside the reduction tree itself. Assert that we got this; // correct, replace internal uses with undef, and mark for eventual; // deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,Energy Efficiency,reduce,reduced,17,"// If all of the reduced values are constant, the vector cost is 0, since; // the reduction value can be calculated at the compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,Performance,optimiz,optimized,10,/// Emits optimized code for unique scalar value reused \p Cnt times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:518,Testability,test,test,518,"/// Recognize construction of vectors like; /// %ra = insertelement <4 x float> poison, float %s0, i32 0; /// %rb = insertelement <4 x float> %ra, float %s1, i32 1; /// %rc = insertelement <4 x float> %rb, float %s2, i32 2; /// %rd = insertelement <4 x float> %rc, float %s3, i32 3; /// starting from the last insertelement or insertvalue instruction.; ///; /// Also recognize homogeneous aggregates like {<2 x float>, <2 x float>},; /// {{float, float}, {float, float}}, [2 x {float, float}] and so on.; /// See llvm/test/Transforms/SLPVectorizer/X86/pr42022.ll for examples.; ///; /// Assume LastInsertInst is of InsertElementInst or InsertValueInst type.; ///; /// \return true if it matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,Performance,scalab,scalable,26,// Skip instructions with scalable type. The num of elements is unknown at; // compile-time for scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:96,Performance,scalab,scalable,96,// Skip instructions with scalable type. The num of elements is unknown at; // compile-time for scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,Safety,avoid,avoid,111,"// Skip if the incoming block is the current BB for now. Also, bypass; // unreachable IR for efficiency and to avoid crashing.; // TODO: Collect the skipped incoming values and try to vectorize them; // after processing BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:197,Safety,safe,safely,197,"// Try to vectorize chain in store, if this is the only store to the; // address in the block.; // TODO: This is just a temporarily solution to save compile time. Need; // to investigate if we can safely turn on slp-vectorize-hor-store; // instead to allow lookup for reduction chains in all non-vectorized; // stores (need to check side effects and compile time).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Performance,load,loads,175,"// Initialize a set a candidate getelementptrs. Note that we use a; // SetVector here to preserve program order. If the index computations; // are vectorizable and begin with loads, we want to minimize the chance; // of having to reorder them later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:115,Performance,optimiz,optimized,115,"// Some of the candidates may have already been vectorized after we; // initially collected them or their index is optimized to constant value.; // If so, they are marked as deleted, so remove them from the set of; // candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:394,Availability,down,down,394,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:175,Performance,load,loads,175,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:193,Performance,load,loads,193,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:239,Performance,perform,performed,239,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:434,Performance,load,loads,434,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:279,Safety,detect,detecting,279,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:335,Usability,simpl,simpler,335,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:210,Integrability,depend,dependecies,210,"// Reverse stores to do bottom-to-top analysis. This is important if the; // values are stores to the same addresses several times, in this case need; // to follow the stores order (reversed to meet the memory dependecies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Performance,Optimiz,Optimize,33,"//===------- VectorCombine.cpp - Optimize partial vector operations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:393,Performance,optimiz,optimizes,393,"//===------- VectorCombine.cpp - Optimize partial vector operations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:18,Performance,perform,perform,18,"/// If true, only perform beneficial early IR transforms. Do not introduce new; /// vector operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:108,Deployability,update,updated,108,"// TODO: Direct calls from the top-level ""run"" loop use a plain ""Instruction""; // parameter. That should be updated to specific sub-classes because the; // run loop was changed to dispatch on opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:90,Performance,load,load,90,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:99,Performance,load,load,99,// Do not widen load if atomic/volatile or under asan/hwasan/memtag/tsan.; // The widened load may load data from dirty regions or create data races; // non-existent in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Security,access,accesses,61,"// We are potentially transforming byte-sized (8-bit) memory accesses, so make; // sure we have all of our type-based constraints in place for this target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:66,Performance,load,load,66,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Safety,safe,safety,9,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:157,Deployability,update,updated,157,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:21,Performance,load,load,21,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:123,Performance,load,load,123,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:237,Performance,load,loading,237,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,Safety,safe,safe,13,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:115,Safety,safe,safe,115,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Availability,down,down,33,"// We want to shuffle the result down from a high element of a vector, so; // the offset must be positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Performance,load,load,9,"// If we load MinVecNumElts, will our target element still be loaded?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:62,Performance,load,loaded,62,"// If we load MinVecNumElts, will our target element still be loaded?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:3,Deployability,Update,Update,3,"// Update alignment with offset value. Note that the offset could be negated; // to more accurately represent ""(new) SrcPtr - Offset = (old) SrcPtr"", but; // negation does not change the result of the alignment calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,load,load,38,"// Original pattern: insertelt undef, load [free casts of] PtrOp, 0; // Use the greater of the alignment on the load or its source pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:112,Performance,load,load,112,"// Original pattern: insertelt undef, load [free casts of] PtrOp, 0; // Use the greater of the alignment on the load or its source pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// New pattern: load VecPtr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:85,Availability,mask,mask,85,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:36,Performance,load,loaded,36,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:182,Performance,load,loaded,182,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:259,Performance,load,loaded,259,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:404,Safety,avoid,avoid,404,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:127,Performance,perform,performance,127,// We can aggressively convert to the vector form because the backend can; // invert this transform if it does not result in a performance win.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:44,Performance,load,load,44,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:86,Performance,load,load,86,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:105,Performance,load,load,105,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Safety,safe,safe,9,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:14,Performance,load,loading,14,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:111,Performance,load,load,111,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:227,Performance,load,loaded,227,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Availability,mask,mask,33,// Allow a non-canonical shuffle mask that is choosing elements from op1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:39,Performance,load,load,39,// Original pattern: insert_subvector (load PtrOp); // This conservatively assumes that the cost of a subvector insert into an; // undef value is 0. We could add that cost if the cost model accurately; // reflects the real cost of that operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:16,Performance,load,load,16,// New pattern: load PtrOp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:127,Performance,perform,performance,127,// We can aggressively convert to the vector form because the backend can; // invert this transform if it does not result in a performance win.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:90,Performance,perform,performing,90,"// We are extracting from 2 different indexes, so one operand must be shuffled; // before performing a vector operation and/or extract. The more expensive; // extract will be replaced by a shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:118,Energy Efficiency,charge,charge,118,"// Handle a special case. If the 2 extracts are identical, adjust the; // formulas to account for that. The extra use charge allows for either the; // CSE'd pattern or an unoptimized form with identical values:; // opcode (extelt V, C), (extelt V, C) --> extelt (opcode V, V), C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:140,Availability,mask,mask,140,"// If we are extracting from 2 different indexes, then one operand must be; // shuffled before performing the vector operation. The shuffle mask is; // poison except for 1 lane that is being translated to the remaining; // extraction lane. Therefore, it is a splat shuffle. Ex:; // ShufMask = { poison, poison, 0, poison }; // TODO: The cost model has an option for a ""broadcast"" shuffle; // (splat-from-element-0), but no option for a more general splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:95,Performance,perform,performing,95,"// If we are extracting from 2 different indexes, then one operand must be; // shuffled before performing the vector operation. The shuffle mask is; // poison except for 1 lane that is being translated to the remaining; // extraction lane. Therefore, it is a splat shuffle. Ex:; // ShufMask = { poison, poison, 0, poison }; // TODO: The cost model has an option for a ""broadcast"" shuffle; // (splat-from-element-0), but no option for a more general splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:99,Performance,optimiz,optimization,99,// Aggressively form a vector op if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:15,Availability,mask,mask,15,"// The shuffle mask is poison except for 1 lane that is being translated; // to the new element index. Example for OldIndex == 2 and NewIndex == 0:; // ShufMask = { 2, poison, poison, poison }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce extract element costs by converting scalar compares to vector; /// compares followed by extract.; /// cmp (ext0 V0, C), (ext1 V1, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce extract element costs by converting scalar binops to vector; /// binops followed by extract.; /// bo (ext0 V0, C), (ext1 V1, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Safety,safe,safe,20,// All IR flags are safe to back-propagate because any potential poison; // created in unused vector elements is discarded by the extract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,Safety,safe,safe,13,"// It is not safe to transform things like div, urem, etc. because we may; // create undefined behavior when executing those on unknown vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:155,Energy Efficiency,reduce,reduced,155,"// If the scalar value 'I' is going to be re-inserted into a vector, then try; // to create an extract to that same element. The extract/insert can be; // reduced to a ""select shuffle"".; // TODO: If we add a larger pattern match that starts from an insert, this; // probably becomes unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:103,Availability,Mask,Mask,103,"// insertelt DestVec, (fneg (extractelt SrcVec, Index)), Index -->; // shuffle DestVec, (fneg SrcVec), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:160,Availability,mask,mask,160,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,scalab,scalable,38,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:81,Performance,scalab,scalable,81,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:169,Performance,scalab,scalable,169,"// 1) Do not fold bitcast shuffle for scalable type. First, shuffle cost for; // scalable type is unknown; Second, we cannot reason if the narrowed shuffle; // mask for scalable type is a splat or not.; // 2) Disallow non-vector casts.; // TODO: We could allow any shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:66,Availability,mask,mask,66,// The bitcast is from wide to narrow/equal elements. The shuffle mask can; // always be expanded to the equivalent form choosing narrower elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:69,Availability,mask,mask,69,// The bitcast is from narrow elements to wide elements. The shuffle mask; // must choose consecutive elements to allow casting first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Availability,Mask,MaskC,20,"// bitcast (shuf V, MaskC) --> shuf (bitcast V), MaskC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:49,Availability,Mask,MaskC,49,"// bitcast (shuf V, MaskC) --> shuf (bitcast V), MaskC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:187,Availability,down,down,187,/// VP Intrinsics whose vector operands are both splat values may be simplified; /// into the scalar version of the operation and the result splatted. This; /// can lead to scalarization down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:69,Usability,simpl,simplified,69,/// VP Intrinsics whose vector operands are both splat values may be simplified; /// into the scalar version of the operation and the result splatted. This; /// can lead to scalarization down the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:50,Safety,avoid,avoid,50,"// Check getSplatValue early in this function, to avoid doing unnecessary; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:122,Usability,simpl,simplification,122,"// For the binary VP intrinsics supported here, the result on disabled lanes; // is a poison value. For now, only do this simplification if all lanes; // are active.; // TODO: Relax the condition that all lanes are active by using insertelement; // on inactive lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:288,Modifiability,variab,variable,288,"// Match against one or both scalar values being inserted into constant; // vectors:; // vec_op VecC0, (inselt VecC1, V1, Index); // vec_op (inselt VecC0, V0, Index), VecC1; // vec_op (inselt VecC0, V0, Index), (inselt VecC1, V1, Index); // TODO: Deal with mismatched index constants and variable indexes?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,// Bail for single insertion if it is a load.; // TODO: Handle this once getVectorInstrCost can cost for load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:105,Performance,load,load,105,// Bail for single insertion if it is a load.; // TODO: Handle this once getVectorInstrCost can cost for load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,Safety,safe,safe,20,// All IR flags are safe to back-propagate. There is no potential for extra; // poison to be created by the scalar instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:98,Performance,optimiz,optimization,98,// Aggressively form vector ops if the cost is equal because the transform; // may enable further optimization.; // Codegen can reverse this transform (scalarize) if it was not profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:59,Safety,safe,safely,59,/// Helper class to indicate whether a vector index can be safely scalarized and; /// if a freeze needs to be inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Safety,Unsafe,Unsafe,23,/// Reset the state of Unsafe and clear ToFreze if set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:34,Usability,clear,clear,34,/// Reset the state of Unsafe and clear ToFreze if set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:28,Deployability,update,update,28,/// Freeze the ToFreeze and update the use in \p User to use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Security,access,access,61,// namespace; /// Check if it is legal to scalarize a memory access to \p VecTy at index \p; /// Idx. \p Idx must access a valid vector element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:114,Security,access,access,114,// namespace; /// Check if it is legal to scalarize a memory access to \p VecTy at index \p; /// Idx. \p Idx must access a valid vector element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:48,Performance,scalab,scalable,48,"// We do checks for both fixed vector types and scalable vector types.; // This is the number of elements of fixed vector types,; // or the minimum number of elements of scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:170,Performance,scalab,scalable,170,"// We do checks for both fixed vector types and scalable vector types.; // This is the number of elements of fixed vector types,; // or the minimum number of elements of scalable vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:35,Performance,load,load,35,"// Combine patterns like:; // %0 = load <4 x i32>, <4 x i32>* %a; // %1 = insertelement <4 x i32> %0, i32 %b, i32 1; // store <4 x i32> %1, <4 x i32>* %a; // to:; // %0 = bitcast <4 x i32>* %a to i32*; // %1 = getelementptr inbounds i32, i32* %0, i64 0, i64 1; // store i32 %b, i32* %1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,Performance,optimiz,optimize,9,"// Don't optimize for atomic/volatile load or store. Ensure memory is not; // modified between, vector type matches store size, and index is inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:38,Performance,load,load,38,"// Don't optimize for atomic/volatile load or store. Ensure memory is not; // modified between, vector type matches store size, and index is inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:28,Performance,load,loads,28,/// Try to scalarize vector loads feeding extractelement instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Safety,abort,aborted,23,"// If the transform is aborted, discard the ScalarizationResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:29,Performance,load,load,29,// Check if all users of the load are extracts with no memory modifications; // between the load and the extract. Compute the cost of both the original; // code and the scalarized version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:92,Performance,load,load,92,// Check if all users of the load are extracts with no memory modifications; // between the load and the extract. Compute the cost of both the original; // code and the scalarized version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:40,Performance,load,load,40,// Check if any instruction between the load and the extract may modify; // memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:39,Performance,load,loads,39,// Replace extracts with narrow scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:44,Safety,safe,safely,44,"// Splats don't change the order, so can be safely ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:12,Availability,mask,mask,12,// Find the mask from sorting the lanes into order. This is most likely to; // become a identity or concat mask. Undef elements are pushed to the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:107,Availability,mask,mask,107,// Find the mask from sorting the lanes into order. This is most likely to; // become a identity or concat mask. Undef elements are pushed to the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,Availability,mask,mask,61,// In the case of a truncating shuffle it's possible for the mask; // to have an index greater than the size of the resulting vector.; // This requires special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:57,Energy Efficiency,reduce,reduce,57,"// See if we can re-use foldSelectShuffle, getting it to reduce the size of; // the shuffle into a nicer order, as it can ignore the order of the shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:418,Energy Efficiency,reduce,reduce,418,"/// This method looks for groups of shuffles acting on binops, of the form:; /// %x = shuffle ...; /// %y = shuffle ...; /// %a = binop %x, %y; /// %b = binop %x, %y; /// shuffle %a, %b, selectmask; /// We may, especially if the shuffle is wider than legal, be able to convert; /// the shuffle to a form where only parts of a and b need to be computed. On; /// architectures with no obvious ""select"" shuffle, this can reduce the total; /// number of operations if the target reports them as cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:280,Availability,mask,mask,280,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:214,Energy Efficiency,reduce,reduce,214,"// For each of the output shuffles, we try to sort all the first vector; // elements to the beginning, followed by the second array elements at the; // end. If the binops are legalized to smaller vectors, this may reduce total; // number of binops. We compute the ReconstructMask mask needed to convert; // back to the original lane order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:106,Availability,mask,mask,106,"// Check the operands are the same as the original, or reversed (in which; // case we need to commute the mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:32,Availability,mask,mask,32,"// Calculate the reconstruction mask for this shuffle, as the mask needed to; // take the packed values from Op0/Op1 and reconstructing to the original; // order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:62,Availability,mask,mask,62,"// Calculate the reconstruction mask for this shuffle, as the mask needed to; // take the packed values from Op0/Op1 and reconstructing to the original; // order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:102,Usability,simpl,simplify,102,"// For reductions, we know that the lane ordering out doesn't alter the; // result. In-order can help simplify the shuffle away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:122,Performance,perform,performing,122,"// If the Maximum element used from V1 and V2 are not larger than the new; // vectors, the vectors are already packes and performing the optimization; // again will likely not help any further. This also prevents us from getting; // stuck in a cycle in case the costs do not also rule it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:137,Performance,optimiz,optimization,137,"// If the Maximum element used from V1 and V2 are not larger than the new; // vectors, the vectors are already packes and performing the optimization; // again will likely not help any further. This also prevents us from getting; // stuck in a cycle in case the costs do not also rule it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:43,Availability,mask,mask,43,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:116,Availability,down,down,116,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:63,Usability,simpl,simpler,63,"// Attempt to sort the inputs my ascending mask values to make simpler input; // shuffles and push complex shuffles down to the uses. We sort on the first; // of the two input shuffle orders, to try and get at least one input into a; // nice order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:17,Availability,mask,masks,17,"// Calculate the masks needed for the new input shuffles, which get padded; // with undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:84,Availability,mask,masks,84,// Get the costs of the shuffles + binops before and after with the new; // shuffle masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:96,Deployability,pipeline,pipeline,96,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:83,Performance,optimiz,optimization,83,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:163,Safety,avoid,avoid,163,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:29,Performance,scalab,scalable,29,// This transform works with scalable and fixed vectors; // TODO: Identify and allow other scalable transforms,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:91,Performance,scalab,scalable,91,// This transform works with scalable and fixed vectors; // TODO: Identify and allow other scalable transforms,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Deployability,pipeline,pipeline,23,"// If this is an early pipeline invocation of this pass, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:157,Safety,avoid,avoid,157,"// Otherwise, try folds that improve codegen but may interfere with; // early IR canonicalizations.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:504,Performance,optimiz,optimize,504,"//===- VPlan.cpp - Vectorizer Plan ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the LLVM vectorization plan. It represents a candidate for; /// vectorization, allowing to plan and optimize how to vectorize a given loop; /// before generating LLVM-IR.; /// The vectorizer uses vectorization plans to estimate the costs of potential; /// candidates and if profitable to execute the desired plan, generating vector; /// LLVM-IR code.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:9,Performance,Cache,Cache,9,// TODO: Cache created scalar values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:45,Modifiability,variab,variables,45,// Place the code for broadcasting invariant variables in the new preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:45,Modifiability,variab,variables,45,// Place the code for broadcasting invariant variables in the new preheader.; // Broadcast the scalar into all locations in the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:14,Performance,scalab,scalable,14,"// FIXME: For scalable vectors, assume vscale=1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:3,Deployability,Update,Update,3,// Update the branch instruction in the predecessor to branch to ExitBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:53,Performance,optimiz,optimization,53,"/* C */; // The last IR basic block is reused, as an optimization, in three cases:; // A. the first VPBB reuses the loop pre-header BB - when PrevVPBB is null;; // B. when the current VPBB has a single (hierarchical) predecessor which; // is PrevVPBB and the latter has a single (hierarchical) successor which; // both are in the same non-replicator region; and; // C. when the current VPBB is an entry of a region replica - where PrevVPBB; // is the exiting VPBB of this region from a previous instance, or the; // predecessor of this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:108,Deployability,update,updates,108,// Move the last step to the end of the latch block. This ensures; // consistent placement of all induction updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:76,Deployability,Update,Update,76,"// The vector body may be more than a single basic-block by this point.; // Update the dominator tree information inside the vector body by propagating; // it from header to latch, expecting only triangular control-flow, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:35,Performance,perform,performing,35,// Implement dot-formatted dump by performing plain-text dump into the; // temporary storage followed by some post-processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:36,Integrability,wrap,wrap,36,// Use no indentation as we need to wrap the lines into quotes ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:79,Deployability,update,update,79,"// If a user got removed after updating the current user, the next user to; // update will be moved to the current position, so we only need to; // increment the index if the number of users did not change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:515,Modifiability,inherit,inherit,515,"//===- VPlan.h - Represent A Vectorizer Plan --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the declarations of the Vectorization Plan base classes:; /// 1. VPBasicBlock and VPRegionBlock that inherit from a common pure virtual; /// VPBlockBase, together implementing a Hierarchical CFG;; /// 2. Pure virtual VPRecipeBase serving as the base class for recipes contained; /// within VPBasicBlocks;; /// 3. Pure virtual VPSingleDefRecipe serving as a base class for recipes that; /// also inherit from VPValue.; /// 4. VPInstruction, a concrete Recipe and VPUser modeling a single planned; /// instruction;; /// 5. The VPlan class holding a candidate for vectorization;; /// 6. The VPlanPrinter class providing a way to print a plan in dot format;; /// These are documented in docs/VectorizationPlan.rst.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:809,Modifiability,inherit,inherit,809,"//===- VPlan.h - Represent A Vectorizer Plan --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the declarations of the Vectorization Plan base classes:; /// 1. VPBasicBlock and VPRegionBlock that inherit from a common pure virtual; /// VPBlockBase, together implementing a Hierarchical CFG;; /// 2. Pure virtual VPRecipeBase serving as the base class for recipes contained; /// within VPBasicBlocks;; /// 3. Pure virtual VPSingleDefRecipe serving as a base class for recipes that; /// also inherit from VPValue.; /// 4. VPInstruction, a concrete Recipe and VPUser modeling a single planned; /// instruction;; /// 5. The VPlan class holding a candidate for vectorization;; /// 6. The VPlanPrinter class providing a way to print a plan in dot format;; /// These are documented in docs/VectorizationPlan.rst.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:145,Performance,scalab,scalable,145,"/// Returns a calculation for the total number of elements for a given \p VF.; /// For fixed width vectors this value is a constant, whereas for scalable; /// vectors it is an expression determined at runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Energy Efficiency,power,powers-of-,15,"/// A range of powers-of-2 vectorization factors with fixed start and; /// adjustable end. The range includes start and excludes end, e.g.,:; /// [1, 16) = {1, 2, 4, 8}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,Energy Efficiency,power,power,5,// A power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:5,Energy Efficiency,power,power,5,// A power of 2. If End <= Start range is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:246,Performance,scalab,scalable,246,"/// In what follows, the term ""input IR"" refers to code that is fed into the; /// vectorizer whereas the term ""output IR"" refers to code that is generated by; /// the vectorizer.; /// VPLane provides a way to access lanes in both fixed width and scalable; /// vectors, where for the latter the lane index sometimes needs calculating; /// as a runtime expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:209,Security,access,access,209,"/// In what follows, the term ""input IR"" refers to code that is fed into the; /// vectorizer whereas the term ""output IR"" refers to code that is generated by; /// the vectorizer.; /// VPLane provides a way to access lanes in both fixed width and scalable; /// vectors, where for the latter the lane index sometimes needs calculating; /// as a runtime expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:100,Performance,scalab,scalable,100,"/// For First, Lane is the index into the first N elements of a; /// fixed-vector <N x <ElTy>> or a scalable vector <vscale x N x <ElTy>>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:8,Performance,Scalab,ScalableLast,8,"/// For ScalableLast, Lane is the offset from the start of the last; /// N-element subvector in a scalable vector <vscale x N x <ElTy>>. For; /// example, a Lane of 0 corresponds to lane `(vscale - 1) * N`, a Lane of; /// 1 corresponds to `((vscale - 1) * N) + 1`, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:98,Performance,scalab,scalable,98,"/// For ScalableLast, Lane is the offset from the start of the last; /// N-element subvector in a scalable vector <vscale x N x <ElTy>>. For; /// example, a Lane of 0 corresponds to lane `(vscale - 1) * N`, a Lane of; /// 1 corresponds to `((vscale - 1) * N) + 1`, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Testability,assert,asserts,62,/// Returns a compile-time known value for the lane index and asserts if the; /// lane can only be calculated at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Performance,cache,cache,23,/// Maps the lane to a cache index based on \p VF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:46,Availability,down,down,46,"/// VPTransformState holds information passed down when ""executing"" a VPlan,; /// needed for generating the output IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:196,Performance,perform,performed,196,/// LoopVersioning. It's only set up (non-null) if memchecks were; /// used.; ///; /// This is currently only used to add no-alias metadata based on the; /// memchecks. The actually versioning is performed manually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:14,Integrability,wrap,wrapped,14,"/// Fixup the wrapped LCSSA phi node in the unique exit block. This simply; /// means we need to add the appropriate incoming value from the middle; /// block as exiting edges from the scalar epilogue loop (if present) are; /// already in place, and we exit the vector loop exclusively to the middle; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:68,Usability,simpl,simply,68,"/// Fixup the wrapped LCSSA phi node in the unique exit block. This simply; /// means we need to add the appropriate incoming value from the middle; /// block as exiting edges from the scalar epilogue loop (if present) are; /// already in place, and we exit the vector loop exclusively to the middle; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:241,Modifiability,inherit,inherit,241,/// VPRecipeBase is a base class modeling a sequence of one or more output IR; /// instructions. VPRecipeBase owns the VPValues it defines through VPDef; /// and is responsible for deleting its defined values. Single-value; /// recipes must inherit from VPSingleDef instead of inheriting from both; /// VPRecipeBase and VPValue separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:277,Modifiability,inherit,inheriting,277,/// VPRecipeBase is a base class modeling a sequence of one or more output IR; /// instructions. VPRecipeBase owns the VPValues it defines through VPDef; /// and is responsible for deleting its defined values. Single-value; /// recipes must inherit from VPSingleDef instead of inheriting from both; /// VPRecipeBase and VPValue separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:171,Modifiability,inherit,inherited,171,/// VPSingleDef is a base class for recipes for modeling a sequence of one or; /// more output IR that define a single result VPValue.; /// Note that VPRecipeBase must be inherited from before VPValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Performance,load,loads,58,"// TODO: Widened stores don't define a value, but widened loads do. Split; // the recipes to be able to make widened loads VPSingleDefRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:117,Performance,load,loads,117,"// TODO: Widened stores don't define a value, but widened loads do. Split; // the recipes to be able to make widened loads VPSingleDefRecipes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:19,Modifiability,extend,extending,19,"/// VPlan opcodes, extending LLVM IR with idiomatics instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Integrability,depend,depending,42,"// CallInst may or may not have a result, depending on the called function.; // Conservatively return calls have results for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:56,Security,access,accesses,56,"/// A recipe to compute the pointers for widened memory accesses of IndexTy for; /// all parts. If IsReverse is true, compute pointers for accessing the input in; /// reverse order per part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:139,Security,access,accessing,139,"/// A recipe to compute the pointers for widened memory accesses of IndexTy for; /// all parts. If IsReverse is true, compute pointers for accessing the input in; /// reverse order per part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:492,Usability,resume,resume,492,"/// A pure virtual base class for all recipes modeling header phis, including; /// phis for first order recurrences, pointer inductions and reductions. The; /// start value is the first operand of the recipe and the incoming value from; /// the backedge is the second operand.; ///; /// Inductions are modeled using the following sub-classes:; /// * VPCanonicalIVPHIRecipe: Canonical scalar induction of the vector loop,; /// starting at a specified value (zero for the main vector loop, the resume; /// value for the epilogue vector loop) and stepping by 1. The induction; /// controls exiting of the vector loop by comparing against the vector trip; /// count. Produces a single scalar PHI for the induction value per; /// iteration.; /// * VPWidenIntOrFpInductionRecipe: Generates vector values for integer and; /// floating point inductions with arbitrary start and step values. Produces; /// a vector PHI per-part.; /// * VPDerivedIVRecipe: Converts the canonical IV value to the corresponding; /// value of an IV with different start and step values. Produces a single; /// scalar value per iteration; /// * VPScalarIVStepsRecipe: Generates scalar values per-lane based on a; /// canonical or derived induction.; /// * VPWidenPointerInductionRecipe: Generate vector and scalar values for a; /// pointer induction. Produces either a vector PHI per-part or scalar values; /// per-lane based on the canonical induction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:4,Deployability,Update,Update,4,/// Update the start value of the recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:57,Availability,mask,mask-based,57,/// A recipe for vectorizing a phi-node as a sequence of mask-based select; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:86,Availability,mask,masks,86,"/// The blend operation is a User of the incoming values and of their; /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value; /// might be incoming with a full mask for which there is no VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:184,Availability,mask,mask,184,"/// The blend operation is a User of the incoming values and of their; /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value; /// might be incoming with a full mask for which there is no VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:103,Availability,mask,mask,103,"/// Return the number of incoming values, taking into account that a single; /// incoming value has no mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:11,Availability,mask,mask,11,/// Return mask number \p Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:258,Availability,mask,mask,258,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:75,Performance,load,load,75,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:109,Performance,load,load,109,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:84,Availability,mask,mask,84,/// Indicates if the interleave group is in a conditional block and requires a; /// mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Availability,mask,masked,62,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:104,Performance,load,loaded,104,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,"// Mask is optional and therefore the last, currently 2nd operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:68,Performance,load,load,68,"/// Return the VPValues stored by this interleave group. If it is a load; /// interleave group, return an empty ArrayRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:96,Availability,mask,mask,96,"// The first operand is the address, followed by the stored values, followed; // by an optional mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,load,22,"/// Generate the wide load or store, and shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:87,Performance,load,load,87,/// Returns the number of stored operands of this interleave group. Returns 0; /// for load interleave groups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:55,Performance,perform,performing,55,"/// A recipe to represent inloop reduction operations, performing a reduction on; /// a vector operand into a scalar value, and adding the result to a chain.; /// The Operands are {ChainOp, VecOp, [Condition]}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Energy Efficiency,reduce,reduced,42,/// The VPValue of the vector value to be reduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask of a predicated VPReplicateRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:66,Availability,mask,mask,66,/// A recipe for generating conditional branches on the bits of a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:25,Availability,mask,mask,25,// nullptr means all-one mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:66,Availability,mask,mask,66,/// Generate the extraction of the appropriate bit from the block mask and the; /// conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,// Mask is optional.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:122,Availability,Mask,Mask,122,/// VPPredInstPHIRecipe is a recipe for generating the phi nodes needed when; /// control converges back from a Branch-on-Mask. The phi nodes are needed in; /// order to merge values that are set under such a branch and feed their uses.; /// The phi nodes can be scalar or vector depending on the users of the value.; /// This recipe works in concert with VPBranchOnMaskRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:280,Integrability,depend,depending,280,/// VPPredInstPHIRecipe is a recipe for generating the phi nodes needed when; /// control converges back from a Branch-on-Mask. The phi nodes are needed in; /// order to merge values that are set under such a branch and feed their uses.; /// The phi nodes can be scalar or vector depending on the users of the value.; /// This recipe works in concert with VPBranchOnMaskRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:125,Availability,Mask,Mask,125,/// Construct a VPPredInstPHIRecipe given \p PredInst whose value needs a phi; /// nodes after merging back from a Branch-on-Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:129,Availability,mask,mask,129,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:184,Availability,mask,mask,184,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:26,Performance,load,load,26,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:105,Performance,load,load,105,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Performance,load,loaded-from,15,// Whether the loaded-from / stored-to addresses are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:27,Performance,load,loaded,27,// Whether the consecutive loaded/stored addresses are in reverse order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,Availability,mask,mask,15,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:58,Availability,mask,mask,58,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Availability,Mask,Mask,3,// Mask is optional and therefore the last operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,Security,access,accessed,23,/// Return the address accessed by this recipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,loaded-from,22,// Return whether the loaded-from / stored-to addresses are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:34,Performance,load,loaded,34,// Return whether the consecutive loaded/stored addresses are in reverse; // order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,Performance,load,load,22,/// Generate the wide load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Modifiability,variab,variable,42,"/// Generate a canonical vector induction variable of the vector loop, with",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:257,Modifiability,variab,variable,257,/// Canonical scalar induction phi of the vector loop. Starting at the specified; /// start value (either 0 or the resume value when vectorizing the epilogue; /// loop). VPWidenCanonicalIVRecipe represents the vector version of the; /// canonical induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:115,Usability,resume,resume,115,/// Canonical scalar induction phi of the vector loop. Starting at the specified; /// start value (either 0 or the resume value when vectorizing the epilogue; /// loop). VPWidenCanonicalIVRecipe represents the vector version of the; /// canonical induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:44,Availability,mask,mask,44,/// A recipe for generating the active lane mask for the vector loop that is; /// used to predicate the vector operations.; /// TODO: It would be good to use the existing VPWidenPHIRecipe instead and; /// remove VPActiveLaneMaskPHIRecipe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:29,Availability,mask,mask,29,/// Generate the active lane mask phi of the vector loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:50,Modifiability,variab,variable,50,/// A Recipe for widening the canonical induction variable of the vector loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:42,Modifiability,variab,variable,42,"/// Generate a canonical vector induction variable of the vector loop, with; /// start = {<Part*VF, Part*VF+1, ..., Part*VF+VF-1> for 0 <= Part < UF}, and; /// step = <VF*UF, VF*UF, ..., VF*UF>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:112,Deployability,Update,Update,112,"/// Create an IR BasicBlock to hold the output instructions generated by this; /// VPBasicBlock, and return it. Update the CFGState accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:96,Energy Efficiency,efficient,efficient,96,"/// VPlan models a candidate for vectorization, encoding various decisions take; /// to produce efficient output IR, including which branches, basic-blocks and; /// output IR instructions to generate, and their cost. VPlan holds a; /// Hierarchical-CFG of VPBasicBlocks and VPRegionBlocks rooted at an Entry; /// VPBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:28,Safety,safe,safe,28,"/// Indicates whether it is safe use the Value2VPValue mapping or if the; /// mapping cannot be used any longer, because it is stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:67,Integrability,wrap,wrapping,67,"/// Create initial VPlan skeleton, having an ""entry"" VPBasicBlock (wrapping; /// original scalar pre-header) which contains SCEV expansions that need to; /// happen before the CFG is modified; a VPBasicBlock for the vector; /// pre-header, followed by a region for the vector loop, followed by the; /// middle VPBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,Safety,safe,safe,62,"/// Mark the plan to indicate that using Value2VPValue is not safe any; /// longer, because it may be stale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:108,Safety,safe,safe,108,/// Returns the VPValue for \p V. \p OverrideAllowed can be used to disable; /// /// checking whether it is safe to query VPValues using IR Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:91,Security,access,accesses,91,/// Return an iterator range over \p Range which only includes \p BlockTy; /// blocks. The accesses are casted to \p BlockTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Safety,Avoid,Avoid,3,// Avoid releasing a pointer twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:69,Security,access,access,69,/// Reorder operands in the multi node to maximize sequential memory access; /// and commutative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:160,Performance,load,loads,160,/// Choose the best candidate to use for the lane after \p Last. The set of; /// candidates to choose from are values with an opcode matching \p Last's; /// or loads consecutive to \p Last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:141,Integrability,wrap,wrapping,141,"/// Get or create a VPValue that corresponds to the expansion of \p Expr. If \p; /// Expr is a SCEVConstant or SCEVUnknown, return a VPValue wrapping the live-in; /// value. Otherwise return a VPExpandSCEVRecipe to expand \p Expr. If \p Plan's; /// pre-header already contains a recipe expanding \p Expr, return it. If not,; /// create a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:272,Availability,down,down,272,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:223,Performance,load,load,223,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:330,Performance,cache,caches,330,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h:65,Usability,simpl,simply,65,"/// Index of the current successor. For VPBasicBlock nodes, this simply is the; /// index for the successor array. For VPRegionBlock, SuccessorIdx == 0 is; /// used for the region's entry block, and SuccessorIdx - 1 are the indices; /// for the successor array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h:301,Security,access,access,301,"// The following set of template specializations implement GraphTraits to treat; // any VPBlockBase as a node in a graph of VPBlockBases. It's important to note; // that VPBlockBase traits don't recurse into VPRegioBlocks, i.e., if the; // VPBlockBase is a VPRegionBlock, this specialization provides access to its; // successors/predecessors but not to the blocks inside the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:32,Usability,simpl,simplify,32,"// The input IR must be in loop-simplify form, ensuring a single predecessor; // for exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:8,Integrability,interface,interface,8,// Main interface to build the plain CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:176,Deployability,update,update,176,"// 0. Reuse the top-level region, vector-preheader and exit VPBBs from the; // skeleton. These were created directly rather than via getOrCreateVPBB(),; // revisit them now to update BB2VPBB. Note that header/entry and; // latch/exiting VPBB's of top-level region have yet to be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:82,Integrability,wrap,wraps,82,// ThePreheaderBB conceptually corresponds to both Plan.getPreheader() (which; // wraps the original preheader BB) and Plan.getEntry() (which represents the; // new vector preheader); here we're interested in setting BB2VPBB to the; // latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:10,Integrability,interface,interface,10,// Public interface to build a H-CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h:472,Integrability,interface,interface,472,"//===-- VPlanHCFGBuilder.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the VPlanHCFGBuilder class which contains the public; /// interface (buildHierarchicalCFG) to build a VPlan-based Hierarchical CFG; /// (H-CFG) for an incoming IR.; ///; /// A H-CFG in VPlan is a control-flow graph whose nodes are VPBasicBlocks; /// and/or VPRegionBlocks (i.e., other H-CFGs). The outermost H-CFG of a VPlan; /// consists of a VPRegionBlock, denoted Top Region, which encloses any other; /// VPBlockBase in the H-CFG. This guarantees that any VPBlockBase in the H-CFG; /// other than the Top Region will have a parent VPRegionBlock and allows us; /// to easily add more nodes before/after the main vector loop (such as the; /// reduction epilogue).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h:32,Deployability,update,update,32,/// Build H-CFG for TheLoop and update Plan accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:38,Modifiability,variab,variable,38,// Get first lane of vector induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:27,Integrability,depend,dependency,27,// FIXME: The cross-recipe dependency on VPReductionPHIRecipe is temporary; // and will be removed by breaking up the recipe further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:21,Modifiability,variab,variable,21,// Get its reduction variable descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:84,Modifiability,extend,extend,84,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.; // TODO: Handle this in truncateToMinBW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:34,Performance,perform,performed,34,"// If the vector reduction can be performed in a smaller type, we truncate; // then extend the loop exit value to enable InstCombine to evaluate the; // entire expression in the smaller type.; // TODO: Handle this in truncateToMinBW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce all of the unrolled parts into a single vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:67,Modifiability,extend,extend,67,"// If the reduction can be performed in a smaller type, we need to extend; // the reduction to the wider type before we branch to the original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:27,Performance,perform,performed,27,"// If the reduction can be performed in a smaller type, we need to extend; // the reduction to the wider type before we branch to the original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:41,Usability,simpl,simple,41,// This instruction is not vectorized by simple widening.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:212,Modifiability,variab,variable,212,"/// This function adds; /// (StartIdx * Step, (StartIdx + 1) * Step, (StartIdx + 2) * Step, ...); /// to each vector element of Val. The sequence starts at StartIndex.; /// \p Opcode is relevant for FP induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:82,Modifiability,variab,variable,82,// The value from the original loop to which we are mapping the new induction; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:80,Modifiability,variab,variables,80,"// We create vector phi nodes for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:141,Performance,perform,perform,141,"// We create vector phi nodes for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:49,Deployability,update,update,49,"// Create a vector splat to use in the induction update.; //; // FIXME: If the step is non-constant, we create the vector splat with; // IRBuilder. IRBuilder can constant-fold the multiply, but it doesn't; // handle a constant vector splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:50,Integrability,depend,depending,50,"// We may need to add the step a number of times, depending on the unroll; // factor. The last of those goes into the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:17,Deployability,update,update,17,"// Add induction update using an incorrect block temporarily. The phi node; // will be fixed after VPlan execution. Note that at this point the latch; // block cannot be used, as it does not exist yet.; // TODO: Model increment value in VPlan, by turning the recipe into a; // multi-def and a subclass of VPHeaderPHIRecipe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:77,Modifiability,variab,variable,77,"/// Compute scalar induction steps. \p ScalarIV is the scalar induction; /// variable on which to base the steps, \p Step is the size of the step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:80,Safety,avoid,avoid,80,"// TODO: Also use VPDerivedIVRecipe when only the step needs truncating, to; // avoid separate truncate here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:75,Modifiability,variab,variables,75,"// We build scalar steps for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:136,Performance,perform,perform,136,"// We build scalar steps for both integer and floating-point induction; // variables. Here, we determine the kind of arithmetic we will perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:86,Performance,scalab,scalable,86,"// The step returned by `createStepForVF` is a runtime-evaluated value; // when VF is scalable. Otherwise, it should be folded into a Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:303,Performance,optimiz,optimizations,303,"// We know that all PHIs in non-header blocks are converted into; // selects, so we don't have to worry about the insertion order and we; // can just use the builder.; // At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:265,Usability,simpl,simple,265,"// We know that all PHIs in non-header blocks are converted into; // selects, so we don't have to worry about the insertion order and we; // can just use the builder.; // At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:93,Availability,mask,mask,93,// Select between the current value and the previous incoming edge; // based on the incoming mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:21,Availability,mask,mask,21,"// Not a User of any mask: not really blending, this is a; // single-predecessor phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:12,Availability,mask,mask,12,// Block in mask is all-one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:26,Testability,log,logic,26,"// By current pack/unpack logic we need to generate only a single phi node: if; // a vector value for the predicated instruction exists at this point it means; // the instruction has vector users only, and a phi for the vector value is; // needed. In this case the recipe of the predicated instruction is marked to; // also do that packing, thereby ""hoisting"" the insert-element sequence.; // Otherwise, a phi node for the scalar value is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:30,Deployability,update,update,30,"// NOTE: Currently we need to update the value of the operand, so the next; // predicated iteration inserts its generated value in the correct vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:30,Deployability,update,update,30,"// NOTE: Currently we need to update the value of the operand, so the next; // predicated iteration inserts its generated value in the correct vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:7,Performance,load,loads,7,"// For loads, check that there are no instructions writing to memory in; // between them.; // TODO: we only have to forbid instructions writing to memory that could; // interfere with any of the loads in the bundle",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:195,Performance,load,loads,195,"// For loads, check that there are no instructions writing to memory in; // between them.; // TODO: we only have to forbid instructions writing to memory that could; // interfere with any of the loads in the bundle",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:65,Performance,load,loads,65,/// Returns true if A and B access sequential memory if they are loads or; /// stores or if they have identical opcodes otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:28,Security,access,access,28,/// Returns true if A and B access sequential memory if they are loads or; /// stores or if they have identical opcodes otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid visiting the same operands multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:45,Performance,load,loads,45,// Create VPWidenMemoryInstructionRecipe for loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:88,Availability,mask,mask,88,"/// If \p R is a region with a VPBranchOnMaskRecipe in the entry block, return; /// the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:112,Availability,mask,masks,112,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:147,Safety,avoid,avoid,147,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:37,Integrability,depend,dependencies,37,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:90,Integrability,depend,dependencies,90,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:137,Integrability,depend,dependence,137,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:176,Security,access,accesses,176,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:93,Deployability,Update,Update,93,// Move VPPredInstPHIRecipes from the merge block to the successor region's; // merge block. Update all users inside the successor region to use the; // original values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:77,Availability,mask,mask,77,// Replace predicated replicate recipe with a replicate recipe without a; // mask but in the replicate region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:52,Performance,optimiz,optimizations,52,// Record predicated instructions for above packing optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Availability,mask,masked,11,// Convert masked VPReplicateRecipes to if-then region blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:18,Availability,alive,alive,18,// A user keeps R alive:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,Availability,alive,alive,31,"// Having side effects keeps R alive, but do remove conditional assume; // instructions as their conditions may be flattened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:3,Deployability,Update,Update,3,// Update scalar users of IV to use Step instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:10,Usability,simpl,simplify,10,"// Try to simplify the branch condition if TC <= VF * UF when preparing to; // execute the plan for the main vector loop. We only do this if the; // terminator is:; // 1. BranchOnCount, or; // 2. BranchOnCond where the input is Not(ActiveLaneMask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:17,Usability,simpl,simplifications,17,// TODO: Further simplifications are possible; // 1. Replace inductions with constants.; // 2. Replace vector loop region with VPBasicBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,Integrability,depend,depend,31,"// The previous value must not depend on the users of the recurrence phi. In; // that case, FOR is not a fixed order recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Usability,simpl,simplify,11,/// Try to simplify recipe \p R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:19,Performance,cache,cached,19,// Verify that the cached type info is for both A and its users is still; // accurate by comparing it to freshly computed types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:11,Usability,simpl,simplify,11,/// Try to simplify the recipes in \p Plan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,Availability,redundant,redundant,215,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,Safety,redund,redundant,215,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:261,Usability,simpl,simplification,261,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:38,Safety,avoid,avoid,38,// Add an entry to ProcessedTruncs to avoid counting the same; // operand multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:7,Integrability,wrap,wrapping,7,"// Any wrapping introduced by shrinking this operation shouldn't be; // considered undefined behavior. So, we can't unconditionally copy; // arithmetic wrapping flags to VPW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:152,Integrability,wrap,wrapping,152,"// Any wrapping introduced by shrinking this operation shouldn't be; // considered undefined behavior. So, we can't unconditionally copy; // arithmetic wrapping flags to VPW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:3,Modifiability,Extend,Extend,3,// Extend result to original width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:164,Availability,mask,mask,164,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1068,Availability,mask,mask,1068,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1145,Availability,mask,mask-phi,1145,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1300,Availability,mask,mask,1300,"// Add a VPActiveLaneMaskPHIRecipe and related recipes to \p Plan and replace; // the loop terminator with a branch-on-cond recipe with the negated; // active-lane-mask as operand. Note that this turns the loop into an; // uncountable one. Only the existing terminator is replaced, all other existing; // recipes/users remain unchanged, except for poison-generating flags being; // dropped from the canonical IV increment. Return the created; // VPActiveLaneMaskPHIRecipe.; //; // The function uses the following definitions:; //; // %TripCount = DataWithControlFlowWithoutRuntimeCheck ?; // calculate-trip-count-minus-VF (original TC) : original TC; // %IncrementValue = DataWithControlFlowWithoutRuntimeCheck ?; // CanonicalIVPhi : CanonicalIVIncrement; // %StartV is the canonical induction start value.; //; // The function adds the following recipes:; //; // vector.ph:; // %TripCount = calculate-trip-count-minus-VF (original TC); // [if DataWithControlFlowWithoutRuntimeCheck]; // %EntryInc = canonical-iv-increment-for-part %StartV; // %EntryALM = active-lane-mask %EntryInc, %TripCount; //; // vector.body:; // ...; // %P = active-lane-mask-phi [ %EntryALM, %vector.ph ], [ %ALM, %vector.body ]; // ...; // %InLoopInc = canonical-iv-increment-for-part %IncrementValue; // %ALM = active-lane-mask %InLoopInc, TripCount; // %Negated = Not %ALM; // branch-on-cond %Negated; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:167,Availability,mask,mask,167,"// When the loop is guarded by a runtime overflow check for the loop; // induction variable increment by VF, we can increment the value before; // the get.active.lane mask and use the unmodified tripcount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:83,Modifiability,variab,variable,83,"// When the loop is guarded by a runtime overflow check for the loop; // induction variable increment by VF, we can increment the value before; // the get.active.lane mask and use the unmodified tripcount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:50,Availability,mask,mask,50,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:173,Availability,mask,mask,173,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:120,Modifiability,variab,variable,120,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:8,Safety,avoid,avoiding,8,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,Availability,mask,mask,26,// Create the active lane mask instruction in the VPlan preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:26,Availability,mask,mask,26,// Create the active lane mask for the next iteration of the loop before the; // original terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:80,Availability,mask,mask,80,// Replace the original terminator with BranchOnCond. We have to invert the; // mask here because a true condition means jumping to the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:148,Availability,mask,mask,148,"// Walk users of WideCanonicalIV and replace all compares of the form; // (ICMP_ULE, WideCanonicalIV, backedge-taken-count) with an; // active-lane-mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Usability,Clear,Clear,4,/// Clear NSW/NUW flags from reduction instructions if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Performance,Optimiz,Optimize,4,/// Optimize \p Plan based on \p BestVF and \p BestUF. This may restrict the; /// resulting plan to \p BestVF and \p BestUF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:25,Performance,optimiz,optimizations,25,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:83,Performance,optimiz,optimizations,83,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:136,Performance,optimiz,optimizations,136,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:46,Availability,mask,mask,46,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:106,Availability,mask,mask,106,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Integrability,Wrap,Wrap,4,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:120,Performance,Optimiz,Optimize,120,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:97,Availability,mask,mask,97,"/// Replace (ICMP_ULE, wide canonical IV, backedge-taken-count) checks with an; /// (active-lane-mask recipe, wide canonical IV, trip-count). If \p; /// UseActiveLaneMaskForControlFlow is true, introduce an; /// VPActiveLaneMaskPHIRecipe. If \p DataAndControlFlowWithoutRuntimeCheck is; /// true, no minimum-iteration runtime check will be created (during skeleton; /// creation) and instead it is handled using active-lane-mask. \p; /// DataAndControlFlowWithoutRuntimeCheck implies \p; /// UseActiveLaneMaskForControlFlow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:424,Availability,mask,mask,424,"/// Replace (ICMP_ULE, wide canonical IV, backedge-taken-count) checks with an; /// (active-lane-mask recipe, wide canonical IV, trip-count). If \p; /// UseActiveLaneMaskForControlFlow is true, introduce an; /// VPActiveLaneMaskPHIRecipe. If \p DataAndControlFlowWithoutRuntimeCheck is; /// true, no minimum-iteration runtime check will be created (during skeleton; /// creation) and instead it is handled using active-lane-mask. \p; /// DataAndControlFlowWithoutRuntimeCheck implies \p; /// UseActiveLaneMaskForControlFlow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Availability,Redundant,Redundant,59,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:25,Modifiability,extend,extends,25,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Safety,Redund,Redundant,59,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:57,Availability,redundant,redundant,57,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:96,Modifiability,variab,variables,96,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:57,Safety,redund,redundant,57,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:155,Deployability,update,update,155,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:223,Energy Efficiency,reduce,reduce,223,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:207,Performance,optimiz,optimization,207,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Availability,redundant,redundant,11,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,Safety,redund,redundant,11,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:21,Security,Access,Access,21,"// DESIGN PRINCIPLE: Access to the underlying IR must be strictly limited to; // the front-end and back-end of VPlan so that the middle-end is as; // independent as possible of the underlying IR. We grant access to the; // underlying IR using friendship. In that way, we should be able to use VPlan; // for multiple underlying IRs (Polly?) by providing a new VPlan front-end,; // back-end and analysis information for the new IR.; // Set \p Val as the underlying Value of this VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:205,Security,access,access,205,"// DESIGN PRINCIPLE: Access to the underlying IR must be strictly limited to; // the front-end and back-end of VPlan so that the middle-end is as; // independent as possible of the underlying IR. We grant access to the; // underlying IR using friendship. In that way, we should be able to use VPlan; // for multiple underlying IRs (Polly?) by providing a new VPlan front-end,; // back-end and analysis information for the new IR.; // Set \p Val as the underlying Value of this VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:273,Modifiability,inherit,inherit,273,"/// This class augments a recipe with a set of VPValues defined by the recipe.; /// It allows recipes to define zero, one or multiple VPValues. A VPDef owns; /// the VPValues it defines and is responsible for deleting its defined values.; /// Single-value VPDefs that also inherit from VPValue must make sure to inherit; /// from VPDef before VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:312,Modifiability,inherit,inherit,312,"/// This class augments a recipe with a set of VPValues defined by the recipe.; /// It allows recipes to define zero, one or multiple VPValues. A VPDef owns; /// the VPValues it defines and is responsible for deleting its defined values.; /// Single-value VPDefs that also inherit from VPValue must make sure to inherit; /// from VPDef before VPValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:38,Modifiability,inherit,inherit,38,// START: SubclassID for recipes that inherit VPHeaderPHIRecipe.; // VPHeaderPHIRecipe need to be kept together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:36,Modifiability,inherit,inherit,36,// END: SubclassID for recipes that inherit VPHeaderPHIRecipe; // END: Phi-like recipes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h:192,Modifiability,evolve,evolves,192,"/// \return an ID for the concrete type of this object.; /// This is used to implement the classof checks. This should not be used; /// for any other purpose, as the values may change as LLVM evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:46,Availability,mask,masks,46,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:64,Performance,cache,cache,64,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:229,Performance,cache,caches,229,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:103,Availability,mask,masked,103,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:205,Availability,mask,mask,205,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:17,Performance,load,load,17,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:93,Modifiability,variab,variable,93,/// Optimize the special case where the operand of \p I is a constant integer; /// induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:4,Performance,Optimiz,Optimize,4,/// Optimize the special case where the operand of \p I is a constant integer; /// induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:234,Performance,perform,performs,234,"/// Handle non-loop phi nodes. Return a VPValue, if all incoming values match; /// or a new VPBlendRecipe otherwise. Currently all such phi nodes are turned; /// into a sequence of select instructions as the vectorizer currently; /// performs full if-conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:187,Performance,perform,performed,187,/// Check if \p I has an opcode that can be widened and return a VPWidenRecipe; /// if it can. The function should only be called if the cost-model indicates; /// that widening should be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:144,Modifiability,inherit,inherit,144,/// Return a VPRecipeOrValueTy with VPRecipeBase * being set. This can be used to force the use as VPRecipeBase* for recipe sub-types that also inherit from VPValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:15,Availability,mask,mask,15,/// Create the mask for the vector loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:142,Availability,mask,mask,142,"/// A helper function that computes the predicate of the block BB, assuming; /// that the header block of the loop is set to True or the loop mask when; /// tail folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:24,Availability,mask,mask,24,/// Returns the *entry* mask for the block \p BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:71,Availability,mask,mask,71,"/// Build a VPReplicationRecipe for \p I. If it is predicated, add the mask as; /// last operand. Range.End may be decreased to ensure same recipe behavior; /// from \p Range.Start to \p Range.End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:30,Availability,error,error,30,// tryParse() returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Security,validat,validate,9,// Don't validate the input; trust the value supplied by the user.; // The motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:130,Security,access,access,130,// Don't validate the input; trust the value supplied by the user.; // The motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:181,Usability,Simpl,Simply,181,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes in; // the same buffer, however. Simply clear it out so we can overwrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:188,Usability,clear,clear,188,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes in; // the same buffer, however. Simply clear it out so we can overwrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:13,Deployability,Install,InstallDir,13,// Test that InstallDir is indeed there before keeping this index.; // Open the chosen key path remainder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:3,Testability,Test,Test,3,// Test that InstallDir is indeed there before keeping this index.; // Open the chosen key path remainder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:19,Deployability,install,installs,19,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:208,Deployability,install,installed,208,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:62,Integrability,depend,depend,62,"// Windows SDK 8.x installs libraries in a folder whose names depend on the; // version of the OS you're targeting. By default choose the newest, which; // usually corresponds to the version of the OS you've installed the SDK on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Security,validat,validate,9,// Don't validate the input; trust the value supplied by the user.; // The primary motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:138,Security,access,access,138,// Don't validate the input; trust the value supplied by the user.; // The primary motivation is to prevent unnecessary file and registry access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:9,Modifiability,variab,variables,9,// These variables are typically set by vcvarsall.bat; // when launching a developer command prompt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:19,Modifiability,variab,variable,19,"// If the previous variable isn't set but this one is, then we've found; // an older Visual Studio. This variable is set by newer Visual Studios too,; // so this check has to appear second.; // In older Visual Studios, the VC directory is the toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:105,Modifiability,variab,variable,105,"// If the previous variable isn't set but this one is, then we've found; // an older Visual Studio. This variable is set by newer Visual Studios too,; // so this check has to appear second.; // In older Visual Studios, the VC directory is the toolchain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:39,Modifiability,variab,variables,39,"// We couldn't find any VC environment variables. Let's walk through PATH and; // see if it leads us to a VC toolchain bin directory. If it does, pick the; // first one that we find.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:38,Testability,test,test,38,// cl.exe existing isn't a conclusive test for a VC toolchain; clang also; // has a cl.exe. So let's check for link.exe too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:225,Availability,error,error,225,"// _com_ptr_t will throw a _com_error if a COM calls fail.; // The LLVM coding standards forbid exception handling, so we'll have to; // stop them from being thrown in the first place.; // The destructor will put the regular error handler back when we leave; // this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:26,Modifiability,inherit,inheritable,26,"// Search for the closest inheritable default namespace, starting on (and; // including) the Node and traveling upwards through parent nodes. Returns; // nullptr if there are no inheritable default namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:178,Modifiability,inherit,inheritable,178,"// Search for the closest inheritable default namespace, starting on (and; // including) the Node and traveling upwards through parent nodes. Returns; // nullptr if there are no inheritable default namespaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:191,Availability,error,error,191,"// Merge the attributes of AdditionalNode into OriginalNode. If attributes; // with identical types are present, they are not duplicated but rather if; // their values are not consistent and error is thrown. In addition, the; // higher priority namespace is used for each attribute, EXCEPT in the case; // of merging two default namespaces and the lower priority namespace; // definition occurs closer than the higher priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:187,Modifiability,inherit,inherited,187,"// This covers the case where the incoming attribute has the higher; // priority. The higher priority namespace is applied in all cases; // EXCEPT when both of the namespaces are default inherited, and the; // closest inherited default is the lower priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:218,Modifiability,inherit,inherited,218,"// This covers the case where the incoming attribute has the higher; // priority. The higher priority namespace is applied in all cases; // EXCEPT when both of the namespaces are default inherited, and the; // closest inherited default is the lower priority one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:38,Modifiability,inherit,inherited,38,// Checks if this Node's namespace is inherited or one it defined itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:65,Modifiability,inherit,inherited,65,"// Check if this Node's namespace is a default namespace that it inherited, as; // opposed to defining itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:67,Availability,down,downwards,67,"// For the given explicit prefix-definition of a namespace, travel downwards; // from a node recursively, and for every implicit, inherited default usage of; // that namespace replace it with that explicit prefix use. This is important; // when namespace overriding occurs when merging, so that elements unique to a; // namespace will still stay in that namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:130,Modifiability,inherit,inherited,130,"// For the given explicit prefix-definition of a namespace, travel downwards; // from a node recursively, and for every implicit, inherited default usage of; // that namespace replace it with that explicit prefix use. This is important; // when namespace overriding occurs when merging, so that elements unique to a; // namespace will still stay in that namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:80,Modifiability,inherit,inherited,80,"// If a node as its own default namespace definition it clearly cannot have; // inherited the given default namespace, and neither will any of its; // children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:56,Usability,clear,clearly,56,"// If a node as its own default namespace definition it clearly cannot have; // inherited the given default namespace, and neither will any of its; // children.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:3,Performance,Perform,Perform,3,// Perform the namespace merge between two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:187,Availability,down,down,187,"// Check whether the original node or the incoming node has the higher; // priority namespace. Depending on which one is dominant, we will have; // to recursively apply namespace changes down to children of the original; // node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:95,Integrability,Depend,Depending,95,"// Check whether the original node or the incoming node has the higher; // priority namespace. Depending on which one is dominant, we will have; // to recursively apply namespace changes down to children of the original; // node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:462,Modifiability,inherit,inherited,462,"// In this case the node with a higher priority namespace did not have a; // default namespace definition, but the lower priority node did. In this; // case the new default namespace definition is copied. A side effect of; // this is that all children will suddenly find themselves in a different; // default namespace. To maintain correctness we need to ensure that all; // children now explicitly refer to the namespace that they had previously; // implicitly inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:89,Modifiability,inherit,inherited,89,"// This covers the case where the incoming node either has a prefix; // namespace, or an inherited default namespace. Since the namespace; // may not yet be defined in the original tree we do a searchOrDefine; // for it, and then set the namespace equal to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:158,Deployability,update,updated,158,"// In this case, the incoming node's default definition overrides; // the original default definition, all children who relied on that; // definition must be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:143,Deployability,update,updated,143,"// The original did not define a default definition, however the new; // default definition still applies to all children, so they must be; // updated to explicitly refer to the namespace they had previously; // been inheriting implicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:217,Modifiability,inherit,inheriting,217,"// The original did not define a default definition, however the new; // default definition still applies to all children, so they must be; // updated to explicitly refer to the namespace they had previously; // been inheriting implicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:19,Modifiability,inherit,inherited,19,// Ensure a node's inherited namespace is actually defined in the tree it; // resides in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:51,Integrability,depend,depending,51,"// Recursively merge the two given manifest trees, depending on which elements; // are of a mergeable type, and choose namespaces according to which have; // higher priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:42,Modifiability,inherit,inherit,42,"// libxml2 assumes that attributes do not inherit default namespaces, whereas; // the original mt.exe does make this assumption. This function reconciles; // this by setting all attributes to have the inherited default namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:201,Modifiability,inherit,inherited,201,"// libxml2 assumes that attributes do not inherit default namespaces, whereas; // the original mt.exe does make this assumption. This function reconciles; // this by setting all attributes to have the inherited default namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp:133,Testability,log,logs,133,"// Before we do any further reading, we should check whether we're at the end; // of the current buffer we're been consuming. In FDR logs version >= 3, we; // rely on the buffer extents record to determine how many bytes we should be; // considering as valid records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp:336,Performance,load,loaded,336,"//; // At the top level, we read one byte to determine the type of the record to; // create. This byte will comprise of the following bits:; //; // - offset 0: A '1' indicates a metadata record, a '0' indicates a function; // record.; // - offsets 1-7: For metadata records, this will indicate the kind of; // metadata record should be loaded.; //; // We read first byte, then create the appropriate type of record to consume; // the rest of the bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp:383,Testability,Test,Test,383,"//===- FDRTraceWriter.cpp - XRay FDR Trace Writer ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Test a utility that can write out XRay FDR Mode formatted trace files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRTraceWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:17,Availability,error,error,17,// FIXME: Create error types that encapsulate a bit more information than what; // StringError instances contain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:119,Modifiability,Extend,Extend,119,"// At this point we assume the file is an object file -- and if that doesn't; // work, we treat it as YAML.; // FIXME: Extend to support non-ELF and non-x86_64 binaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:13,Performance,load,load,13,// We try to load it as YAML if the ELF load didn't work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:40,Performance,load,load,40,// We try to load it as YAML if the ELF load didn't work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:23,Availability,error,error,23,// Report the ELF load error if YAML failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:18,Performance,load,load,18,// Report the ELF load error if YAML failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:48,Availability,error,error,48,"// If the file is empty, we return the original error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:26,Availability,error,errors,26,"// From this point on the errors will be only for the YAML parts, so we; // consume the errors at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:88,Availability,error,errors,88,"// From this point on the errors will be only for the YAML parts, so we; // consume the errors at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp:58,Availability,error,errors,58,"// We apply all of the visitors in order, and concatenate errors; // appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/LogBuilderConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp:431,Performance,latency,latency,431,"//===- Profile.cpp - XRay Profile Abstraction -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Profile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp:37,Testability,log,log,37,"// For version 4 onwards, of the FDR log, we want to also capture the CPU ID; // of the custom event.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/RecordInitializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:30,Performance,Load,Loading,30,"//===- Trace.cpp - XRay Trace Loading implementation. ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // XRay log reader implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:388,Testability,log,log,388,"//===- Trace.cpp - XRay Trace Loading implementation. ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // XRay log reader implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:90,Testability,log,logs,90,// Advance the offset pointer enough bytes to align to 32-byte records for; // basic mode logs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:12,Testability,log,log,12,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:164,Testability,log,log,164,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:664,Testability,log,logic,664,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:961,Testability,log,log,961,"/// Reads a log in FDR mode for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:1059,Testability,log,log,1059,"for version 1 of this binary format. FDR mode is; /// defined as part of the compiler-rt project in xray_fdr_logging.h, and such; /// a log consists of the familiar 32 bit XRayHeader, followed by sequences of; /// of interspersed 16 byte Metadata Records and 8 byte Function Records.; ///; /// The following is an attempt to document the grammar of the format, which is; /// parsed by this function for little-endian machines. Since the format makes; /// use of BitFields, when we support big-endian architectures, we will need to; /// adjust not only the endianness parameter to llvm's RecordExtractor, but also; /// the bit twiddling logic, which is consistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how many usable bytes are; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:2007,Usability,usab,usable,2007,"onsistent with the little-endian; /// convention that BitFields within a struct will first be packed into the; /// least significant bits the address they belong to.; ///; /// We expect a format complying with the grammar in the following pseudo-EBNF; /// in Version 1 of the FDR log.; ///; /// FDRLog: XRayFileHeader ThreadBuffer*; /// XRayFileHeader: 32 bytes to identify the log as FDR with machine metadata.; /// Includes BufferSize; /// ThreadBuffer: NewBuffer WallClockTime NewCPUId FunctionSequence EOB; /// BufSize: 8 byte unsigned integer indicating how large the buffer is.; /// NewBuffer: 16 byte metadata record with Thread Id.; /// WallClockTime: 16 byte metadata record with human readable time.; /// Pid: 16 byte metadata record with Pid; /// NewCPUId: 16 byte metadata record with CPUId and a 64 bit TSC reading.; /// EOB: 16 byte record in a thread buffer plus mem garbage to fill BufSize.; /// FunctionSequence: NewCPUId | TSCWrap | FunctionRecord; /// TSCWrap: 16 byte metadata record with a full 64 bit TSC reading.; /// FunctionRecord: 8 byte record with FunctionId, entry/exit, and TSC delta.; ///; /// In Version 2, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime NewCPUId; /// FunctionSequence; /// BufferExtents: 16 byte metdata record describing how many usable bytes are; /// in the buffer. This is measured from the start of the buffer; /// and must always be at least 48 (bytes).; ///; /// In Version 3, we make the following changes:; ///; /// ThreadBuffer: BufferExtents NewBuffer WallClockTime Pid NewCPUId; /// FunctionSequence; /// EOB: *deprecated*; ///; /// In Version 4, we make the following changes:; ///; /// CustomEventRecord now includes the CPU data.; ///; /// In Version 5, we make the following changes:; ///; /// CustomEventRecord and TypedEventRecord now use TSC delta encoding similar to; /// what FunctionRecord instances use, and we no longer need to include the CPU; /// id in the CustomEventRecord.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:12,Performance,load,load,12,// First we load the records into memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:58,Security,access,access,58,// Map the opened file into memory and use a StringRef to access it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:721,Availability,error,error,721,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:256,Performance,load,loading,256,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:581,Performance,load,loading,581,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:658,Performance,load,load,658,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:14,Safety,detect,detect,14,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:490,Availability,down,down,490,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:495,Availability,error,errors,495,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:505,Performance,optimiz,optimizations,505,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:20,Deployability,update,update,20,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:68,Deployability,update,update,68,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:10,Energy Efficiency,reduce,reduce,10,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:61,Modifiability,config,configure,61,"// If we don't have an override triple, use the first one to configure; // bugpoint, or use the host triple if none provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:167,Availability,failure,failure,167,"// This method takes the specified list of LLVM input files, attempts to load; // them, either as assembly or bitcode, then link them together. It returns; // true on failure (if, for example, an input bitcode file could not be; // parsed), and false on success.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:73,Performance,load,load,73,"// This method takes the specified list of LLVM input files, attempts to load; // them, either as assembly or bitcode, then link them together. It returns; // true on failure (if, for example, an input bitcode file could not be; // parsed), and false on success.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:3,Performance,Load,Load,3,// Load the first input file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:78,Modifiability,variab,variables,78,/// run - The top level method that is invoked after all of the instance; /// variables are set up from command line arguments.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:115,Performance,optimiz,optimization,115,"// If we're not running as a child, the first thing that we must do is; // determine what the problem is. Does the optimization series crash the; // compiler, or does it produce illegal code? We make the top-level; // decision by trying to run all of the passes on the input program,; // which should generate a bitcode file. If it does generate a bitcode; // file, then we know the compiler didn't crash, so try to diagnose a; // miscompilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:3,Testability,Test,Test,3,// Test to see if we have a code generator crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:490,Availability,down,down,490,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:495,Availability,error,errors,495,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:505,Performance,optimiz,optimizations,505,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:115,Modifiability,variab,variables,115,// Set up methods... these methods are used to copy information about the; // command line arguments into instance variables of BugDriver.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:78,Modifiability,variab,variables,78,/// run - The top level method that is invoked after all of the instance; /// variables are set up from command line arguments. The \p as_child argument; /// indicates whether the driver is to run in parent mode or child mode.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:117,Availability,down,down,117,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:58,Performance,optimiz,optimizer,58,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:126,Testability,test,testcase,126,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:117,Energy Efficiency,reduce,reduce,117,/// debugCodeGeneratorCrash - This method is called when the code generator; /// crashes on an input. It attempts to reduce the input as much as possible; /// while still causing the code generator to crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:45,Availability,down,down,45,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:120,Safety,safe,safe,120,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:59,Testability,test,testing,59,/// isExecutingJIT - Returns true if bugpoint is currently testing the JIT; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:20,Deployability,update,update,20,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:68,Deployability,update,update,68,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:10,Energy Efficiency,reduce,reduce,10,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:85,Testability,test,testing,85,/// Try to compile the specified module. This is used for code generation; /// crash testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:206,Availability,Error,Error,206,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:46,Safety,safe,safe,46,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:271,Availability,Error,Error,271,"/// This method executes the specified module and diffs the output against the; /// file specified by ReferenceOutputFile. If the output is different, 1 is; /// returned. If there is a problem with the code generator (e.g., llc; /// crashes), this will return -1 and set Error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:206,Integrability,depend,depends,206,/// This method clones the current Program and deletes the specified; /// instruction from the cloned module. It then runs a series of cleanup; /// passes (ADCE and SimplifyCFG) to eliminate any code which depends on the; /// value. The modified module is then returned.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:165,Usability,Simpl,SimplifyCFG,165,/// This method clones the current Program and deletes the specified; /// instruction from the cloned module. It then runs a series of cleanup; /// passes (ADCE and SimplifyCFG) to eliminate any code which depends on the; /// value. The modified module is then returned.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:47,Performance,perform,performs,47,"/// This method clones the current Program and performs a series of cleanups; /// intended to get rid of extra cruft on the module. If the; /// MayModifySemantics argument is true, then the cleanups is allowed to; /// modify how the code behaves.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:194,Performance,perform,performed,194,"/// Extract all but the specified basic blocks into their own functions. The; /// only detail is that M is actually a module cloned from the one the BBs are; /// in, so some mapping needs to be performed. If this operation fails for; /// some reason (ie the implementation is buggy), this function should return; /// null, otherwise it returns a new Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:141,Availability,failure,failure,141,"/// Carefully run the specified set of pass on the specified/ module,; /// returning the transformed module on success, or a null pointer on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:402,Integrability,message,message,402,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:153,Performance,optimiz,optimizations,153,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:189,Performance,optimiz,optimizer,189,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:115,Performance,optimiz,optimizer,115,"/// runPasses - Just like the method above, but this just returns true or; /// false indicating whether or not the optimizer crashed on the specified; /// input (true = crashed). Does not produce any output.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:388,Availability,failure,failure,388,"/// Take the specified pass list and create different combinations of passes; /// to compile the program with. Compile the program with each set and mark; /// test to see if it compiled correctly. If the passes compiled correctly; /// output nothing and rearrange the passes into a new order. If the passes; /// did not compile correctly, output the command required to recreate the; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:159,Testability,test,test,159,"/// Take the specified pass list and create different combinations of passes; /// to compile the program with. Compile the program with each set and mark; /// test to see if it compiled correctly. If the passes compiled correctly; /// output nothing and rearrange the passes into a new order. If the passes; /// did not compile correctly, output the command required to recreate the; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:71,Availability,error,error,71,"/// This writes the current ""Program"" to the named bitcode file. If an error; /// occurs, true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:68,Modifiability,variab,variables,68,/// PrintGlobalVariableList - prints out list of problematic global variables; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:49,Modifiability,variab,variable,49,"// DeleteGlobalInitializer - ""Remove"" the global variable by deleting its; // initializer, making it external.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:461,Availability,down,down,461,"//===- bugpoint.cpp - The LLVM Bugpoint utility ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is an automated compiler debugger tool. It is used to narrow; // down miscompilations and crash problems to a specific pass in the compiler,; // and the specific Module or Function input that is causing the problem.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:43,Deployability,update,update,43,// Set the default MemoryLimit. Be sure to update the flag's description if; // you change this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:35,Energy Efficiency,allocate,allocated,35,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:110,Energy Efficiency,allocate,allocate,110,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:91,Security,Sanitiz,Sanitizers,91,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:78,Safety,avoid,avoid,78,"// Bugpoint has the ability of generating a plethora of core files, so to; // avoid filling up the disk, we prevent it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:436,Availability,down,down,436,"//===- CrashDebugger.cpp - Debug compilation crashes ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the bugpoint internals that narrow down compilation crashes; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:171,Deployability,update,update,171,"// Return true iff running the ""removed"" passes succeeds, and running the; // ""Kept"" passes fail when run on the output of the ""removed"" passes. If we; // return true, we update the current module of bugpoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingGlobalInitializers,4,"/// ReduceCrashingGlobalInitializers - This works by removing global variable; /// initializers and seeing if the program still crashes. If it does, then we; /// keep that program and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:69,Modifiability,variab,variable,69,"/// ReduceCrashingGlobalInitializers - This works by removing global variable; /// initializers and seeing if the program still crashes. If it does, then we; /// keep that program and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:35,Modifiability,variab,variables,35,// Loop over and delete any global variables which we aren't supposed to be; // playing with...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:71,Modifiability,variab,variable,71,"// It crashed, keep the trimmed version...; // Make sure to use global variable pointers that point into the now-current; // module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingFunctions,4,"/// ReduceCrashingFunctions reducer - This works by removing functions and; /// seeing if the program still crashes. If it does, then keep the newer,; /// smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:28,Energy Efficiency,reduce,reducer,28,"/// ReduceCrashingFunctions reducer - This works by removing functions and; /// seeing if the program still crashes. If it does, then keep the newer,; /// smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingFunctionAttributes,4,"/// ReduceCrashingFunctionAttributes reducer - This works by removing; /// attributes on a particular function and seeing if the program still crashes.; /// If it does, then keep the newer, smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:37,Energy Efficiency,reduce,reducer,37,"/// ReduceCrashingFunctionAttributes reducer - This works by removing; /// attributes on a particular function and seeing if the program still crashes.; /// If it does, then keep the newer, smaller program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:77,Energy Efficiency,reduce,reducer,77,// Build up an AttributeList from the attributes we've been given by the; // reducer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:130,Availability,failure,failure,130,"// If the attribute list includes ""optnone"" we need to make sure it also; // includes ""noinline"" otherwise we will get a verifier failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:106,Availability,down,down,106,"/// Simplify the CFG without completely destroying it.; /// This is not well defined, but basically comes down to ""try to eliminate; /// unreachable blocks and constant fold terminators without deciding that; /// certain undefined behavior cuts off the program at the legs"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify the CFG without completely destroying it.; /// This is not well defined, but basically comes down to ""try to eliminate; /// unreachable blocks and constant fold terminators without deciding that; /// certain undefined behavior cuts off the program at the legs"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingBlocks,4,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:25,Energy Efficiency,reduce,reducer,25,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:265,Energy Efficiency,reduce,reduce,265,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:177,Usability,simpl,simplifycfg,177,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:296,Safety,risk,risk,296,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:11,Usability,Simpl,Simplifier,11,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingConditionals,4,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:31,Energy Efficiency,reduce,reducer,31,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:208,Energy Efficiency,reduce,reduce,208,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:118,Usability,simpl,simplifying,118,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:16,Energy Efficiency,reduce,reducer,16,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Usability,Simpl,SimplifyCFG,4,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:48,Usability,Simpl,SimplifyCFG,48,/// SimplifyCFG reducer - This works by calling SimplifyCFG on each basic block; /// in the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingInstructions,4,/// ReduceCrashingInstructions reducer - This works by removing the specified; /// non-terminator instructions and replacing them with undef.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:31,Energy Efficiency,reduce,reducer,31,/// ReduceCrashingInstructions reducer - This works by removing the specified; /// non-terminator instructions and replacing them with undef.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Energy Efficiency,Reduce,ReduceCrashingMetadata,4,/// ReduceCrashingMetadata reducer - This works by removing all metadata from; /// the specified instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:27,Energy Efficiency,reduce,reducer,27,/// ReduceCrashingMetadata reducer - This works by removing all metadata from; /// the specified instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:83,Safety,avoid,avoid,83,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:93,Safety,avoid,avoid,93,"// First collect all the metadata to delete in a vector, then; // delete them all at once to avoid invalidating the iterator",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of operands to named metadata nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,Energy Efficiency,reduce,reduce,14,// Now try to reduce the number of global variable initializers in the; // module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:42,Modifiability,variab,variable,42,// Now try to reduce the number of global variable initializers in the; // module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:57,Availability,error,error,57,"// TODO: Should we distinguish this with an ""interrupted error""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:387,Availability,failure,failure,387,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:434,Availability,failure,failure,434,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:330,Usability,Simpl,SimplifyCFG,330,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:49,Availability,error,error,49,// TODO: Should this be some kind of interrupted error?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:70,Energy Efficiency,reduce,reduce,70,"// Yup, it does, we delete the old module, and continue trying; // to reduce the testcase...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:81,Testability,test,testcase,81,"// Yup, it does, we delete the old module, and continue trying; // to reduce the testcase...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:120,Energy Efficiency,reduce,reduce,120,"/// DebugACrash - Given a predicate that determines whether a component crashes; /// on a program, try to destructively reduce the program while still keeping; /// the predicate true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:57,Modifiability,variab,variable,57,// See if we can get away with nuking some of the global variable initializers; // in the program...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,Energy Efficiency,reduce,reduce,14,// Now try to reduce the number of functions in the module to something small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:39,Energy Efficiency,reduce,reduce,39,"// For each remaining function, try to reduce that function's attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:183,Usability,simpl,simplifycfg,183,"// Attempt to delete entire basic blocks at a time to speed up; // convergence... this actually works by setting the terminator of the blocks; // to a return instruction then running simplifycfg, which can potentially; // shrinks the code dramatically quickly; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,Energy Efficiency,reduce,reduce,10,"// Try to reduce the amount of global metadata (particularly debug info),; // by dropping global named metadata that anchors them",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:23,Testability,test,testcase,23,// Try to clean up the testcase by running funcresolve and globaldce...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:26,Energy Efficiency,reduce,reduced,26,"// Yup, it does, keep the reduced version...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:107,Availability,down,down,107,"/// debugOptimizerCrash - This method is called when some pass crashes on input.; /// It attempts to prune down the testcase to something reasonable, and figure; /// out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:116,Testability,test,testcase,116,"/// debugOptimizerCrash - This method is called when some pass crashes on input.; /// It attempts to prune down the testcase to something reasonable, and figure; /// out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the list of passes which causes the optimizer to crash...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:46,Performance,optimiz,optimizer,46,// Reduce the list of passes which causes the optimizer to crash...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,Energy Efficiency,reduce,reduce,10,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:84,Energy Efficiency,reduce,reduce,84,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:129,Integrability,depend,dependencies,129,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:117,Energy Efficiency,reduce,reduce,117,/// debugCodeGeneratorCrash - This method is called when the code generator; /// crashes on an input. It attempts to reduce the input as much as possible; /// while still causing the code generator to crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:73,Testability,test,test,73,"// OutputType - Allow the user to specify the way code should be run, to test; // for miscompilation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:49,Integrability,interface,interface,49,// Create an instance of the AbstractInterpreter interface as specified on; // the command line,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:25,Integrability,message,messages,25,// Display informational messages on stdout instead of stderr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:11,Safety,safe,safe,11,"// In ""llc-safe"" mode, default to using LLC as the ""safe"" backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:52,Safety,safe,safe,52,"// In ""llc-safe"" mode, default to using LLC as the ""safe"" backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:19,Availability,error,error,19,"// If there was an error creating the selected interpreter, quit with error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:70,Availability,error,error,70,"// If there was an error creating the selected interpreter, quit with error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:69,Availability,Error,Error,69,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:86,Availability,error,error,86,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:139,Testability,test,testing,139,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:46,Safety,safe,safe,46,"/// Used to create reference output with the ""safe"" backend, if reference output; /// is not provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:156,Safety,avoid,avoid,156,"// Check to see if we created any new functions. If not, no loops were; // extracted and we should return null. Limit the number of loops we extract; // to avoid taking forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:53,Modifiability,variab,variable,53,"//; // DeleteGlobalInitializer - ""Remove"" the global variable by deleting its; // initializer,; // making it external.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:111,Modifiability,variab,variables,111,"/// SplitStaticCtorDtor - A module was recently split into two parts, M1/M2, and; /// M1 has all of the global variables. If M2 contains any functions that are; /// static ctors/dtors, we need to add an llvm.global_[cd]tors global to M2, and; /// prune appropriate entries out of M1s list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:38,Safety,Safe,Safe,38,// Remove the Test functions from the Safe module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:14,Testability,Test,Test,14,// Remove the Test functions from the Safe module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:14,Safety,Safe,Safe,14,// Remove the Safe functions from the Test module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:38,Testability,Test,Test,38,// Remove the Safe functions from the Test module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:24,Safety,safe,safe,24,"// If we keep it in the safe module, then delete it in the test module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:59,Testability,test,test,59,"// If we keep it in the safe module, then delete it in the test module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:584,Availability,failure,failure,584,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:404,Integrability,interface,interface,404,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,Performance,Optimiz,Optimizations,42,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:475,Performance,optimiz,optimizations,475,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:547,Performance,optimiz,optimizations,547,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:648,Performance,optimiz,optimizations,648,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,Performance,optimiz,optimizer,42,//; // Step 1: Randomize the order of the optimizer passes.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:19,Performance,optimiz,optimizer,19,//; // Step 2: Run optimizer passes on the program and check for success.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:27,Performance,optimiz,optimized,27,//; // Step 3: Compile the optimized code.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:28,Availability,down,down,28,"//===- ListReducer.h - Trim down list while retaining property --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class is to be used as a base class for operations that want to zero in; // on a subset of the input which still causes the bug we are tracking.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:6,Availability,failure,failure,6,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:35,Safety,detect,detected,35,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:82,Testability,test,test,82,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:100,Testability,test,testcase,100,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:129,Testability,test,test,129,"/// This virtual function should be overriden by subclasses to implement the; /// test desired. The testcase is only required to test to see if the Kept; /// list still satisfies the property, but if it is going to check the prefix; /// anyway, it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:30,Energy Efficiency,reduce,reduce,30,"/// This function attempts to reduce the length of the specified list while; /// still maintaining the ""test"" property. This is the core of the ""work""; /// that bugpoint does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:104,Testability,test,test,104,"/// This function attempts to reduce the length of the specified list while; /// still maintaining the ""test"" property. This is the core of the ""work""; /// that bugpoint does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:25,Availability,error,error,25,"// there's definitely an error, but we need to narrow it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:57,Availability,down,down,57,"// there's definitely an error, but we need to narrow it down",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:15,Availability,failure,failure,15,// there is no failure with the full set of passes/funcs!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:99,Safety,avoid,avoid,99,"// If the loop doesn't make satisfying progress, try shuffling.; // The purpose of shuffling is to avoid the heavy tails of the; // distribution (improving the speed of convergence).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:26,Availability,error,error,26,"// TODO: Previously, this error was ignored and we treated it as if; // shuffling hid the bug. This should really either be consumeError if; // that behaviour was sensible, or we should propagate the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:200,Availability,error,error,200,"// TODO: Previously, this error was ignored and we treated it as if; // shuffling hid the bug. This should really either be consumeError if; // that behaviour was sensible, or we should propagate the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:43,Safety,avoid,avoid,43,// Must increase the shuffling treshold to avoid the small; // probability of infinite looping without making progress.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:171,Testability,test,testing,171,"// Okay, we trimmed as much off the top and the bottom of the list as we; // could. If there is more than two elements in the list, try deleting; // interior elements and testing that.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:15,Availability,down,down,15,// We can trim down the list!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:18,Availability,failure,failure,18,// there are some failure and we've narrowed them down,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:50,Availability,down,down,50,// there are some failure and we've narrowed them down,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:404,Performance,optimiz,optimizer,404,"//===- Miscompilation.cpp - Debug program miscompilations -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizer and code generation miscompilation debugging; // support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:32,Testability,Test,TestResult,32,"// end anonymous namespace; /// TestResult - After passes have been split into a test group and a control; /// group, see if they still break the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:81,Testability,test,test,81,"// end anonymous namespace; /// TestResult - After passes have been split into a test group and a control; /// group, see if they still break the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:18,Safety,detect,detected,18,// Miscompilation detected!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:249,Deployability,update,update,249,"// If it is not broken with the kept passes, it's possible that the prefix; // passes must be run before the kept passes to break it. If the program; // WORKS after the prefix passes, but then fails if running the prefix AND; // kept passes, we can update our bitcode file to include the result of the; // prefix passes, then discard the prefix passes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Availability,error,error,35,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:54,Testability,test,test,54,// No miscompilation!; // Restore orig program & free test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:160,Availability,error,error,160,"// end anonymous namespace; /// Given two modules, link them together and run the program, checking to see; /// if the program matches the diff. If there is an error, return NULL. If not,; /// return the merged module. The Broken argument will be set to true if the; /// output is different. If the DeleteInputs argument is set to true then this; /// function deletes both input modules before it returns.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:33,Availability,error,error,33,// TODO: Shouldn't we thread the error up instead of exiting?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:136,Testability,test,test,136,"/// split functions in a Module into two groups: those that are under; /// consideration for miscompilation vs. those that are not, and test; /// accordingly. Each group of functions becomes a separate Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Testability,Test,Test,3,// Test to see if the function is misoptimized if we ONLY run it on the; // functions listed in Funcs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:48,Performance,optimiz,optimization,48,"// Create a clone for two reasons:; // * If the optimization passes delete any function, the deleted function; // will be in the clone and Funcs will still point to valid memory; // * If the optimization passes use interprocedural information to break; // a function, we want to continue with the original function. Otherwise; // we can conclude that a function triggers the bug when in fact one; // needs a larger set of original functions to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:191,Performance,optimiz,optimization,191,"// Create a clone for two reasons:; // * If the optimization passes delete any function, the deleted function; // will be in the clone and Funcs will still point to valid memory; // * If the optimization passes use interprocedural information to break; // a function, we want to continue with the original function. Otherwise; // we can conclude that a function triggers the bug when in fact one; // needs a larger set of original functions to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,Energy Efficiency,reduce,reduced,12,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:168,Energy Efficiency,reduce,reduces,168,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:49,Security,expose,exposed,49,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:170,Testability,test,test,170,"// Bugpoint is intentionally not very trusting of LLVM transformations. In; // particular, we're not going to assume that the loop extractor works, so; // we're going to test the newly loop extracted program to make sure nothing; // has broken. If something broke, then we'll inform the user and stop; // extraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:22,Testability,test,tester,22,"// Clone modules, the tester function will free them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:83,Availability,mask,masked,83,"// If the program is not still broken, then loop extraction did something; // that masked the error. Stop loop extraction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:94,Availability,error,error,94,"// If the program is not still broken, then loop extraction did something; // that masked the error. Stop loop extraction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:124,Availability,mask,mask,124,"// Okay, great! Now we know that we extracted a loop and that loop; // extraction both didn't break the program, and didn't mask the problem.; // Replace the current program with the loop extracted version, and try to; // extract another loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:86,Deployability,Update,Update,86,// All of the Function*'s in the MiscompiledFunctions list are in the old; // module. Update this list to include all of the functions in the; // optimized and loop extracted module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:146,Performance,optimiz,optimized,146,// All of the Function*'s in the MiscompiledFunctions list are in the old; // module. Update this list to include all of the functions in the; // optimized and loop extracted module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:32,Testability,Test,TestFuncs,32,"// end anonymous namespace; /// TestFuncs - Extract all blocks for the miscompiled functions except for the; /// specified blocks. If the problem still exists, return true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Testability,Test,Test,3,// Test to see if the function is misoptimized if we ONLY run it on the; // functions listed in Funcs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:129,Availability,down,down,129,"// Try the extraction. If it doesn't work, then the block extractor crashed; // or something, in which case bugpoint can't chase down this possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,Energy Efficiency,reduce,reduced,12,"/// Given a reduced list of functions that still expose the bug, extract as many; /// basic blocks from the region as possible without obscuring the bug.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:49,Security,expose,expose,49,"/// Given a reduced list of functions that still expose the bug, extract as many; /// basic blocks from the region as possible without obscuring the bug.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:16,Energy Efficiency,reduce,reducer,16,// Use the list reducer to identify blocks that can be extracted without; // obscuring the bug. The Blocks list will end up containing blocks that must; // be retained from the original program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Deployability,Update,Update,3,// Update the list of miscompiled functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:39,Availability,down,down,39,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,Performance,optimiz,optimization,79,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,Availability,failure,failure,79,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:106,Availability,down,down,106,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:26,Energy Efficiency,reduce,reduced,26,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:64,Testability,Test,Test,64,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is misoptimized. If so, return true. In any case, both module; /// arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:11,Performance,optimiz,optimization,11,"// Run the optimization passes on ToOptimize, producing a transformed version; // of the functions being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:105,Testability,test,tested,105,"// Run the optimization passes on ToOptimize, producing a transformed version; // of the functions being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:55,Testability,test,testing,55,/// Get the specified modules ready for code generator testing.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:41,Safety,Safe,Safe,41,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:68,Testability,stub,stub,68,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:84,Testability,Test,Test,84,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:54,Testability,test,test,54,// Create a NEW `main' function with same type in the test module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:40,Testability,test,test,40,"// Create an `oldmain' prototype in the test module, which will; // corresponds to the real main function in the same module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:67,Safety,Safe,Safe,67,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:253,Safety,Safe,Safe,253,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:138,Testability,test,test,138,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:53,Testability,test,test,53,// Don't forward functions which are external in the test module too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:63,Integrability,wrap,wrapper,63,"// Rewrite uses of F in global initializers, etc. to uses of a wrapper; // function that dynamically resolves the calls to F via our JIT API",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite uses of F in global initializers, etc. to uses of a wrapper; // function that dynamically resolves the calls to F via our JIT API",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,Performance,cache,cached,35,// Create a new global to hold the cached function pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:46,Integrability,rout,route,46,// Construct a new stub function that will re-route calls to F,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:19,Testability,stub,stub,19,// Construct a new stub function that will re-route calls to F,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:25,Performance,cache,cache,25,// Save the value in our cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:11,Integrability,wrap,wrapper,11,// Use the wrapper function instead of the old function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:64,Testability,Test,Test,64,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is miscompiled by the code generator under test. If so, return; /// true. In any case, both module arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:141,Testability,test,test,141,"/// This is the predicate function used to check to see if the ""Test"" portion of; /// the program is miscompiled by the code generator under test. If so, return; /// true. In any case, both module arguments are deleted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:46,Performance,load,loading,46,"// Run the code generator on the `Test' code, loading the shared library.; // The function returns whether or not the new output differs from reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:34,Testability,Test,Test,34,"// Run the code generator on the `Test' code, loading the shared library.; // The function returns whether or not the new output differs from reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:31,Availability,error,errors,31,"/// debugCodeGenerator - debug errors in LLC, LLI, or CBE.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:404,Integrability,interface,interface,404,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:7,Performance,Optimiz,OptimizerDriver,7,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:679,Performance,optimiz,optimizations,679,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:58,Safety,safe,safely,58,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:473,Security,threat,threat,473,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:71,Availability,error,error,71,"/// This writes the current ""Program"" to the named bitcode file. If an error; /// occurs, true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:66,Integrability,message,message,66,"// Output the input to the current pass to a bitcode file, emit a message; // telling the user how to reproduce it: opt -foo blah.bc; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:401,Integrability,message,message,401,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:152,Performance,optimiz,optimizations,152,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:188,Performance,optimiz,optimizer,188,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:408,Integrability,interface,interfaces,408,"//===-- ToolRunner.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces described in the ToolRunner.h file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:64,Integrability,interface,interface,64,/// RunProgramWithTimeout - This function provides an alternate interface; /// to the sys::Program::ExecuteAndWait interface.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:115,Integrability,interface,interface,115,/// RunProgramWithTimeout - This function provides an alternate interface; /// to the sys::Program::ExecuteAndWait interface.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:224,Availability,error,error,224,/// RunProgramRemotelyWithTimeout - This function runs the given program; /// remotely using the given remote client and the sys::Program::ExecuteAndWait.; /// Returns the remote program exit code or reports a remote client error if it; /// fails. Remote client is required to return 255 if it failed or program exit; /// code otherwise.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:7,Availability,error,error,7,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:13,Integrability,message,message,13,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:37,Availability,error,error,37,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:43,Integrability,message,messages,43,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:48,Availability,error,error,48,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:54,Integrability,message,messages,54,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // LLI Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:371,Availability,error,errors,371,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:145,Integrability,interface,interface,145,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:334,Integrability,wrap,wrapper,334,"//===---------------------------------------------------------------------===//; // Custom compiler command implementation of AbstractIntepreter interface; //; // Allows using a custom command for compiling the bitcode, thus allows, for; // example, to compile a bitcode fragment without linking or executing, then; // using a custom wrapper script to check for compiler errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:146,Integrability,interface,interface,146,"//===---------------------------------------------------------------------===//; // Custom execution command implementation of AbstractIntepreter interface; //; // Allows using a custom command for executing the bitcode, thus allows,; // for example, to invoke a cross compiler for code generation followed by; // a simulator that executes the generated binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:476,Usability,Simpl,Simple,476,"// Tokenize the CommandLine to the command and the args to allow; // defining a full command line as the command instead of just the; // executed program. We cannot just pass the whole string after the command; // as a single argument because then the program sees only a single; // command line argument (with spaces in it: ""foo bar"" instead; // of ""foo"" and ""bar"").; //; // Spaces are used as a delimiter; however repeated, leading, and trailing; // whitespace are ignored. Simple escaping is allowed via the '\'; // character, as seen below:; //; // Two consecutive '\' evaluate to a single '\'.; // A space after a '\' evaluates to a space that is not interpreted as a; // delimiter.; // Any other instances of the '\' character are removed.; //; // Example:; // '\\' -> '\'; // '\ ' -> ' '; // 'exa\mple' -> 'example'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:126,Integrability,interface,interface,126,//===----------------------------------------------------------------------===//; // LLC Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // JIT Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,Safety,safe,safe,296,"// Output to the right file...; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the program a bit...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:39,Safety,timeout,timeout,39,// Treat a signal (usually SIGSEGV) or timeout as part of the program output; // so that crash-causing miscompilation is handled seamlessly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:29,Energy Efficiency,Power,PowerPC,29,// `-dynamiclib' for MacOS X/PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the program a bit.; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,Safety,safe,safe,296,"// Optimize the program a bit.; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:531,Integrability,interface,interface,531,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:393,Security,expose,exposes,393,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:495,Security,expose,exposes,495,"//===-- tools/bugpoint/ToolRunner.h -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an abstraction around a platform C compiler, used to; // compile C and assembly code. It also exposes an ""AbstractIntepreter""; // interface, which is used to execute code using one of the LLVM execution; // engines.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:373,Performance,load,loaded,373,"/// ExecuteProgram - Execute the program specified by ""ProgramFile"" (which is; /// either a .s file, or a .c file, specified by FileType), with the specified; /// arguments. Standard input is specified with InputFile, and standard; /// Output is captured to the specified OutputFile location. The SharedLibs; /// option specifies optional native shared objects that can be loaded into; /// the program for execution.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:212,Integrability,interface,interface,212,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:265,Integrability,interface,interface,265,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:258,Usability,simpl,simple,258,//===---------------------------------------------------------------------===//; /// AbstractInterpreter Class - Subclasses of this class are used to execute; /// LLVM bitcode in a variety of ways. This abstract interface hides this; /// complexity behind a simple interface.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:118,Availability,error,error,118,"/// Compile the specified program from bitcode to code understood by the CC; /// driver (either C or asm). Returns an error if the code generator fails,,; /// otherwise, the type of code emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:169,Availability,Error,Error,169,"/// ExecuteProgram - Run the specified bitcode file, emitting output to the; /// specified filename. This sets RetVal to the exit code of the program or; /// returns an Error if a problem was encountered that prevented execution of; /// the program.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:125,Integrability,interface,interface,125,//===---------------------------------------------------------------------===//; // LLC Implementation of AbstractIntepreter interface; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:247,Availability,error,error,247,"/// Find the first executable file \ExeName, either in the user's PATH or,; /// failing that, in the same directory as argv[0]. This allows us to find; /// another LLVM tool if it is built in the same directory. If no executable is; /// found, an error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:487,Availability,down,down,487,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:7,Testability,Test,TestPasses,7,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:47,Testability,test,test,47,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:438,Testability,test,test,438,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:492,Testability,test,testcases,492,"//===- TestPasses.cpp - ""buggy"" passes used to test bugpoint --------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains ""buggy"" passes that are used to test bugpoint, to check; // that it is narrowing down testcases correctly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:40,Testability,test,test,40,/// CrashOnCalls - This pass is used to test bugpoint. It intentionally; /// crashes on any call instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:39,Testability,test,test,39,"/// DeleteCalls - This pass is used to test bugpoint. It intentionally; /// deletes some call instructions, ""misoptimizing"" the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:43,Testability,test,test,43,/// CrashOnDeclFunc - This pass is used to test bugpoint. It intentionally; /// crashes if the module has an undefined function (ie a function that is; /// defined in an external module).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp:40,Testability,test,test,40,/// CrashOnOneCU - This pass is used to test bugpoint. It intentionally; /// crashes if the Module has two or more compile units,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/TestPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:10,Performance,load,load,10,// Try to load archive and force it to be memory mapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:37,Integrability,depend,depending,37,"// Load one or more archive buffers, depending on whether we're dealing with; // a fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:3,Performance,Load,Load,3,"// Load one or more archive buffers, depending on whether we're dealing with; // a fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:19,Performance,load,load,19,"// Finally, try to load the archives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:10,Performance,load,load,10,// Try to load regular binary and force it to be memory mapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:36,Integrability,depend,depending,36,"// Load one or more object buffers, depending on whether we're dealing with a; // fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:3,Performance,Load,Load,3,"// Load one or more object buffers, depending on whether we're dealing with a; // fat binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:11,Performance,cache,cache,11,// Try the cache first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:53,Performance,cache,cache,53,"// Create a new ObjectEntry, but don't add it to the cache yet. Loading of; // the archive members might fail and we don't want to lock the whole archive; // during this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:64,Performance,Load,Loading,64,"// Create a new ObjectEntry, but don't add it to the cache yet. Loading of; // the archive members might fail and we don't want to lock the whole archive; // during this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:77,Performance,cache,cached,77,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:105,Performance,load,load,105,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:121,Security,access,accessing,121,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:20,Availability,error,error,20,// Don't return the error here: maybe the file wasn't an archive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:42,Performance,cache,cached,42,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:71,Performance,load,load,71,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:108,Performance,cache,cache,108,"// If this is an object, we might have it cached. If not we'll have to load; // it from the file system and cache it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:43,Security,access,accessing,43,"//===-- BinaryHolder.h - Utility class for accessing binaries -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a utility that aims to be a dropin replacement for; // Darwin's dsymutil.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:181,Security,access,accessing,181,/// The BinaryHolder class is responsible for creating and owning; /// ObjectFiles and their underlying MemoryBuffers. It differs from a simple; /// OwningBinary in that it handles accessing and caching of archives and its; /// members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:137,Usability,simpl,simple,137,/// The BinaryHolder class is responsible for creating and owning; /// ObjectFiles and their underlying MemoryBuffers. It differs from a simple; /// OwningBinary in that it handles accessing and caching of archives and its; /// members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:25,Performance,cache,cached,25,"/// Base class shared by cached entries, representing objects and archives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cached,4,/// Cached entry holding one or more (in case of a fat binary) object files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Load,Load,4,/// Load the given object binary in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access all owned ObjectFiles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:127,Availability,Error,Error,127,"/// Access to a derived version of all the currently owned ObjectFiles. The; /// conversion might be invalid, in which case an Error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,"/// Access to a derived version of all the currently owned ObjectFiles. The; /// conversion might be invalid, in which case an Error is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access the owned ObjectFile with architecture \p T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Security,Access,Access,4,/// Access to a derived version of the currently owned ObjectFile with; /// architecture \p T. The conversion must be known to be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cached,4,/// Cached entry holding one or more (in the of a fat binary) archive files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Load,Load,4,/// Load the given object binary in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Performance,Cache,Cache,4,"/// Cache of static archives. Objects that are part of a static archive are; /// stored under this object, rather than in the map below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:142,Deployability,release,released,142,/// This helper owns any CoreFoundation pointer and will call CFRelease() on; /// any valid pointer it owns unless that pointer is explicitly released using; /// the release() member function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:166,Deployability,release,release,166,/// This helper owns any CoreFoundation pointer and will call CFRelease() on; /// any valid pointer it owns unless that pointer is explicitly released using; /// the release() member function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper around CFBundleRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper around CFBundleRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/CFBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:97,Testability,test,testing,97,"// Sort the symbols in alphabetical order, like llvm-nm (and to get; // deterministic output for testing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:3,Integrability,Wrap,WrapColumn,3,/* WrapColumn = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp:22,Availability,resilien,resilient,22,// FIXME: find a more resilient way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DebugMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:169,Availability,error,error,169,/// Return a list of input files. This function has logic for dealing with the; /// special case where we might have dSYM bundles as input. The function; /// returns an error when the directory structure doesn't match that of a dSYM; /// bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:52,Testability,log,logic,52,/// Return a list of input files. This function has logic for dealing with the; /// special case where we might have dSYM bundles as input. The function; /// returns an error when the directory structure doesn't match that of a dSYM; /// bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:37,Deployability,update,update,37,"// FIXME: We cannot use stdin for an update because stdin will be; // consumed by the BinaryHolder during the debugmap parsing, and; // then we will want to consume it again in DwarfLinker. If we; // used a unique BinaryHolder object that could cache multiple; // binaries this restriction would go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:245,Performance,cache,cache,245,"// FIXME: We cannot use stdin for an update because stdin will be; // consumed by the BinaryHolder during the debugmap parsing, and; // then we will want to consume it again in DwarfLinker. If we; // used a unique BinaryHolder object that could cache multiple; // binaries this restriction would go away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:115,Availability,error,error,115,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:68,Performance,perform,performs,68,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:87,Safety,sanity check,sanity checking,87,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:11,Availability,avail,available,11,// Use all available hardware threads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:56,Usability,simpl,simple,56,"// If a flat dSYM has been requested, things are pretty simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:21,Deployability,update,update,21,// We need to create/update a dSYM bundle.; // A bundle hierarchy looks like this:; // <bundle name>.dSYM/; // Contents/; // Info.plist; // Resources/; // DWARF/; // <DWARF file(s)>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:35,Deployability,update,update,35,// Compute the output location and update the resource directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,Availability,recover,recovery,18,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,Safety,recover,recovery,18,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:215,Availability,error,error,215,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:442,Availability,error,error,442,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:299,Safety,detect,detect,299,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:28,Testability,log,logging,28,// FIXME: implement warning logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:20,Availability,error,error,20,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:26,Testability,log,logging,26,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:16,Availability,error,errors,16,// Don't report errors for missing remark files from static; // archives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:35,Availability,error,error,35,"// If ObjectEntry or Object has an error, no binary exists, therefore no; // reflection sections exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:7,Availability,error,errors,7,"// Any errors will be diagnosed later in the main loop, ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:7,Availability,error,errors,7,"// Any errors will be diagnosed later in the main loop, ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:3,Deployability,Update,Update,3,"// Update the section start with the current section's contribution, so; // the next section we copy from a different .o file points to the correct; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:74,Performance,cache,cache,74,"// If the module's parent directory exists, we assume that the; // module cache has expired and was pruned by clang. A more; // adventurous dsymutil would invoke clang to rebuild the module; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:17,Performance,cache,cache,17,"// If the module cache directory doesn't exist at all and the; // object file is inside a static library, we assume that the; // static library was built on a different machine. We don't want; // to discourage module debugging for convenience libraries within; // a project though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:23,Performance,load,loaded,23,// link debug info for loaded object files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:80,Integrability,depend,depending,80,/// Dispatch the valid relocation finding logic to the; /// appropriate handler depending on the object file format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:42,Testability,log,logic,42,/// Dispatch the valid relocation finding logic to the; /// appropriate handler depending on the object file format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp:33,Integrability,depend,depending,33,// Dispatch to the right handler depending on the file type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:51,Testability,log,logic,51,/// DwarfLinkerForBinaryRelocationMap contains the logic to handle the; /// relocations and to store them inside an associated RelocationMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:404,Integrability,interface,interface,404,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:259,Performance,optimiz,optimizes,259,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:328,Performance,optimiz,optimized,328,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:43,Testability,log,logic,43,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:67,Availability,error,errors,67,/// Returns true if input verification is enabled and verification errors were; /// found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:17,Integrability,depend,dependencies,17,///< Walking the dependencies of a kept DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:31,Integrability,depend,dependents,31,///< Use the ODR while keeping dependents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:15,Performance,load,load,15,/// Attempt to load a debug object from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h:4,Deployability,Update,Update,4,/// Update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h:29,Modifiability,variab,variable,29,/// Whether we want a static variable to force us to keep its enclosing; /// function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/LinkUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:148,Availability,error,error,148,/// Parses and returns the DebugMaps of the input binary. The binary contains; /// multiple maps in case it is a universal binary.; /// \returns an error in case the provided BinaryPath doesn't exist; /// or isn't of a supported type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:13,Performance,load,loaded,13,// Found and loaded new dSYM file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:203,Safety,Detect,Detect,203,"// Static archives can contain multiple object files with identical names, in; // which case the timestamp is used to disambiguate. However, if both are; // identical, there's no way to tell them apart. Detect this and skip; // duplicate debug map objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:188,Integrability,interface,interface,188,"// Table that maps Darwin's Mach-O stab constants to strings to allow printing.; // llvm-nm has very similar code, the strings used here are however slightly; // different and part of the interface of dsymutil (some project's build-systems; // parse the ouptut of dsymutil -s), thus they shouldn't be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:22,Integrability,rout,routine,22,/// This main parsing routine tries to open the main binary and if; /// successful iterates over the STAB entries. The real parsing is; /// done in handleStabSymbolTableEntry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:94,Deployability,update,update,94,"// If the last N_OSO object file wasn't found, CurrentDebugMapObject will be; // null. Do not update anything until we find the next valid N_OSO entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:20,Modifiability,variab,variable,20,// This is a global variable. We need to query the main binary; // symbol table to find its address as it might not be in the; // debug map (for common symbols).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Performance,Load,Load,4,/// Load the current object file symbols into CurrentObjectAddresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:153,Availability,avail,available,153,"/// Lookup a symbol address in the main binary symbol table. The; /// parser only needs to query common symbols, thus not every symbol's; /// address is available through this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Performance,Load,Load,4,/// Load the interesting main binary symbols' addresses into; /// MainBinarySymbolAddresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:58,Modifiability,variab,variables,58,"// In theory, the only symbols of interest are the global variables. These; // are the only ones that need to be queried because the address of common; // data won't be described in the debug map. All other addresses should be; // fetched for the debug map. In reality, by playing with 'ld -r' and; // export lists, you can get symbols described as N_GSYM in the debug map,; // but associated with a local symbol. Gather all the symbols, but prefer; // the global ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:121,Safety,avoid,avoid,121,// Return a MachO::segment_command_64 that holds the same values as the passed; // MachO::segment_command. We do that to avoid having to duplicate the logic; // for 32bits and 64bits segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:151,Testability,log,logic,151,// Return a MachO::segment_command_64 that holds the same values as the passed; // MachO::segment_command. We do that to avoid having to duplicate the logic; // for 32bits and 64bits segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper around transferSymbol to transfer all of \a Obj symbols; // to \a NewSymtab. This function does not write in the output file.; // \returns the number of symbols in \a NewSymtab.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:314,Deployability,update,updated,314,"// Transfer \a Segment from \a Obj to the output file. This calls into \a Writer; // to write these load commands directly in the output file at the current; // position.; //; // The function also tries to find a hole in the address map to fit the __DWARF; // segment of \a DwarfSegmentSize size. \a EndAddress is updated to point at the; // highest segment address.; //; // When the __LINKEDIT segment is transferred, its offset and size are set resp.; // to \a LinkeditOffset and \a LinkeditSize.; //; // When the eh_frame section is transferred, its offset and size are set resp.; // to \a EHFrameOffset and \a EHFrameSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:100,Performance,load,load,100,"// Transfer \a Segment from \a Obj to the output file. This calls into \a Writer; // to write these load commands directly in the output file at the current; // position.; //; // The function also tries to find a hole in the address map to fit the __DWARF; // segment of \a DwarfSegmentSize size. \a EndAddress is updated to point at the; // highest segment address.; //; // When the __LINKEDIT segment is transferred, its offset and size are set resp.; // to \a LinkeditOffset and \a LinkeditSize.; //; // When the eh_frame section is transferred, its offset and size are set resp.; // to \a EHFrameOffset and \a EHFrameSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:29,Performance,load,load,29,// Write the __DWARF segment load command to the output file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:25,Performance,load,load,25,// Compute the number of load commands we will need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load commands for the segments and sections we 'import' from; // the original binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:13,Performance,load,load,13,// Write the load command for the __DWARF segment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:111,Integrability,depend,depend,111,"// Apply relocations to the contents of the DWARF segment.; // We do this here because the final value written depend on the DWARF vm; // addr, which is only calculated in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h:45,Deployability,patch,patched,45,"// The position in the stream that should be patched, starting from the; // Dwarf's segment file address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp:3,Integrability,Wrap,WrapColumn,3,/* WrapColumn = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/RelocationMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp:217,Safety,risk,risk,217,"// We need permanent storage for the string we are about to create. Just; // append it to the vector containing translations. This should only happen; // during MachO symbol table translation, thus there should be no risk on; // exponential growth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:460,Integrability,interface,interface,460,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:13,Modifiability,plugin,plugin,13,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:26,Modifiability,Plugin,Plugin,26,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:397,Modifiability,plugin,plugin,397,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:55,Performance,Optimiz,Optimization,55,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Modifiability,plugin,plugin-api,3,// plugin-api.h requires HAVE_STDINT_H,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:9,Integrability,wrap,wrapper,9,/// RAII wrapper to manage opening and releasing of a ld_plugin_input_file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:20,Modifiability,plugin,plugin,20,"// When the thinlto plugin option is specified, only read the function; // the information from intermediate files and write a combined; // global index for the ThinLTO backends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:116,Modifiability,plugin,plugin,116,"// If false, all ThinLTO backend compilations through code gen are performed; // using multiple threads in the gold-plugin, before handing control back to; // gold. If true, write individual backend index files which reflect; // the import decisions, and exit afterwards. The assumption is; // that the build system will launch the backend processes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:67,Performance,perform,performed,67,"// If false, all ThinLTO backend compilations through code gen are performed; // using multiple threads in the gold-plugin, before handing control back to; // gold. If true, write individual backend index files which reflect; // the import decisions, and exit afterwards. The assumption is; // that the build system will launch the backend processes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:540,Safety,detect,detected,540,"// If non-empty, holds the name of a file in which to write the list of; // oject files gold selected for inclusion in the link after symbol; // resolution (i.e. they had selected symbols). This will only be non-empty; // in the thinlto_index_only case. It is used to identify files, which may; // have originally been within archive libraries specified via; // --start-lib/--end-lib pairs, that should be included in the final; // native link process (since intervening function importing and inlining; // may change the symbol resolution detected in the final link and which; // files to include out of --start-lib/--end-lib libraries as a result).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:39,Performance,cache,caches,39,// Optional pruning policy for ThinLTO caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:93,Modifiability,plugin,plugin,93,// Additional options to pass into the code generator.; // Note: This array will contain all plugin options which are not claimed; // as plugin exclusive to pass to the code generator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:137,Modifiability,plugin,plugin,137,// Additional options to pass into the code generator.; // Note: This array will contain all plugin options which are not claimed; // as plugin exclusive to pass to the code generator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Testability,Assert,Asserts,3,// Asserts that LTO link has whole program visibility,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization remarks filename, accepted passes and hotness options",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:141,Modifiability,plugin,plugin-api,141,"// Cast tv_tag to int to allow values not in ""enum ld_plugin_tag"", like, for; // example, LDPT_GET_SYMBOLS_V3 when building against an older plugin-api.h; // header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:60,Modifiability,plugin,plugin,60,/// Called by gold to see whether this file is one that our plugin can handle.; /// We'll try to open it and register all the symbols with add_symbol if; /// possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:228,Deployability,release,released,228,"// Keep track of the first handle for each file descriptor, since there are; // multiple in the case of an archive. This is used later in the case of; // ThinLTO parallel backends to ensure that each file is only opened and; // released once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:16,Integrability,wrap,wrap,16,"// Handle any --wrap options passed to gold, which are than passed; // along to the plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:84,Modifiability,plugin,plugin,84,"// Handle any --wrap options passed to gold, which are than passed; // along to the plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:3,Deployability,Toggle,Toggle,3,// Toggle function/data sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:10,Performance,optimiz,optimization,10,// Set up optimization remarks handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:74,Integrability,interface,interfaces,74,"// Map to own RAII objects that manage the file opening and releasing; // interfaces with gold. This is needed only for ThinLTO mode, since; // unlike regular LTO, where addModule will result in the opened file; // being merged into a new combined module, we need to keep these files open; // through Lto->run().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:182,Performance,perform,perform,182,"/// gold informs us that all symbols have been read. At this point, we use; /// get_symbols to see if any of our definitions have been overridden by a; /// native object file. Then, perform optimization and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:190,Performance,optimiz,optimization,190,"/// gold informs us that all symbols have been read. At this point, we use; /// get_symbols to see if any of our definitions have been overridden by a; /// native object file. Then, perform optimization and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:9,Performance,cache,cache,9,// Prune cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:464,Integrability,interface,interface,464,"//===-- llc.cpp - Implement the LLVM Native Code Generator ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the llc code generator driver. It provides a convenient; // command-line interface for generating an assembly file or a relocatable file,; // given LLVM bitcode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:13,Performance,optimiz,optimization,13,// Determine optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:70,Deployability,pipeline,pipeline,70,"// This flag specifies a textual description of the optimization pass pipeline; // to run over the module. This flag switches opt to use the new pass manager; // infrastructure, completely disabling all of the flags specific to the old; // pass management.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:52,Performance,optimiz,optimization,52,"// This flag specifies a textual description of the optimization pass pipeline; // to run over the module. This flag switches opt to use the new pass manager; // infrastructure, completely disabling all of the flags specific to the old; // pass management.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:36,Testability,test,tests,36,"// RemoveDIs debug-info transition: tests may request that we /try/ to use the; // new debug-info format, if it's built in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:59,Availability,error,error,59,// Set a diagnostic handler that doesn't exit on the first error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:3,Performance,Load,Load,3,// Load the module to be compiled...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:34,Performance,load,loaded,34,// Set attributes on functions as loaded from MIR from command line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:188,Modifiability,variab,variables,188,"// Since the storage mapping class is specified per csect,; // without using data sections, it is less effective to use read-only; // pointers. Using read-only pointers may cause other RO variables in the; // same csect to become RW when the linker acts upon `-bforceimprw`;; // therefore, we require that separate data sections are used in the; // presence of ReadOnlyPointers. We respect the setting of data-sections; // since we have not found reasons to do otherwise that overcome the user; // surprise of not respecting the setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:30,Availability,avail,available,30,"// If user just wants to list available options, skip module loading",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:61,Performance,load,loading,61,"// If user just wants to list available options, skip module loading",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:60,Availability,down,down,60,// If we don't have a module then just exit now. We do this down; // here since the CPU/Feature help is underneath the target machine; // creation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:33,Availability,down,down,33,// Ensure the filename is passed down to CodeViewDebug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:16,Usability,simpl,simplify-libcalls,16,// The -disable-simplify-libcalls flag actually disables all builtin optzns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:27,Deployability,pipeline,pipeline,27,// Construct a custom pass pipeline that starts after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/llc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:439,Testability,log,logically,439,"//===- NewPMDriver.cpp - Driver for llc using new PM ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file is just a split of the code that logically belongs in llc.cpp but; /// that includes the new pass manager headers.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:7,Testability,test,testing,7,"// For testing purposes, we print the LocCookie here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp:27,Deployability,pipeline,pipeline,27,// Construct a custom pass pipeline that starts after instruction; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h:680,Integrability,rout,routines,680,"//===- NewPMDriver.h - Function to drive llc with the new PM ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A single function which is called to drive the llc behavior for the new; /// PassManager.; ///; /// This is only in a separate TU with a header to avoid including all of the; /// old pass manager headers and the new pass manager headers into the same; /// file. Eventually all of the routines here will get folded back into; /// llc.cpp.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h:543,Safety,avoid,avoid,543,"//===- NewPMDriver.h - Function to drive llc with the new PM ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A single function which is called to drive the llc behavior for the new; /// PassManager.; ///; /// This is only in a separate TU with a header to avoid including all of the; /// old pass manager headers and the new pass manager headers into the same; /// file. Eventually all of the routines here will get folded back into; /// llc.cpp.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/NewPMDriver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Energy Efficiency,Adapt,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Integrability,Adapter,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Modifiability,Adapt,Adapter,18,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:587,Availability,avail,available,587,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:414,Integrability,wrap,wrapper,414,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:407,Usability,simpl,simple,407,"//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple wrapper around the LLVM Execution Engines,; // which allow the direct execution of LLVM programs through a Just-In-Time; // compiler, or through an interpreter if no JIT is available for this platform.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:115,Energy Efficiency,allocate,allocates,115,// Manually specify the child process for remote execution. This overrides; // the simulated remote execution that allocates address space for child; // execution. The child process will be executed and will communicate with; // lli via stdin/stdout pipes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:13,Performance,optimiz,optimization,13,// Determine optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:92,Performance,cache,cache,92,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:118,Performance,cache,cache,118,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:146,Performance,cache,cached,146,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:203,Performance,Cache,CacheDir,203,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:273,Performance,cache,cache,273,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:288,Performance,load,load,288,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:348,Performance,Cache,CacheDir,348,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:399,Performance,cache,cached,399,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:23,Performance,cache,cache,23,// Add trailing '/' to cache dir if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:23,Performance,cache,cache,23,// Create user-defined cache dir.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load the object from the cache filename,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:28,Performance,cache,cache,28,// Load the object from the cache filename,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:181,Deployability,release,released,181,"// MCJIT will want to write into this buffer, and we don't want that; // because the file has probably just been mmapped. Instead we make; // a copy. The filed-based buffer will be released when it goes; // out of scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:142,Safety,avoid,avoid,142,"// On Mingw and Cygwin, an external symbol named '__main' is called from the; // generated 'main' function to allow static initialization. To avoid linking; // problems with remote targets (because lli's remote target support does not; // currently handle external linking) we add a secondary module which defines; // an empty '__main' function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:79,Usability,usab,usable,79,"// If we have a native target, initialize it to ensure it is linked in and; // usable by the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load the bitcode...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:26,Performance,load,load,26,"// If not jitting lazily, load the whole bitcode file eagerly too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Performance,Load,Load,3,// Load any additional modules specified on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:112,Deployability,configurat,configuration,112,// The following functions have no effect if their respective profiling; // support wasn't enabled in the build configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:112,Modifiability,config,configuration,112,// The following functions have no effect if their respective profiling; // support wasn't enabled in the build configuration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check use of remote-jit: LLI currently only supports use of the; // remote JIT on Unix platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:21,Performance,cache,cache,21,// Clear instruction cache before code will be executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Usability,Clear,Clear,3,// Clear instruction cache before code will be executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:146,Availability,down,down,146,"// Like static constructors, the remote target MCJIT support doesn't handle; // this yet. It could. FIXME.; // Delete the EE - we need to tear it down *before* we terminate the session; // with the remote, otherwise it'll crash when it tries to release resources; // on a remote that has already been disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:245,Deployability,release,release,245,"// Like static constructors, the remote target MCJIT support doesn't handle; // this yet. It could. FIXME.; // Delete the EE - we need to tear it down *before* we terminate the session; // with the remote, otherwise it'll crash when it tries to release resources; // on a remote that has already been disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:86,Integrability,Interface,Interface,86,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:25,Modifiability,plugin,plugins,25,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:387,Availability,error,error,387,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:360,Safety,avoid,avoid,360,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:144,Availability,error,error,144,// FIXME: Setting a dummy call-through manager in non-lazy mode prevents the; // JIT builder to instantiate a default (which would fail with an error for; // unsupported architectures).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:17,Performance,cache,cache,17,// If the object cache is enabled then set a custom compile function; // creator to use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:92,Performance,cache,cache,92,// If the object cache is enabled then set a custom compile function; // creator to use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:216,Testability,stub,stubs,216,// Regular modules are greedy: They materialize as a whole and trigger; // materialization for all required symbols recursively. Lazy modules go; // through partitioning and they replace outgoing calls with reexport stubs; // that resolve on call-through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:12,Usability,Simpl,SimpleRemoteEPC,12,// Return a SimpleRemoteEPC instance connected to our end of the pipes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:739,Availability,avail,available,739,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:277,Deployability,configurat,configurations,277,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:326,Deployability,configurat,configurations,326,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:422,Deployability,configurat,configurations,422,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:1129,Energy Efficiency,allocate,allocate,1129,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:277,Modifiability,config,configurations,277,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:326,Modifiability,config,configurations,326,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:422,Modifiability,config,configurations,422,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:871,Testability,test,tests,871,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:1003,Testability,test,tests,1003,"// For MinGW environments, manually export the __chkstk function from the lli; // executable.; //; // Normally, this function is provided by compiler-rt builtins or libgcc.; // It is named ""_alloca"" on i386, ""___chkstk_ms"" on x86_64, and ""__chkstk"" on; // arm/aarch64. In MSVC configurations, it's named ""__chkstk"" in all; // configurations.; //; // When Orc tries to resolve symbols at runtime, this succeeds in MSVC; // configurations, somewhat by accident/luck; kernelbase.dll does export a; // symbol named ""__chkstk"" which gets found by Orc, even if regular applications; // never link against that function from that DLL (it's linked in statically; // from a compiler support library).; //; // The MinGW specific symbol names aren't available in that DLL though.; // Therefore, manually export the relevant symbol from lli, to let it be; // found at runtime during tests.; //; // For real JIT uses, the real compiler support libraries should be linked; // in, somehow; this is a workaround to let tests pass.; //; // We need to make sure that this symbol actually is linked in when we; // try to export it; if no functions allocate a large enough stack area,; // nothing would reference it. Therefore, manually declare it and add a; // reference to it. (Note, the declarations of _alloca/___chkstk_ms/__chkstk; // are somewhat bogus, these functions use a different custom calling; // convention.); //; // TODO: Move this into libORC at some point, see; // https://github.com/llvm/llvm-project/issues/56603.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/lli.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp:383,Usability,Simpl,Simple,383,"//===----------- ChildTarget.cpp - Out-of-proc executor for lli -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple out-of-process executor for lli.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ChildTarget/ChildTarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:1485,Deployability,update,update,1485,"R""(OPTIONS:; --format - archive format to create; =default - default; =gnu - gnu; =darwin - darwin; =bsd - bsd; =bigarchive - big archive (AIX OS); --plugin=<string> - ignored for compatibility; -h --help - display this help and exit; --output - the directory to extract archive members to; --rsp-quoting - quoting style for response files; =posix - posix; =windows - windows; --thin - create a thin archive; --version - print the version and exit; -X{32|64|32_64|any} - object mode (only for AIX OS); @<file> - read options from <file>. OPERATIONS:; d - delete [files] from the archive; m - move [files] in the archive; p - print contents of [files] found in the archive; q - quick append [files] to the archive; r - replace or insert [files] into the archive; s - act as ranlib; t - display list of files in archive; x - extract [files] from the archive. MODIFIERS:; [a] - put [files] after [relpos]; [b] - put [files] before [relpos] (same as [i]); [c] - do not warn if archive had to be created; [D] - use zero for timestamps and uids/gids (default); [h] - display this help and exit; [i] - put [files] before [relpos] (same as [b]); [l] - ignored for compatibility; [L] - add archive's contents; [N] - use instance [count] of name; [o] - preserve original dates; [O] - display member offsets; [P] - use full names when matching (implied for thin archives); [s] - create an archive index (cf. ranlib); [S] - do not build a symbol table; [T] - deprecated, use --thin instead; [u] - update only [files] newer than archive contents; [U] - use actual timestamps and uids/gids; [v] - be verbose about actions taken; [V] - display the version and exit; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:150,Modifiability,plugin,plugin,150,"R""(OPTIONS:; --format - archive format to create; =default - default; =gnu - gnu; =darwin - darwin; =bsd - bsd; =bigarchive - big archive (AIX OS); --plugin=<string> - ignored for compatibility; -h --help - display this help and exit; --output - the directory to extract archive members to; --rsp-quoting - quoting style for response files; =posix - posix; =windows - windows; --thin - create a thin archive; --version - print the version and exit; -X{32|64|32_64|any} - object mode (only for AIX OS); @<file> - read options from <file>. OPERATIONS:; d - delete [files] from the archive; m - move [files] in the archive; p - print contents of [files] found in the archive; q - quick append [files] to the archive; r - replace or insert [files] into the archive; s - act as ranlib; t - display list of files in archive; x - extract [files] from the archive. MODIFIERS:; [a] - put [files] after [relpos]; [b] - put [files] before [relpos] (same as [i]); [c] - do not warn if archive had to be created; [D] - use zero for timestamps and uids/gids (default); [h] - display this help and exit; [i] - put [files] before [relpos] (same as [b]); [l] - ignored for compatibility; [L] - add archive's contents; [N] - use instance [count] of name; [o] - preserve original dates; [O] - display member offsets; [P] - use full names when matching (implied for thin archives); [s] - create an archive index (cf. ranlib); [S] - do not build a symbol table; [T] - deprecated, use --thin instead; [u] - update only [files] newer than archive contents; [U] - use actual timestamps and uids/gids; [v] - be verbose about actions taken; [V] - display the version and exit; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,Availability,error,error,12,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:33,Integrability,message,message,33,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,Availability,error,error,12,// Show the error message and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:18,Integrability,message,message,18,// Show the error message and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:75,Modifiability,variab,variable,75,"///< 'L' modifier; // Relative Positional Argument (for insert/move). This variable holds; // the name of the archive member to which the 'a', 'b' or 'i' modifier; // refers. Only one of 'a', 'b' or 'i' can be specified so we only need; // one variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:244,Modifiability,variab,variable,244,"///< 'L' modifier; // Relative Positional Argument (for insert/move). This variable holds; // the name of the archive member to which the 'a', 'b' or 'i' modifier; // refers. Only one of 'a', 'b' or 'i' can be specified so we only need; // one variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:42,Modifiability,variab,variable,42,"// Count parameter for 'N' modifier. This variable specifies which file should; // match for extract/delete operations when there are multiple matches. This is; // 1-indexed. A value of 0 is invalid, and implies 'N' is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:8,Modifiability,variab,variable,8,// This variable holds the name of the archive file as given on the; // command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:8,Modifiability,variab,variable,8,"// This variable holds the list of member files to proecess, as given; // on the command line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:3,Performance,Perform,Perform,3,// Perform various checks on the operation/modifier specification; // to make sure we are dealing with a legal request.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:131,Testability,Test,Test,131,"// If OutputDir is not a directory, create_directories may still succeed if; // all components of the path prefix are directories. Test is_directory as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:19,Performance,optimiz,optimize,19,"// We could try to optimize this to a fstat, but it is not a common; // operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:122,Energy Efficiency,efficient,efficient,122,"// We have to walk this twice and computing it is not trivial, so creating an; // explicit std::vector is actually fairly efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:221,Deployability,update,update,221,"// When an archive is created or modified, if the s option is given, the; // resulting archive will have a current symbol table. If the S option; // is given, it will have no symbol table.; // In summary, we only need to update the symbol table if we have none.; // This is actually very common because of broken build systems that think; // they have to run ranlib.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:31,Modifiability,variab,variable,31,"// Get BitMode from enviorment variable ""OBJECT_MODE"" for AIX OS, if; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:57,Modifiability,variab,variable,57,"// If not specify -X option, get BitMode from enviorment variable; // ""OBJECT_MODE"" for AIX OS if specify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:85,Availability,error,error,85,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:163,Availability,error,error,163,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:169,Integrability,message,message,169,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:52,Testability,test,test,52,"// Don't bother printing reason, just return to the test function,; // since a fatal error represents a successful parse (i.e. it correctly; // terminated with an error message to the user).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for locals before setjmp so that memory can be collected; // if parse exits prematurely (via longjmp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-as-fuzzer/llvm-as-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c:32,Testability,test,testing,32,"/*===-- attributes.c - tool for testing libLLVM and llvm-c API ------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --test-attributes and --test-callsite-attributes *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c:435,Testability,test,test-attributes,435,"/*===-- attributes.c - tool for testing libLLVM and llvm-c API ------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --test-attributes and --test-callsite-attributes *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c:457,Testability,test,test-callsite-attributes,457,"/*===-- attributes.c - tool for testing libLLVM and llvm-c API ------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --test-attributes and --test-callsite-attributes *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c:508,Testability,test,test,508,"/*===-- attributes.c - tool for testing libLLVM and llvm-c API ------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --test-attributes and --test-callsite-attributes *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/attributes.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c:26,Testability,test,testing,26,"/*===-- calc.c - tool for testing libLLVM and llvm-c API ------------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --calc command in llvm-c-test. --calc reads lines *|; |* from stdin, parses them as a name and an expression in reverse polish *|; |* notation and prints a module with a function with the expression. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c:458,Testability,test,test,458,"/*===-- calc.c - tool for testing libLLVM and llvm-c API ------------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --calc command in llvm-c-test. --calc reads lines *|; |* from stdin, parses them as a name and an expression in reverse polish *|; |* notation and prints a module with a function with the expression. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/calc.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c:31,Testability,test,testing,31,"/*===-- debuginfo.c - tool for testing libLLVM and llvm-c API -------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Tests for the LLVM C DebugInfo API *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c:408,Testability,Test,Tests,408,"/*===-- debuginfo.c - tool for testing libLLVM and llvm-c API -------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Tests for the LLVM C DebugInfo API *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/debuginfo.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c:34,Testability,test,testing,34,"//===-- diagnostic.cpp - tool for testing libLLVM and llvm-c API ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --test-diagnostic-handler command in llvm-c-test.; //; // This command uses the C API to read a module with a custom diagnostic; // handler set to test the diagnostic handler functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c:410,Testability,test,test-diagnostic-handler,410,"//===-- diagnostic.cpp - tool for testing libLLVM and llvm-c API ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --test-diagnostic-handler command in llvm-c-test.; //; // This command uses the C API to read a module with a custom diagnostic; // handler set to test the diagnostic handler functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c:452,Testability,test,test,452,"//===-- diagnostic.cpp - tool for testing libLLVM and llvm-c API ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --test-diagnostic-handler command in llvm-c-test.; //; // This command uses the C API to read a module with a custom diagnostic; // handler set to test the diagnostic handler functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c:555,Testability,test,test,555,"//===-- diagnostic.cpp - tool for testing libLLVM and llvm-c API ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --test-diagnostic-handler command in llvm-c-test.; //; // This command uses the C API to read a module with a custom diagnostic; // handler set to test the diagnostic handler functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/diagnostic.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c:33,Testability,test,testing,33,"/*===-- disassemble.c - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --disassemble command in llvm-c-test. *|; |* --disassemble reads lines from stdin, parses them as a triple and hex *|; |* machine code, and prints disassembly of the machine code. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c:465,Testability,test,test,465,"/*===-- disassemble.c - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --disassemble command in llvm-c-test. *|; |* --disassemble reads lines from stdin, parses them as a triple and hex *|; |* machine code, and prints disassembly of the machine code. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/disassemble.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:8,Availability,echo,echo,8,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:410,Availability,echo,echo,410,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:609,Security,validat,validate,609,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:28,Testability,test,testing,28,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:433,Testability,test,test,433,"//===-- echo.cpp - tool for testing libLLVM and llvm-c API ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the --echo command in llvm-c-test.; //; // This command uses the C API to read a module and output an exact copy of it; // as output. It is used to check that the resulting module matches the input; // to validate that the C API can read and write modules properly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:14,Modifiability,variab,variable,14,// Try global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:76,Integrability,depend,dependency,76,"// If we have a hit, it means we already generated the instruction; // as a dependency to something else. We need to make sure; // it is ordered properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/helpers.c:29,Testability,test,testing,29,"/*===-- helpers.c - tool for testing libLLVM and llvm-c API ---------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Helper functions *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/helpers.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/helpers.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/include-all.c:33,Testability,test,testing,33,"/*===-- include-all.c - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file doesn't have any actual code. It just make sure that all *|; |* the llvm-c include files are good and doesn't generate any warnings *|; |* *|; \*===----------------------------------------------------------------------===*/; // FIXME: Autogenerate this list",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/include-all.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/include-all.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:15,Testability,test,test,15,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:33,Testability,test,testing,33,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:431,Testability,test,test,431,"/*===-- llvm-c-test.h - tool for testing libLLVM and llvm-c API -----------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Header file for llvm-c-test *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h:3,Availability,echo,echo,3,// echo.c,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/llvm-c-test.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/main.c:26,Testability,test,testing,26,"/*===-- main.c - tool for testing libLLVM and llvm-c API ------------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Main file for llvm-c-tests. ""Parses"" arguments and dispatches. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/main.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/main.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/main.c:429,Testability,test,tests,429,"/*===-- main.c - tool for testing libLLVM and llvm-c API ------------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* Main file for llvm-c-tests. ""Parses"" arguments and dispatches. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/main.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/main.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c:28,Testability,test,testing,28,"/*===-- object.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --add-named-metadata-operand and --set-metadata *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c:507,Testability,test,test,507,"/*===-- object.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --add-named-metadata-operand and --set-metadata *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c:27,Testability,assert,assertion,27,// This used to trigger an assertion,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c:27,Testability,assert,assertion,27,// This used to trigger an assertion,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/metadata.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/module.c:28,Testability,test,testing,28,"/*===-- module.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --module-dump, --module-list-functions and *|; |* --module-list-globals commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/module.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/module.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/module.c:524,Testability,test,test,524,"/*===-- module.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --module-dump, --module-list-functions and *|; |* --module-list-globals commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/module.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/module.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/object.c:28,Testability,test,testing,28,"/*===-- object.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --object-list-sections and --object-list-symbols *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/object.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/object.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/object.c:508,Testability,test,test,508,"/*===-- object.c - tool for testing libLLVM and llvm-c API ----------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --object-list-sections and --object-list-symbols *|; |* commands in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/object.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/object.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c:29,Testability,test,testing,29,"/*===-- targets.c - tool for testing libLLVM and llvm-c API ---------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --targets command in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c:461,Testability,test,test,461,"/*===-- targets.c - tool for testing libLLVM and llvm-c API ---------------===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file implements the --targets command in llvm-c-test. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/targets.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp:403,Testability,test,testing,403,"//===- llvm-cat.cpp - LLVM module concatenation utility -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is for testing features that rely on multi-module bitcode files.; // It takes a list of input modules and uses them to create a multi-module; // bitcode file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp:108,Availability,alive,alive,108,"// The string table does not own strings added to it, some of which are; // owned by the modules; keep them alive until we write the string table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp:415,Security,Integrity,Integrity,415,"//===-- llvm-cfi-verify.cpp - CFI Verification tool for LLVM --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool verifies Control Flow Integrity (CFI) instrumentation by static; // binary analysis. See the design document in /docs/CFIVerify.rst for more; // information.; //; // This tool is currently incomplete. It currently only does disassembly for; // object files, and searches through the code for indirect control flow; // instructions, printing them once found.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/llvm-cfi-verify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:45,Performance,load,load,45,"// Some architectures (e.g., AArch64) cannot load in an indirect branch, so; // we allow them one load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:98,Performance,load,load,98,"// Some architectures (e.g., AArch64) cannot load in an indirect branch, so; // we allow them one load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:26,Performance,load,load,26,// Add the registers this load reads to those we check for clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:53,Availability,failure,failures,53,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:3,Safety,Avoid,Avoid,3,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:77,Availability,error,error,77,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:117,Security,validat,validate,117,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:222,Performance,load,load,222,"// Returns the first place the operand register is clobbered between the CFI-; // check and the indirect CF instruction execution. We do this by walking; // backwards from the indirect CF and ensuring there is at most one load; // involving the operand register (which is the indirect CF itself on x86).; // If the register is not modified, returns the address of the indirect CF; // instruction. The result is undefined if the provided graph does not fall; // under either the FAIL_REGISTER_CLOBBERED or PROTECTED status (see; // CFIProtectionStatus).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:111,Integrability,depend,dependency,111,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:122,Integrability,inject,inject,122,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:122,Security,inject,inject,122,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:79,Testability,test,testing,79,"// Construct a blank object with the provided triple and features. Used in; // testing, where a sub class will dependency inject protected methods to; // allow analysis of raw binary, without requiring a fully valid ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:140,Safety,avoid,avoid,140,// A mapping between the virtual memory address to the instruction metadata; // struct. TODO(hctim): Reimplement this as a sorted vector to avoid per-; // insertion allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h:228,Deployability,update,update,228,"// Utilised by buildFlowGraphImpl to build the tree out from the provided; // conditional branch node to an undefined instruction. The provided; // conditional branch node must have exactly one of its subtrees set, and will; // update the node's CFIProtection field if a deterministic flow can be found; // to an undefined instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/GraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:538,Availability,avail,available,538,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:39,Deployability,configurat,configuration,39,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:440,Deployability,configurat,configuration,440,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:518,Deployability,install,installed,518,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:13,Modifiability,config,config,13,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:39,Modifiability,config,configuration,39,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:440,Modifiability,config,configuration,440,"//===-- llvm-config.cpp - LLVM project configuration utility --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This tool encapsulates information about an LLVM project configuration for; // use by other project's build environments (to determine installed path,; // available features, required libraries, etc.).; //; // Note that although this tool *may* be used by some parts of LLVM's build; // itself (i.e., the Makefiles use it to compute required libraries when linking; // tools), this tool is primarily designed to support external projects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:26,Modifiability,variab,variables,26,// Include the build time variables we can report to the user. This is generated; // at build time from the BuildVariables.inc.in file by the build system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:68,Availability,Avail,AvailableComponent,68,"// Include the component table. This creates an array of struct; // AvailableComponent entries, which record the component name, library name,; // and required components for all of the available libraries.; //; // Not all components define a library, we also use ""library groups"" as a way to; // create entries for pseudo groups like x86 or all-targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:186,Availability,avail,available,186,"// Include the component table. This creates an array of struct; // AvailableComponent entries, which record the component name, library name,; // and required components for all of the available libraries.; //; // Not all components define a library, we also use ""library groups"" as a way to; // create entries for pseudo groups like x86 or all-targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:43,Integrability,depend,dependencies,43,"// Built-in extensions also register their dependencies, but in a separate file,; // later in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:69,Modifiability,config,config,69,// LinkMode determines what libraries and flags are returned by llvm-config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:207,Availability,avail,available,207,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:61,Deployability,install,installation,61,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:88,Integrability,depend,dependent,88,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:98,Availability,error,error,98,"// LinkModeShared will link with the dynamic component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:97,Availability,error,error,97,"// LinkModeStatic will link with the static component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:20,Deployability,install,installed,20,// Only include non-installed components if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:28,Integrability,depend,dependencies,28,"// Otherwise, visit all the dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:137,Performance,load,loaded,137,"// Special handling for the special 'extensions' component. Its content is; // not populated by llvm-build, but later in the process and loaded from; // ExtensionDependencies.inc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:314,Deployability,install,installed,314,"/// Compute the list of required libraries for a given list of; /// components, in an order suitable for passing to a linker (that is, libraries; /// appear prior to their dependencies).; ///; /// \param Components - The names of the components to find libraries for.; /// \param IncludeNonInstalled - Whether non-installed components should be; /// reported.; /// \param GetComponentNames - True if one would prefer the component names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:172,Integrability,depend,dependencies,172,"/// Compute the list of required libraries for a given list of; /// components, in an order suitable for passing to a linker (that is, libraries; /// appear prior to their dependencies).; ///; /// \param Components - The names of the components to find libraries for.; /// \param IncludeNonInstalled - Whether non-installed components should be; /// reported.; /// \param GetComponentNames - True if one would prefer the component names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:3,Security,Validat,Validate,3,// Validate that the user supplied a valid component name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:106,Integrability,depend,dependency,106,"// The list is now ordered with leafs first, we want the libraries to printed; // in the reverse order of dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:93,Deployability,install,installed,93,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:8,Modifiability,config,config,8,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:125,Safety,detect,detect,125,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:18,Safety,avoid,avoid,18,// Initialized to avoid warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:117,Availability,avail,available,117,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:221,Deployability,install,installed,221,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:431,Modifiability,config,configure,431,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:44,Availability,error,error,44,// The shared library does not exist: don't error unless the user; // explicitly passes --link-shared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:20,Deployability,install,installed,20,// Only include non-installed components when in a development tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:79,Integrability,depend,dependent,79,// Print SYSTEM_LIBS after --libs.; // FIXME: Each LLVM component may have its dependent system libs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:14,Availability,error,error,14,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:35,Availability,error,error,35,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:20,Integrability,message,message,20,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:37,Availability,error,error,37,/// Print the warning message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:22,Integrability,message,message,22,/// Print the warning message to the error output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:34,Performance,cache,cache,34,/// Retrieve a file status with a cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:57,Availability,error,error,57,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:4,Performance,Load,Load,4,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:22,Availability,avail,available,22,"/// If a demangler is available, demangle all symbol names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:16,Performance,cache,cache,16,/// File status cache used when finding the same file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:6,Performance,cache,cache,6,/// A cache for demangled symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:3,Performance,Cache,Cache,3,// Cache the demangled names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:29,Safety,safe,safe,29,"// In -output-dir mode, it's safe to use multiple threads to print files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:68,Availability,error,error,68,// Unreachable because we should have gracefully terminated with an error; // above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h:427,Integrability,interface,interface,427,"//===- CoverageExporter.h - Code coverage exporter ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class defines a code coverage exporter interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp:1250,Security,checksum,checksum,1250,"//===- CoverageExporterLcov.cpp - Code coverage export --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements export of code coverage data to lcov trace file format.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // The trace file code coverage export follows the following format (see also; // https://linux.die.net/man/1/geninfo). Each quoted string appears on its own; // line; the indentation shown here is only for documentation purposes.; //; // - for each source file:; // - ""SF:<absolute path to source file>""; // - for each function:; // - ""FN:<line number of function start>,<function name>""; // - for each function:; // - ""FNDA:<execution count>,<function name>""; // - ""FNF:<number of functions found>""; // - ""FNH:<number of functions hit>""; // - for each instrumented line:; // - ""DA:<line number>,<execution count>[,<checksum>]; // - for each branch:; // - ""BRDA:<line number>,<branch pair id>,<branch id>,<count>""; // - ""BRF:<number of branches found>""; // - ""BRH:<number of branches hit>""; // - ""LH:<number of lines with non-zero execution count>""; // - ""LF:<number of instrumented lines>""; // - ""end_of_record""; //; // If the user is exporting summary information only, then the FN, FNDA, and DA; // lines will not be present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageExporterLcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,Availability,redundant,redundant,22,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,Safety,redund,redundant,22,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,Availability,redundant,redundant,31,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,Safety,redund,redundant,31,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,Availability,redundant,redundant,33,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,Safety,redund,redundant,33,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,Availability,redundant,redundant,23,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,Safety,redund,redundant,23,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Availability,redundant,redundant,40,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Safety,redund,redundant,40,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,Availability,redundant,redundant,55,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,Safety,redund,redundant,55,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Availability,redundant,redundant,40,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,Safety,redund,redundant,40,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:340,Availability,error,error,340,"/// Prepare file reports for each directory in \p SourceFiles. The total; /// report for all files is returned and its Name is set to the LCP of all; /// files. The size of \p SourceFiles must be greater than 1 or else the; /// behavior is undefined, in which case you should use; /// CoverageReport::prepareSingleFileReport instead. If an error occurs,; /// the recursion will stop immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:16,Modifiability,variab,variables,16,// These member variables below are used for avoiding being passed; // repeatedly in recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:45,Safety,avoid,avoiding,45,// These member variables below are used for avoiding being passed; // repeatedly in recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h:6,Performance,cache,cache,6,/// A cache for demangled symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h:58,Availability,avail,available,58,/// Check if the created time of the profile data file is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageViewOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:64,Performance,concurren,concurrent,64,// Open .gcda and .gcda without requiring a NUL terminator. The concurrent; // modification may nullify the NUL terminator condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:3,Usability,Clear,Clear,3,// Clear the filename to make it clear we didn't read anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp:33,Usability,clear,clear,33,// Clear the filename to make it clear we didn't read anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/gcov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp:46,Testability,test,testing,46,/// The main entry point for the 'convert-for-testing' subcommand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/llvm-cov.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp:65,Availability,error,error,65,// Unreachable because CodeCoverage.cpp should terminate with an error; // before we get here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp:65,Availability,error,error,65,// Unreachable because CodeCoverage.cpp should terminate with an error; // before we get here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:24,Integrability,Interface,Interface,24,/// @name File Creation Interface; /// @{; /// Create a file to print a coverage view into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:256,Integrability,Interface,Interface,256,/// A code coverage view of a source file or function.; ///; /// A source coverage view and its nested sub-views form a file-oriented; /// representation of code coverage data. This view can be printed out by a; /// renderer which implements the Rendering Interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:23,Usability,guid,guide,23,/// Various options to guide the coverage renderer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:20,Integrability,Interface,Interface,20,/// @name Rendering Interface; /// @{; /// Render a header for the view.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:47,Availability,avail,available,47,"/// Render \p Title, a project title if one is available, and the; /// created time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1517,Energy Efficiency,green,green,1517,";; margin-right: 5px;; margin-bottom: 5px;; border: 1px solid #dbdbdb;; border-radius: 3px;; }; table {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1590,Energy Efficiency,green,green,1590," solid #dbdbdb;; border-radius: 3px;; }; table {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; }; th, td {; vertical-align: top;; padding: 2px 8px;; bo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:1626,Energy Efficiency,green,green,1626,"e {; border-collapse: collapse;; }; .light-row {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; }; .light-row-bold {; background: #ffffff;; border: 1px solid #dbdbdb;; border-left: none;; border-right: none;; font-weight: bold;; }; .column-entry {; text-align: left;; }; .column-entry-bold {; font-weight: bold;; text-align: left;; }; .column-entry-yellow {; text-align: left;; background-color: #ffffd0;; }; .column-entry-yellow:hover, tr:hover .column-entry-yellow {; background-color: #fffff0;; }; .column-entry-red {; text-align: left;; background-color: #ffd0d0;; }; .column-entry-red:hover, tr:hover .column-entry-red {; background-color: #fff0f0;; }; .column-entry-gray {; text-align: left;; background-color: #fbfbfb;; }; .column-entry-gray:hover, tr:hover .column-entry-gray {; background-color: #f0f0f0;; }; .column-entry-green {; text-align: left;; background-color: #d0ffd0;; }; .column-entry-green:hover, tr:hover .column-entry-green {; background-color: #f0fff0;; }; .line-number {; text-align: right;; color: #aaa;; }; .covered-line {; text-align: right;; color: #0080ff;; }; .uncovered-line {; text-align: right;; color: #ff3300;; }; .tooltip {; position: relative;; display: inline;; background-color: #b3e6ff;; text-decoration: none;; }; .tooltip span.tooltip-content {; position: absolute;; width: 100px;; margin-left: -50px;; color: #FFFFFF;; background: #000000;; height: 30px;; line-height: 30px;; text-align: center;; visibility: hidden;; border-radius: 6px;; }; .tooltip span.tooltip-content:after {; content: '';; position: absolute;; top: 100%;; left: 50%;; margin-left: -8px;; width: 0; height: 0;; border-top: 8px solid #000000;; border-right: 8px solid transparent;; border-left: 8px solid transparent;; }; :hover.tooltip span.tooltip-content {; visibility: visible;; opacity: 0.8;; bottom: 30px;; left: 50%;; z-index: 999;; }; th, td {; vertical-align: top;; padding: 2px 8px;; border-collapse: collapse;; border-right: solid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:34,Availability,avail,available,34,"// Link to a stylesheet if one is available. Otherwise, use the default style.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:39,Integrability,wrap,wrap,39,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:27,Safety,avoid,avoid,27,"// |Line| + 1 is needed to avoid underflow when, e.g |Line| = 0 and LCol = 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:13,Integrability,Wrap,WrappedSegment,13,"// 3. Use \p WrappedSegment to set the highlight for snippet 0. Use segment; // 1 to set the highlight for snippet 2, segment 2 to set the highlight for; // snippet 3, and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h:413,Integrability,interface,interface,413,"//===- SourceCoverageViewHTML.h - A html code coverage view ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file defines the interface to the html coverage renderer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h:413,Integrability,interface,interface,413,"//===- SourceCoverageViewText.h - A text-based code coverage view ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file defines the interface to the text-based coverage renderer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewText.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:7,Testability,Test,TestingSupport,7,"//===- TestingSupport.cpp - Convert objects files into test files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:55,Testability,test,test,55,"//===- TestingSupport.cpp - Convert objects files into test files --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp:89,Energy Efficiency,allocate,allocated,89,"// If this is a linked PE/COFF file, then we have to skip over the null byte; // that is allocated in the .lprfn$A section in the LLVM profiling runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/TestingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:7,Availability,Error,Error,7,"//===- Error.cpp - system_error extensions for llvm-cxxdump -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines a new error_category for the llvm-cxxdump tool.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h:7,Availability,Error,Error,7,"//===- Error.h - system_error extensions for llvm-cxxdump -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This declares a new error_category for the llvm-cxxdump tool.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxdump/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp:21,Integrability,depend,depends,21,"// The default value depends on the default triple. Mach-O has symbols; // prefixed with ""_"", so strip by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp:3,Performance,Load,Load,3,// Load the remapping file and prepare to canonicalize symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxmap/llvm-cxxmap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:426,Testability,log,logical,426,"//===-- llvm-debuginfo-analyzer.cpp - LLVM Debug info analysis utility ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a utility that displays the logical view for the debug; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:63,Integrability,depend,dependencies,63,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:34,Safety,avoid,avoid,34,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:47,Availability,error,error,47,// Don't remove output file if we exit with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:22,Performance,perform,perform,22,// Create readers and perform requested tasks on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:12,Availability,error,error,12,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:18,Integrability,message,message,18,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:46,Security,access,accessible,46,/// @}; // Copy local options into a globally accessible data structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:32,Deployability,update,update,32,// Traverse list of options and update the given set (Using case and Regex).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:32,Deployability,update,update,32,// Traverse list of options and update the given set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:23,Integrability,depend,dependencies,23,"// Resolve any options dependencies (ie. --print=all should set other; // print options, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:60,Availability,error,error,60,"// Parse an argument representing an offset. Return true on error.; // If the prefix is 0, the base is octal, if the prefix is 0x or 0X, the; // base is hexadecimal, otherwise the base is decimal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:3,Performance,Perform,Perform,3,"// Perform any additional post parse command line actions. Propagate the; // values captured by the command line parser, into the generic reader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:13,Testability,log,logicalview,13,// namespace logicalview,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp:474,Integrability,protocol,protocol,474,"//===-- llvm-debuginfod.cpp - federating debuginfod server ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod tool, which serves the debuginfod; /// protocol over HTTP. The tool periodically scans zero or more filesystem; /// directories for ELF binaries to serve, and federates requests for unknown; /// build IDs to the debuginfod servers set in the DEBUGINFOD_URLS environment; /// variable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp:710,Modifiability,variab,variable,710,"//===-- llvm-debuginfod.cpp - federating debuginfod server ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod tool, which serves the debuginfod; /// protocol over HTTP. The tool periodically scans zero or more filesystem; /// directories for ELF binaries to serve, and federates requests for unknown; /// build IDs to the debuginfod servers set in the DEBUGINFOD_URLS environment; /// variable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod/llvm-debuginfod.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:532,Modifiability,variab,variable,532,"//===-- llvm-debuginfod-find.cpp - Simple CLI for libdebuginfod-client ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod-find tool. This tool; /// queries the debuginfod servers in the DEBUGINFOD_URLS environment; /// variable (delimited by space ("" "")) for the executable,; /// debuginfo, or specified source file of the binary matching the; /// given build-id.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:35,Usability,Simpl,Simple,35,"//===-- llvm-debuginfod-find.cpp - Simple CLI for libdebuginfod-client ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the llvm-debuginfod-find tool. This tool; /// queries the debuginfod servers in the DEBUGINFOD_URLS environment; /// variable (delimited by space ("" "")) for the executable,; /// debuginfo, or specified source file of the binary matching the; /// given build-id.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp:25,Performance,cache,cached,25,// Print the path to the cached artifact file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfod-find/llvm-debuginfod-find.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:35,Availability,error,error,35,"/// Reads a module from a file. On error, messages are written to stderr; /// and null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:42,Integrability,message,messages,42,"/// Reads a module from a file. On error, messages are written to stderr; /// and null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:3,Performance,Load,Load,3,// Load both modules. Die if that fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getLeft(I), true);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getLeft(I), true);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp:13,Testability,Log,Log,13,"//printValue(Log.getRight(I), false);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:407,Integrability,interface,interface,407,"//===-- DiffConsumer.h - Difference Consumer --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference Consumer; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:8,Integrability,interface,interface,8,/// The interface for consumers of difference data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h:170,Modifiability,variab,variables,170,"/// Record that a local context has been entered. Left and; /// Right are IR ""containers"" of some sort which are being; /// considered for structural equivalence: global variables,; /// functions, blocks, instructions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:15,Performance,queue,queue,15,"/// A priority queue, implemented as a heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:14,Testability,test,test,14,"// Otherwise, test whether we should swap L and Index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:39,Modifiability,variab,variable,39,// Some initializers may reference the variable we're currently checking. This; // can cause an infinite loop. The Saved[LR]HS ivars can be checked to prevent; // recursing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:91,Integrability,depend,depend,91,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:686,Integrability,depend,depend,686,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1187,Integrability,depend,depending,1187,"processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either hav",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1481,Integrability,depend,dependency,1481,"ce and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either have already been; // proven to differ, or pairs whose equivalence depends on assumptions to be; // verified later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:2189,Integrability,depend,depends,2189,"ce and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either have already been; // proven to differ, or pairs whose equivalence depends on assumptions to be; // verified later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:892,Safety,avoid,avoid,892,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:1066,Usability,clear,clear,1066,"processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by induction on the; // iteration, using the computed value mapping.; // The class BlockDiffCandidate stores pairs which either hav",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:34,Performance,queue,queue,34,/// A type which sorts a priority queue by the number of unprocessed; /// predecessor blocks it has remaining.; ///; /// This is actually really expensive to calculate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:6,Performance,queue,queue,6,/// A queue of unified blocks to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:204,Safety,detect,detected,204,"// Register (L, R) as diffing pair. Note that we could directly emit a; // block diff here, but this way we ensure all diffs are emitted in one; // consistent order, independent of whether the diffs were detected; // immediately or via invalid assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:3,Performance,Perform,Perform,3,"// Perform the ""try unify"" step so that we can equate the indirect; // destinations before checking the call site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:67,Modifiability,variab,variable,67,"// If the left and right operands aren't both re-analyzing the; // variable, then the initialiers don't match, so report ""false"".; // Otherwise, we skip these operands..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:67,Modifiability,variab,variable,67,"// If the left and right operands aren't both re-analyzing the; // variable, then the initialiers don't match, so report ""false"".; // Otherwise, we skip these operands..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:95,Integrability,depend,depends,95,"// There are cases where we cannot determine whether two values are; // equivalent, because it depends on not yet processed basic blocks -- see the; // documentation on assumptions.; //; // AC is the context in which we are currently performing a diff.; // When we encounter a pair of values for which we can neither prove; // equivalence nor the opposite, we do the following:; // * If AC is nullptr, we treat the pair as non-equivalent.; // * If AC is set, we add an assumption for the basic blocks given by AC,; // and treat the pair as equivalent. The assumption is checked later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:234,Performance,perform,performing,234,"// There are cases where we cannot determine whether two values are; // equivalent, because it depends on not yet processed basic blocks -- see the; // documentation on assumptions.; //; // AC is the context in which we are currently performing a diff.; // When we encounter a pair of values for which we can neither prove; // equivalence nor the opposite, we do the following:; // * If AC is nullptr, we treat the pair as non-equivalent.; // * If AC is set, we add an assumption for the basic blocks given by AC,; // and treat the pair as equivalent. The assumption is checked later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:43,Integrability,depend,depend,43,"// L and R might be equivalent, this could depend on not yet processed; // basic blocks, so we cannot decide here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:3,Safety,Avoid,Avoid,3,// Avoid a gcc warning about accessing 'this' in an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:29,Security,access,accessing,29,// Avoid a gcc warning about accessing 'this' in an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:407,Integrability,interface,interface,407,"//===-- DifferenceEngine.h - Module comparator ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference engine,; // which structurally compares functions within a module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:16,Performance,perform,performing,16,/// A class for performing structural comparisons of LLVM assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:4,Deployability,Install,Installs,4,"/// Installs an oracle to decide whether two global values are; /// equivalent as operands. Without an oracle, global values are; /// considered equivalent as operands precisely when they have the; /// same name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:407,Integrability,interface,interface,407,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:47,Security,access,accessories,47,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:31,Testability,Log,Log,31,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp:440,Testability,log,log,440,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:407,Integrability,interface,interface,407,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:47,Security,access,accessories,47,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:31,Testability,Log,Log,31,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:440,Testability,log,log,440,"//===-- DiffLog.h - Difference Log Builder and accessories ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the interface to the LLVM difference log builder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:49,Integrability,message,messages,49,/// A temporary-object class for building up log messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:45,Testability,log,log,45,/// A temporary-object class for building up log messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:60,Testability,Log,LogBuilder,60,"/// The use of a stored StringRef here is okay because; /// LogBuilder should be used only as a temporary, and as a; /// temporary it will be destructed before whatever temporary; /// might be initializing this format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h:50,Integrability,message,messages,50,/// A temporary-object class for building up diff messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DiffLog.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp:50,Safety,sanity check,sanity check,50,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp:426,Testability,test,test,426,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dlang-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:19,Availability,error,error,19,/// Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:19,Availability,error,error,19,/// Return true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:51,Availability,error,error,51,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:57,Integrability,message,messages,57,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:40,Availability,down,down,40,"// If we have split DWARF, then recurse down into the .dwo files as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:274,Modifiability,extend,extend,274,"/// Handle the --lookup option and dump the DIEs and line info for the given; /// address.; /// TODO: specified Address for --lookup option could relate for several; /// different sections(in case not-linked object file). llvm-dwarfdump; /// need to do something with this: extend lookup option with section; /// information or probably display all matched entries, or something else...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:34,Availability,avail,available,34,"// Since there's no compile units available, walk the line tables and; // extract out any referenced paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:46,Safety,avoid,avoids,46,// Flush outs() when printing to errs(). This avoids interleaving output; // between the two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:10,Security,Audit,Audit,10,// FIXME: Audit interactions between these two options and make them; // compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:47,Availability,error,error,47,// Don't remove output file if we exit with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:131,Modifiability,variab,variables,131,"/// This represents the number of categories of debug location coverage being; /// calculated. The first category is the number of variables with 0% location; /// coverage, but the last category is the number of variables with 100%; /// location coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:212,Modifiability,variab,variables,212,"/// This represents the number of categories of debug location coverage being; /// calculated. The first category is the number of variables with 0% location; /// coverage, but the last category is the number of variables with 100%; /// location coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// This represents variables DIE offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:41,Modifiability,variab,variables,41,/// This maps function DIE offset to its variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:70,Safety,detect,detect,70,/// This represents a data type for the stats and it helps us to; /// detect an overflow.; /// NOTE: This can be implemented as a template if there is an another type; /// needing this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:93,Modifiability,variab,variables,93,"/// Holds statistics for one function (or other entity that has a PC range and; /// contains variables, such as a compile unit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:14,Modifiability,variab,variables,14,/// Number of variables and parameters with location across all inlined; /// instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:24,Modifiability,variab,variables,24,"/// Number of arificial variables, parameters or members across all instances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:16,Modifiability,Variab,Variables,16,/// List of all Variables and parameters in this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:20,Modifiability,variab,variables,20,/// Number of local variables with DW_AT_location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variable,43,/// Total number of PC range bytes in each variable's enclosing scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:83,Modifiability,variab,variables,83,/// Total number of PC range bytes covered by DW_AT_locations (only for local; /// variables).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:49,Modifiability,variab,variable,49,/// Total number of PC range bytes in each local variable's enclosing scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:131,Modifiability,variab,variables,131,/// Total number of PC range bytes covered by DW_AT_locations with; /// the debug entry values (DW_OP_entry_value) (only for local variables).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:156,Performance,tune,tune,156,/// Total byte size of inlined functions. This is the total number of bytes; /// for the top inline functions within concrete functions. This can help; /// tune the inline settings when compiling to match user expectations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:60,Modifiability,variab,variables,60,/// Holds accumulated debug location statistics about local variables and; /// formal parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:51,Modifiability,variab,variables,51,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:162,Modifiability,variab,variables,162,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:286,Modifiability,variab,variables,286,"/// Map the scope coverage decile to the number of variables in the decile.; /// The first element of the array (at the index zero) represents the number; /// of variables with the no debug location at all, but the last element; /// in the vector represents the number of fully covered variables within; /// its scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:44,Modifiability,variab,variables,44,/// The debug location statistics for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:50,Modifiability,variab,variables,50,/// Map non debug entry values coverage for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:26,Modifiability,variab,variables,26,/// Total number of local variables and function parameters processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:26,Modifiability,variab,variables,26,/// Total number of local variables processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:36,Modifiability,variab,variable,36,// No debug location at all for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:17,Modifiability,variab,variable,17,// Fully covered variable within its scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:37,Modifiability,variab,variables,37,// Prefix + Name is enough for local variables and parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:28,Modifiability,variab,variables,28,// For zero covered inlined variables the locstats will be; // calculated later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:9,Modifiability,variab,variable,9,// Not a variable or constant member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:33,Modifiability,variab,variables,33,// Ignore declarations of global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:21,Modifiability,variab,variable,21,"// Do not track this variable any more, since it has location; // coverage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:39,Modifiability,variab,variables,39,// This catches constant members *and* variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:10,Modifiability,variab,variables,10,// Handle variables and function arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:249,Modifiability,variab,variable,249,"// Calculate how many bytes of the parent scope this entry covers.; // FIXME: In section 2.6.2 of the DWARFv5 spec it says that ""The; // address ranges defined by the bounded location descriptions of a; // location list may overlap"". So in theory a variable can have; // multiple simultaneous locations, which would make this calculation; // misleading because we will count the overlapped areas; // twice. However, clang does not currently emit DWARF like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:24,Modifiability,variab,variables,24,/// Recursively collect variables from subprogram with DW_AT_inline attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:28,Modifiability,variab,variables,28,// We want to know how many variables (with abstract_origin) don't have; // location info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variables,43,"// Skip over abstract origins, but collect variables; // from it so it can be used for location statistics; // for inlined instancies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:3,Deployability,Update,Update,3,// Update function prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:52,Modifiability,variab,variable,52,"// Not a scope, visit the Die itself. It could be a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:128,Modifiability,variab,variables,128,"// After we have processed all vars of the inlined function (or function with; // an abstract_origin), we want to know how many variables have no location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:18,Modifiability,variab,variables,18,/// Stop tracking variables that contain abstract_origin with a location.; /// This is used for out-of-order DW_AT_inline subprograms only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:47,Modifiability,variab,variables,47,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is out of order in the DWARF.; /// Also cover the variables of a concrete function (represented with; /// the DW_TAG_subprogram) with an abstract_origin attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:166,Modifiability,variab,variables,166,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is out of order in the DWARF.; /// Also cover the variables of a concrete function (represented with; /// the DW_TAG_subprogram) with an abstract_origin attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:12,Modifiability,variab,variable,12,"// The next variable is used to filter out functions that have been processed,; // leaving FnsWithAbstractOriginToBeProcessed with just CrossCU references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:47,Modifiability,variab,variables,47,/// Collect zero location coverage for inlined variables which refer to; /// a DW_AT_inline copy of subprogram that is in a different CU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:141,Availability,down,down,141,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:104,Energy Efficiency,reduce,reduce,104,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:336,Performance,optimiz,optimizations,336,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,"// This variable holds variable information for functions with; // abstract_origin globally, across all CUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variable,23,"// This variable holds variable information for functions with; // abstract_origin globally, across all CUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,// This variable holds information about the CU of a function with; // abstract_origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:8,Modifiability,variab,variable,8,"// This variable holds variable information for functions with; // abstract_origin, but just for the current CU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variable,23,"// This variable holds variable information for functions with; // abstract_origin, but just for the current CU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:9,Modifiability,variab,variables,9,// Count variables in global scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:23,Modifiability,variab,variables,23,// This includes local variables and formal parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:31,Modifiability,variab,variables,31,// Print the summary for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:37,Modifiability,variab,variables,37,// Print the location statistics for variables (includes local variables; // and formal parameters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:63,Modifiability,variab,variables,63,// Print the location statistics for variables (includes local variables; // and formal parameters).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:43,Modifiability,variab,variables,43,// Print the location statistics for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:28,Testability,log,logging,28,// FIXME: implement warning logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:20,Availability,error,error,20,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:26,Testability,log,logging,26,// FIXME: implement error logging which does not block other threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:11,Integrability,message,message,11,// Display message for the replaced accelerator tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp:11,Integrability,message,message,11,// Display message for the removed accelerator tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/DebugInfoLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h:7,Availability,Error,Error,7,"//===- Error.h --------------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp:11,Availability,avail,available,11,// Use all available hardware threads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp:198,Availability,error,error,198,"// The file ""FileName"" was created by this utility in the previous steps; // (i.e. it is already known that it should pass the isObject check).; // If the createBinary() function does not return an error, the isObject; // check should also be successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:34,Testability,benchmark,benchmark,34,"// When not asking for a specific benchmark mode,; // we'll analyse the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:33,Availability,error,error,33,// Helper function that logs the error(s) and exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:24,Testability,log,logs,24,// Helper function that logs the error(s) and exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:27,Availability,failure,failure,27,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:54,Availability,error,error,54,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:41,Testability,log,log,41,// Check Err. If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:89,Availability,failure,failure,89,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:116,Availability,error,error,116,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:103,Testability,log,log,103,// Check E. If it's in a success state then return the contained value.; // If it's in a failure state log the file error(s) and exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:3,Availability,Error,Errors,3,// Errors from executing the snippets are fine.; // All other errors are a framework issue and should fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:62,Availability,error,errors,62,// Errors from executing the snippets are fine.; // All other errors are a framework issue and should fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:65,Testability,benchmark,benchmark,65,// Preliminary check to ensure features needed for requested; // benchmark mode are present on target CPU and/or OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:8,Testability,benchmark,benchmarks,8,// Read benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:42,Performance,latency,latency,42,// FIXME: Merge points from several runs (latency and uops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp:22,Availability,avail,available,22,// Enable printing of available targets when flag --version is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/llvm-exegesis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:56,Energy Efficiency,schedul,scheduling,56,"// Prints a row representing an instruction, along with scheduling info and; // point coordinates (measurements).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:12,Testability,benchmark,benchmarks,12,// Parallel benchmarks repeat the same opcode multiple times. Just show this; // opcode and show the whole snippet only on hover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:3,Performance,Latency,Latency,3,// Latency tries to find a serial path. Just show the opcode path and show the; // whole snippet only on hover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:16,Security,validat,validate,16,// In Uops mode validate() may not be enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:31,Performance,latency,latency,31,// Dismabiguate if more than 1 latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:11,Performance,throughput,throughput,11,// inverse throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:226,Modifiability,config,config,226,"R""(; <head>; <title>llvm-exegesis Analysis Results</title>; <style>; body {; font-family: sans-serif; }; span.sched-class-name {; font-weight: bold;; font-family: monospace;; }; span.opcode {; font-family: monospace;; }; span.config {; font-family: monospace;; }; div.inconsistency {; margin-top: 50px;; }; table {; margin-left: 50px;; border-collapse: collapse;; }; table, table tr,td,th {; border: 1px solid #444;; }; table ul {; padding-left: 0px;; margin: 0px;; list-style-type: none;; }; table.sched-class-clusters td {; padding-left: 10px;; padding-right: 10px;; padding-top: 10px;; padding-bottom: 10px;; }; table.sched-class-desc td {; padding-left: 10px;; padding-right: 10px;; padding-top: 2px;; padding-bottom: 2px;; }; span.mono {; font-family: monospace;; }; td.measurement {; text-align: center;; }; tr.good-cluster td.measurement {; color: #292; }; tr.bad-cluster td.measurement {; color: #922; }; tr.good-cluster td.measurement span.minmax {; color: #888;; }; tr.bad-cluster td.measurement span.minmax {; color: #888;; }; </style>; </head>; )""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:20,Availability,error,errors,20,// Ignore noise and errors. FIXME: take noise into account ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:13,Energy Efficiency,schedul,scheduling,13,// Print any scheduling class that has at least one cluster that does not; // match the checked-in data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:416,Testability,benchmark,benchmark,416,"//===-- Analysis.h ----------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Analysis output for benchmark results.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:29,Testability,benchmark,benchmark,29,// A helper class to analyze benchmark results for a target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:18,Availability,error,errors,18,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h:32,Energy Efficiency,schedul,scheduling,32,// Find potential errors in the scheduling information given measurements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:99,Security,validat,validate,99,// The frontend that generates that parses the memory mapping information; // from the user should validate that the requested address is a multiple; // of the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:171,Testability,Assert,Assert,171,// The frontend that generates that parses the memory mapping information; // from the user should validate that the requested address is a multiple; // of the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:50,Performance,load,load,50,"// If we're generating memory instructions, don't load in the value for; // the register with the stack pointer as it will be used later to finish; // the setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:3,Performance,Load,Load,3,// Load a constant in the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:3,Performance,Load,Load,3,// Load in the stack register now as we're done using it elsewhere; // and need to set the value in preparation for executing the; // snippet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:179,Testability,assert,assertion,179,"// If the snippet setup is not complete, we disable liveliness tracking. This; // means that we won't know what values are in the registers.; // FIXME: this should probably be an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:24,Performance,load,loadObjectImpl,24,// See RuntimeDyldImpl::loadObjectImpl(Obj) for much more complete; // implementation.; // Find the only function in the object file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:41,Integrability,depend,depends,41,// Gather the set of reserved registers (depends on function's calling; // convention and target machine).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:3,Performance,Load,Loads,3,// Loads the content of Filename as on ObjectFile and returns it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:10,Testability,benchmark,benchmark,10,// Copies benchmark function's bytes from benchmark object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:42,Testability,benchmark,benchmark,42,// Copies benchmark function's bytes from benchmark object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:8,Testability,Benchmark,BenchmarkCode,8,"//===-- BenchmarkCode.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:31,Deployability,configurat,configuration,31,// Informations about how this configuration was built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h:31,Modifiability,config,configuration,31,// Informations about how this configuration was built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp:8,Testability,Benchmark,BenchmarkResult,8,"//===-- BenchmarkResult.cpp -------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp:2,Integrability,Wrap,WrapColumn,2,/*WrapColumn*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:8,Testability,Benchmark,BenchmarkResult,8,"//===-- BenchmarkResult.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines classes to represent measurements and serialize/deserialize them to; // Yaml.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:44,Security,access,access,44,// The memory mappings that the snippet can access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:13,Deployability,configurat,configuration,13,"// An opaque configuration, that can be used to separate several benchmarks of; // the same instruction under different configurations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:120,Deployability,configurat,configurations,120,"// An opaque configuration, that can be used to separate several benchmarks of; // the same instruction under different configurations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:13,Modifiability,config,configuration,13,"// An opaque configuration, that can be used to separate several benchmarks of; // the same instruction under different configurations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:120,Modifiability,config,configurations,120,"// An opaque configuration, that can be used to separate several benchmarks of; // the same instruction under different configurations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:65,Testability,benchmark,benchmarks,65,"// An opaque configuration, that can be used to separate several benchmarks of; // the same instruction under different configurations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:42,Performance,load,loaded,42,// The address that the snippet should be loaded in at if the execution mode; // being used supports it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:34,Testability,Benchmark,BenchmarkMeasure,34,// A helper to create an unscaled BenchmarkMeasure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:17,Security,validat,validation,17,// These are the validation counter values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:32,Testability,benchmark,benchmark,32,// The result of an instruction benchmark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:30,Testability,benchmark,benchmarked,30,// Which instruction is being benchmarked here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:41,Testability,benchmark,benchmarks,41,"// Given a set of serialized instruction benchmarks, returns the set of; // triples and CPUs that appear in the list of benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:120,Testability,benchmark,benchmarks,120,"// Given a set of serialized instruction benchmarks, returns the set of; // triples and CPUs that appear in the list of benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:108,Testability,Benchmark,Benchmark,108,//------------------------------------------------------------------------------; // Utilities to work with Benchmark measures.; // A class that measures stats over benchmark measures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:165,Testability,benchmark,benchmark,165,//------------------------------------------------------------------------------; // Utilities to work with Benchmark measures.; // A class that measures stats over benchmark measures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:8,Testability,Benchmark,BenchmarkRunner,8,"//===-- BenchmarkRunner.cpp -------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:122,Availability,error,error,122,"// The exit code of the process on windows is not meaningful as a; // signal, so simply pass in -1 as the signal into the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:81,Usability,simpl,simply,81,"// The exit code of the process on windows is not meaningful as a; // signal, so simply pass in -1 as the signal into the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:430,Availability,error,errors,430,"// The following class implements a function executor that executes the; // benchmark code within a subprocess rather than within the main llvm-exegesis; // process. This allows for much more control over the execution context of the; // snippet, particularly with regard to memory. This class performs all the; // necessary functions to create the subprocess, execute the snippet in the; // subprocess, and report results/handle errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:294,Performance,perform,performs,294,"// The following class implements a function executor that executes the; // benchmark code within a subprocess rather than within the main llvm-exegesis; // process. This allows for much more control over the execution context of the; // snippet, particularly with regard to memory. This class performs all the; // necessary functions to create the subprocess, execute the snippet in the; // subprocess, and report results/handle errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:76,Testability,benchmark,benchmark,76,"// The following class implements a function executor that executes the; // benchmark code within a subprocess rather than within the main llvm-exegesis; // process. This allows for much more control over the execution context of the; // snippet, particularly with regard to memory. This class performs all the; // necessary functions to create the subprocess, execute the snippet in the; // subprocess, and report results/handle errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:453,Availability,failure,failures,453,"// Make sure to attach to the process (and wait for the sigstop to be; // delivered and for the process to continue) before we write to the counter; // file descriptor. Attaching to the process before writing to the socket; // ensures that the subprocess at most has blocked on the read call. If we; // attach afterwards, the subprocess might exit before we get to the attach; // call due to effects like scheduler contention, introducing transient; // failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:405,Energy Efficiency,schedul,scheduler,405,"// Make sure to attach to the process (and wait for the sigstop to be; // delivered and for the process to continue) before we write to the counter; // file descriptor. Attaching to the process before writing to the socket; // ensures that the subprocess at most has blocked on the read call. If we; // attach afterwards, the subprocess might exit before we get to the attach; // call due to effects like scheduler contention, introducing transient; // failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:6,Availability,error,error,6,"// An error was encountered running the snippet, process it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:96,Availability,failure,failure,96,"// Disable core dumps in the child process as otherwise everytime we; // encounter an execution failure like a segmentation fault, we will create; // a core dump. We report the information directly rather than require the; // user inspect a core dump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:124,Availability,fault,fault,124,"// Disable core dumps in the child process as otherwise everytime we; // encounter an execution failure like a segmentation fault, we will create; // a core dump. We report the information directly rather than require the; // user inspect a core dump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:35,Testability,benchmark,benchmarking,35,// The following occurs within the benchmarking subprocess,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:214,Safety,safe,safely,214,// Glibc versions greater than 2.35 automatically call rseq during; // initialization. Unmapping the region that glibc sets up for this causes; // segfaults in the program Unregister the rseq region so that we can safely; // unmap it later,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:96,Security,validat,validate,96,// GLIBC_INITS_RSEQ; // The frontend that generates the memory annotation structures should; // validate that the address to map the snippet in at is a multiple of; // the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:183,Testability,Assert,Assert,183,// GLIBC_INITS_RSEQ; // The frontend that generates the memory annotation structures should; // validate that the address to map the snippet in at is a multiple of; // the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:135,Usability,clear,clearly,135,// Assemble at least kMinInstructionsForSnippet instructions by repeating; // the snippet for debug/analysis. This is so that the user clearly; // understands that the inside instructions are repeated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:509,Performance,latency,latency,509,"//===-- BenchmarkRunner.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract BenchmarkRunner class for measuring a certain execution; /// property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:8,Testability,Benchmark,BenchmarkRunner,8,"//===-- BenchmarkRunner.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract BenchmarkRunner class for measuring a certain execution; /// property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:417,Testability,Benchmark,BenchmarkRunner,417,"//===-- BenchmarkRunner.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract BenchmarkRunner class for measuring a certain execution; /// property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:23,Testability,benchmark,benchmark,23,// Common code for all benchmark modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:64,Modifiability,sandbox,sandboxed,64,// A helper to measure counters while executing a function in a sandboxed; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:64,Testability,sandbox,sandboxed,64,// A helper to measure counters while executing a function in a sandboxed; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:577,Usability,simpl,simple,577,"// The clustering problem has the following characteristics:; // (A) - Low dimension (dimensions are typically proc resource units,; // typically < 10).; // (B) - Number of points : ~thousands (points are measurements of an MCInst); // (C) - Number of clusters: ~tens.; // (D) - The number of clusters is not known /a priory/.; // (E) - The amount of noise is relatively small.; // The problem is rather small. In terms of algorithms, (D) disqualifies; // k-means and makes algorithms such as DBSCAN[1] or OPTICS[2] more applicable.; //; // We've used DBSCAN here because it's simple to implement. This is a pretty; // straightforward and inefficient implementation of the pseudocode in [2].; //; // [1] https://en.wikipedia.org/wiki/DBSCAN; // [2] https://en.wikipedia.org/wiki/OPTICS_algorithm; // Finds the points at distance less than sqrt(EpsilonSquared) of Q (not; // including Q).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:3,Availability,Error,Error,3,// Error point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:3,Availability,Error,Error,3,// Error point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:3,Availability,Error,Error,3,// Error point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:16,Availability,error,error,16,// Pretend that error point is a neighbour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:24,Safety,avoid,avoid,24,// Persistent buffer to avoid allocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:7,Modifiability,extend,extend,7,// And extend to the neighbors of Q if the region is dense enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:3,Testability,assert,assert,3,"// assert(Neighbors.capacity() == (Points_.size() - 1));; // ^ True, but it is not quaranteed to be true in all the cases.; // Add noisy points to noise cluster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:94,Testability,benchmark,benchmarks,94,"// Given an instruction Opcode, which sched class id's are represented,; // and which are the benchmarks for each sched class?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:335,Integrability,depend,depending,335,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:305,Modifiability,variab,variable,305,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:109,Performance,perform,performance,109,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:474,Performance,perform,performance,474,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:44,Testability,benchmark,benchmarks,44,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:176,Testability,benchmark,benchmarks,176,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:396,Testability,benchmark,benchmarks,396,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:566,Testability,benchmark,benchmarks,566,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:742,Testability,benchmark,benchmarks,742,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:801,Testability,benchmark,benchmarks,801,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:35,Modifiability,Config,Config,35,"// Given an instruction Opcode and Config, in which clusters do benchmarks of; // this instruction lie? Normally, they all should be in the same cluster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:64,Testability,benchmark,benchmarks,64,"// Given an instruction Opcode and Config, in which clusters do benchmarks of; // this instruction lie? Normally, they all should be in the same cluster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:60,Testability,benchmark,benchmarks,60,// Go through every cluster which we recorded as containing benchmarks; // of this UnstableOpcode. NOTE: we only recorded valid clusters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h:417,Testability,benchmark,benchmark,417,"//===-- Clustering.h --------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Utilities to compute benchmark result clusters.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h:14,Testability,benchmark,benchmarks,14,// Indices of benchmarks within the cluster.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:64,Modifiability,Variab,Variables,64,// A template for an Instruction holding values for each of its Variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:96,Modifiability,variab,variable,96,// Builds an MCInst from this InstructionTemplate setting its operands; // to the corresponding variable values. Precondition: All VariableValues must; // be set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:131,Modifiability,Variab,VariableValues,131,// Builds an MCInst from this InstructionTemplate setting its operands; // to the corresponding variable values. Precondition: All VariableValues must; // be set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:36,Energy Efficiency,power,powers,36,// Returns a sequence of increasing powers of two corresponding to all the; // Execution flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:98,Modifiability,variab,variables,98,// A CodeTemplate is a set of InstructionTemplates that may not be fully; // specified (i.e. some variables are not yet set). This allows the; // SnippetGenerator to instantiate it many times with specific values to study; // their impact on instruction's performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:256,Performance,perform,performance,256,// A CodeTemplate is a set of InstructionTemplates that may not be fully; // specified (i.e. some variables are not yet set). This allows the; // SnippetGenerator to instantiate it many times with specific values to study; // their impact on instruction's performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:22,Modifiability,Config,Config,22,// See BenchmarkKey.::Config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:7,Testability,Benchmark,BenchmarkKey,7,// See BenchmarkKey.::Config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.cpp:8,Availability,Error,Error,8,"//===-- Error.cpp -----------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:8,Availability,Error,Error,8,"//===-- Error.h -------------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:24,Availability,failure,failures,24,"// A class representing failures that happened within llvm-exegesis, they are; // used to report informations to the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:24,Availability,failure,failures,24,// A class representing failures that happened during clustering calculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:57,Availability,failure,failure,57,"// A class representing a non-descript snippet execution failure. This class; // is designed to sub-classed into more specific failures that contain; // additional data about the specific error that they represent. Instead of; // halting the program, the errors are reported in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:127,Availability,failure,failures,127,"// A class representing a non-descript snippet execution failure. This class; // is designed to sub-classed into more specific failures that contain; // additional data about the specific error that they represent. Instead of; // halting the program, the errors are reported in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:188,Availability,error,error,188,"// A class representing a non-descript snippet execution failure. This class; // is designed to sub-classed into more specific failures that contain; // additional data about the specific error that they represent. Instead of; // halting the program, the errors are reported in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:255,Availability,error,errors,255,"// A class representing a non-descript snippet execution failure. This class; // is designed to sub-classed into more specific failures that contain; // additional data about the specific error that they represent. Instead of; // halting the program, the errors are reported in the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:50,Availability,fault,faults,50,// A class representing specifically segmentation faults that happen during; // snippet execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h:47,Availability,failure,failures,47,// A class representing all other non-specific failures that happen during; // snippet execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp:8,Performance,Latency,LatencyBenchmarkRunner,8,"//===-- LatencyBenchmarkRunner.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h:8,Performance,Latency,LatencyBenchmarkRunner,8,"//===-- LatencyBenchmarkRunner.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A BenchmarkRunner implementation to measure instruction latencies.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h:398,Testability,Benchmark,BenchmarkRunner,398,"//===-- LatencyBenchmarkRunner.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A BenchmarkRunner implementation to measure instruction latencies.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp:3,Deployability,Update,Update,3,// Update Triple with the updated triple from the target lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp:26,Deployability,update,updated,26,// Update Triple with the updated triple from the target lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h:418,Security,access,access,418,"//===-- LlvmState.h ---------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A class to set up and access common LLVM objects.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h:260,Testability,test,tests,260,"// Factory function.; // If `Triple` is empty, uses the host triple.; // If `CpuName` is empty, uses the host CPU.; // If `UseDummyPerfCounters` is set, does not query the kernel; // for event counts.; // `UseDummyPerfCounters` and `Features` are intended for tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LlvmState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp:3,Modifiability,Variab,Variables,3,// Variables.size() <= Operands.size(); // Assigning Variables to non tied explicit operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp:53,Modifiability,Variab,Variables,53,// Variables.size() <= Operands.size(); // Assigning Variables to non tied explicit operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp:13,Modifiability,Variab,Variables,13,// Assigning Variables to tied operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp:25,Modifiability,Variab,Variables,25,// Assigning Operands to Variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:614,Modifiability,Variab,Variable,614,"//===-- MCInstrDescView.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provide views around LLVM structures to represents an instruction instance,; /// as well as its implicit and explicit arguments in a uniform way.; /// Arguments that are explicit and independant (non tied) also have a Variable; /// associated to them so the instruction can be fully defined by reading its; /// Variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:707,Modifiability,Variab,Variables,707,"//===-- MCInstrDescView.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provide views around LLVM structures to represents an instruction instance,; /// as well as its implicit and explicit arguments in a uniform way.; /// Arguments that are explicit and independant (non tied) also have a Variable; /// associated to them so the instruction can be fully defined by reading its; /// Variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:5,Modifiability,variab,variable,5,// A variable represents the value associated to an Operand or a set of Operands; // if they are tied together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:29,Modifiability,Variab,Variable,29,// Returns the index of this Variable inside Instruction's Variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:59,Modifiability,Variab,Variable,59,// Returns the index of this Variable inside Instruction's Variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:51,Modifiability,Variab,Variable,51,// Returns the index of the Operand linked to this Variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:24,Modifiability,Variab,Variable,24,// Returns whether this Variable has more than one Operand linked to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:44,Modifiability,Variab,Variable,44,// The indices of the operands tied to this Variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:21,Modifiability,Variab,Variable,21,// The index of this Variable in Instruction.Variables and its associated; // Value in InstructionBuilder.VariableValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:45,Modifiability,Variab,Variables,45,// The index of this Variable in Instruction.Variables and its associated; // Value in InstructionBuilder.VariableValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:106,Modifiability,Variab,VariableValues,106,// The index of this Variable in Instruction.Variables and its associated; // Value in InstructionBuilder.VariableValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:577,Modifiability,Variab,VariableIndex,577,"// MCOperandInfo can only represents Explicit operands. This object gives a; // uniform view of Implicit and Explicit Operands.; // - Index: can be used to refer to MCInstrDesc::operands for Explicit operands.; // - Tracker: is set for Register Operands and is used to keep track of possible; // registers and the registers reachable from them (aliasing registers).; // - Info: a shortcut for MCInstrDesc::operands()[Index].; // - TiedToIndex: the index of the Operand holding the value or -1.; // - ImplicitReg: the register value when Operand is Implicit, 0 otherwise.; // - VariableIndex: the index of the Variable holding the value for this Operand; // or -1 if this operand is implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:609,Modifiability,Variab,Variable,609,"// MCOperandInfo can only represents Explicit operands. This object gives a; // uniform view of Implicit and Explicit Operands.; // - Index: can be used to refer to MCInstrDesc::operands for Explicit operands.; // - Tracker: is set for Register Operands and is used to keep track of possible; // registers and the registers reachable from them (aliasing registers).; // - Info: a shortcut for MCInstrDesc::operands()[Index].; // - TiedToIndex: the index of the Operand holding the value or -1.; // - ImplicitReg: the register value when Operand is Implicit, 0 otherwise.; // - VariableIndex: the index of the Variable holding the value for this Operand; // or -1 if this operand is implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:18,Security,access,accessors,18,// Please use the accessors above and not the following fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:6,Performance,cache,cache,6,"/// A cache of BitVector to reuse between Instructions.; /// The cache will only be exercised during Instruction initialization.; /// For X86, this is ~160 unique vectors for all of the ~15K Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:65,Performance,cache,cache,65,"/// A cache of BitVector to reuse between Instructions.; /// The cache will only be exercised during Instruction initialization.; /// For X86, this is ~160 unique vectors for all of the ~15K Instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:12,Energy Efficiency,allocate,allocates,12,// Finds or allocates the provided BitVector in the cache and retrieves it's; // unique instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:52,Performance,cache,cache,52,// Finds or allocates the provided BitVector in the cache and retrieves it's; // unique instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:52,Integrability,interface,interface,52,// A view over an MCInstrDesc offering a convenient interface to compute; // Register aliasing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:42,Energy Efficiency,allocate,allocated,42,"// Prevent copy or move, instructions are allocated once and cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:61,Performance,cache,cached,61,"// Prevent copy or move, instructions are allocated once and cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:38,Modifiability,Variab,Variable,38,"// Returns the Operand linked to this Variable.; // In case the Variable is tied, the primary (i.e. Def) Operand is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:64,Modifiability,Variab,Variable,64,"// Returns the Operand linked to this Variable.; // In case the Variable is tied, the primary (i.e. Def) Operand is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:68,Performance,cache,cache,68,// Instructions are expensive to instantiate. This class provides a cache of; // Instructions with lazy construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:24,Deployability,configurat,configurations,24,// Returns all possible configurations leading Def registers of DefInstruction; // to alias with Use registers of UseInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:24,Modifiability,config,configurations,24,// Returns all possible configurations leading Def registers of DefInstruction; // to alias with Use registers of UseInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:23,Deployability,configurat,configuration,23,// True if no aliasing configuration is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:23,Modifiability,config,configuration,23,// True if no aliasing configuration is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h:86,Availability,avail,available,86,"// Before kernel 4.17, Linux did not support MAP_FIXED_NOREPLACE, so if it is; // not available, simplfy define it as MAP_FIXED which performs the same; // function but does not guarantee existing mappings won't get clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h:134,Performance,perform,performs,134,"// Before kernel 4.17, Linux did not support MAP_FIXED_NOREPLACE, so if it is; // not available, simplfy define it as MAP_FIXED which performs the same; // function but does not guarantee existing mappings won't get clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h:97,Usability,simpl,simplfy,97,"// Before kernel 4.17, Linux did not support MAP_FIXED_NOREPLACE, so if it is; // not available, simplfy define it as MAP_FIXED which performs the same; // function but does not guarantee existing mappings won't get clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MmapUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:183,Availability,avail,availability,183,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:283,Availability,avail,availability,283,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:310,Integrability,depend,dependencies,310,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:412,Integrability,depend,dependencies,412,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1360,Integrability,depend,dependency,1360," achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; //; // To avoid that, we do the renaming statically by generating as many; // independent exclusive assignments as possible (until all possible registers; // are exhausted) e.g.:; // imul rax, rbx; // imul rcx, rbx; // imul rdx, rbx; // imul r8, rbx; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:10,Performance,Load,Load,10,"// FIXME: Load constants into registers (e.g. with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1163,Performance,latency,latency,1163,"with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1922,Performance,latency,latency,1922,"tr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; //; // To avoid that, we do the renaming statically by generating as many; // independent exclusive assignments as possible (until all possible registers; // are exhausted) e.g.:; // imul rax, rbx; // imul rcx, rbx; // imul rdx, rbx; // imul r8, rbx; //; // Some instruction even make the above static renaming impossible because; // they implicitly read and write from the same operand, e.g. ADC16rr reads; // and writes from EFLAGS.; // In that case we just use a greedy register assignment and hope for the; // best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1792,Safety,avoid,avoiding,1792,"tr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; //; // To avoid that, we do the renaming statically by generating as many; // independent exclusive assignments as possible (until all possible registers; // are exhausted) e.g.:; // imul rax, rbx; // imul rcx, rbx; // imul rdx, rbx; // imul r8, rbx; //; // Some instruction even make the above static renaming impossible because; // they implicitly read and write from the same operand, e.g. ADC16rr reads; // and writes from EFLAGS.; // In that case we just use a greedy register assignment and hope for the; // best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:2085,Safety,avoid,avoid,2085,"tr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; //; // To avoid that, we do the renaming statically by generating as many; // independent exclusive assignments as possible (until all possible registers; // are exhausted) e.g.:; // imul rax, rbx; // imul rcx, rbx; // imul rdx, rbx; // imul r8, rbx; //; // Some instruction even make the above static renaming impossible because; // they implicitly read and write from the same operand, e.g. ADC16rr reads; // and writes from EFLAGS.; // In that case we just use a greedy register assignment and hope for the; // best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.h:167,Performance,load,load,167,"// Instantiates memory operands within a snippet.; // To make computations as parallel as possible, we generate independant; // memory locations for instructions that load and store. If there are less; // than kMinNumDifferentAddresses in the original snippet, we duplicate; // instructions until there are this number of instructions.; // For example, assuming kMinNumDifferentAddresses=5 and; // getMaxMemoryAccessSize()=64, if the original snippet is:; // mov eax, [memory]; // we might generate:; // mov eax, [rdi]; // mov eax, [rdi + 64]; // mov eax, [rdi + 128]; // mov eax, [rdi + 192]; // mov eax, [rdi + 256]; // If the original snippet is:; // mov eax, [memory]; // add eax, [memory]; // we might generate:; // mov eax, [rdi]; // add eax, [rdi + 64]; // mov eax, [rdi + 128]; // add eax, [rdi + 192]; // mov eax, [rdi + 256]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:3,Performance,Perform,Performance,3,// Performance counters may be unavailable for a number of reasons (such as; // kernel.perf_event_paranoid restriction or CPU being unknown to libpfm).; //; // Dummy event can be specified to skip interaction with real performance; // counters while still passing control to the generated code snippet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:219,Performance,perform,performance,219,// Performance counters may be unavailable for a number of reasons (such as; // kernel.perf_event_paranoid restriction or CPU being unknown to libpfm).; //; // Dummy event can be specified to skip interaction with real performance; // counters while still passing control to the generated code snippet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:47,Availability,avail,available,47,// We don't know beforehand which counters are available (e.g. 6 uops ports; // on Sandybridge but 8 on Haswell) so we report the missing counter without; // crashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:78,Safety,safe,safe,78,"// Reading a validation counter will only return a single value, so it is; // safe to only append the first value here. Also assert that this is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:13,Security,validat,validation,13,"// Reading a validation counter will only return a single value, so it is; // safe to only append the first value here. Also assert that this is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:125,Testability,assert,assert,125,"// Reading a validation counter will only return a single value, so it is; // safe to only append the first value here. Also assert that this is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:19,Availability,error,error,19,// Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:37,Security,access,access,37,// Dummy event that does not require access to counters (for tests).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:61,Testability,test,tests,61,// Dummy event that does not require access to counters (for tests).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:43,Modifiability,config,configured,43,// Represents a single event that has been configured in the Linux perf; // subsystem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:197,Energy Efficiency,schedul,scheduled,197,// Consists of a counter measuring a specific event and associated validation; // counters measuring execution conditions. All counters in a group are part; // of a single event group and are thus scheduled on and off the CPU as a single; // unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:67,Security,validat,validation,67,// Consists of a counter measuring a specific event and associated validation; // counters measuring execution conditions. All counters in a group are part; // of a single event group and are thus scheduled on and off the CPU as a single; // unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:48,Availability,error,error,48,"/// Returns the current value of the counter or error if it cannot be read.; /// FunctionBytes: The benchmark function being executed.; /// This is used to filter out the measurements to ensure they are only; /// within the benchmarked code.; /// If empty (or not specified), then no filtering will be done.; /// Not all counters choose to use this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:100,Testability,benchmark,benchmark,100,"/// Returns the current value of the counter or error if it cannot be read.; /// FunctionBytes: The benchmark function being executed.; /// This is used to filter out the measurements to ensure they are only; /// within the benchmarked code.; /// If empty (or not specified), then no filtering will be done.; /// Not all counters choose to use this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:224,Testability,benchmark,benchmarked,224,"/// Returns the current value of the counter or error if it cannot be read.; /// FunctionBytes: The benchmark function being executed.; /// This is used to filter out the measurements to ensure they are only; /// within the benchmarked code.; /// If empty (or not specified), then no filtering will be done.; /// Not all counters choose to use this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h:5,Performance,cache,cache,5,// A cache of existing trackers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h:28,Performance,cache,cache,28,// RegInfo must outlive the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h:17,Performance,optimiz,optimized,17,"// `a = a & ~b`, optimized for few bit sets in B and no allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterAliasing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterValue.h:5,Usability,simpl,simple,5,// A simple object storing the value for a particular register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/RegisterValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:18,Availability,redundant,redundant,18,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:88,Energy Efficiency,schedul,scheduling,88,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:507,Energy Efficiency,consumption,consumption,507,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:18,Safety,redund,redundant,18,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:20,Availability,mask,masks,20,// Collect resource masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:12,Performance,latency,latency,12,// Find the latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h:98,Energy Efficiency,schedul,scheduler,98,// Computes the idealized ProcRes Unit pressure. This is the expected; // distribution if the CPU scheduler can distribute the load as evenly as; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h:127,Performance,load,load,127,// Computes the idealized ProcRes Unit pressure. This is the expected; // distribution if the CPU scheduler can distribute the load as evenly as; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SerialSnippetGenerator.cpp:39,Modifiability,variab,variable,39,// Picking whatever value for the tied variable will make the instruction; // serial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SerialSnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SerialSnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:30,Testability,Benchmark,BenchmarkCode,30,// An MCStreamer that reads a BenchmarkCode definition from a file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:36,Integrability,interface,interface,36,// Implementation of the MCStreamer interface. We only care about; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:3,Security,Validat,Validate,3,// Validate that the annotation is a multiple of the platform's page; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:17,Security,validat,validate,17,// __linux__; // validate that the annotation refers to an already existing memory; // definition,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:3,Security,Validat,Validate,3,// Validate that the address in the annotation is a multiple of the; // platform's page size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:70,Safety,abort,abort,70,"// If the instruction implicitly writes to ScratchSpacePointerInReg , abort.; // FIXME: We could make a copy of the scratch register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:3,Safety,Avoid,Avoid,3,// Avoid reallocations in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:26,Testability,Benchmark,BenchmarkCode,26,// TODO: Generate as many BenchmarkCode as needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:36,Modifiability,config,configs,36,// We reached the number of allowed configs and return early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:85,Testability,benchmark,benchmarked,85,"// Mention the particular opcode - it is not necessarily the ""main""; // opcode being benchmarked by this snippet. For example, serial snippet; // generator uses one more opcode when in SERIAL_VIA_NON_MEMORY_INSTR; // execution mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:528,Performance,latency,latency,528,"//===-- SnippetGenerator.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract SnippetGenerator class for generating code that allows; /// measuring a certain property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:44,Integrability,depend,dependency,44,// Generates code templates that has a self-dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:24,Availability,failure,failures,24,"// A class representing failures that happened during Benchmark, they are used; // to report informations to the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:54,Testability,Benchmark,Benchmark,54,"// A class representing failures that happened during Benchmark, they are used; // to report informations to the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:23,Testability,benchmark,benchmark,23,// Common code for all benchmark modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:62,Testability,Benchmark,BenchmarkCode,62,// Calls generateCodeTemplate and expands it into one or more BenchmarkCode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:49,Deployability,configurat,configurations,49,// A global Random Number Generator to randomize configurations.; // FIXME: Move random number generation into an object and make it seedable for; // unit tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:49,Modifiability,config,configurations,49,// A global Random Number Generator to randomize configurations.; // FIXME: Move random number generation into an object and make it seedable for; // unit tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:155,Testability,test,tests,155,// A global Random Number Generator to randomize configurations.; // FIXME: Move random number generation into an object and make it seedable for; // unit tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:18,Deployability,configurat,configuration,18,"// Picks a random configuration, then selects a random def and a random use from; // it and finally set the selected values in the provided InstructionInstances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:18,Modifiability,config,configuration,18,"// Picks a random configuration, then selects a random def and a random use from; // it and finally set the selected values in the provided InstructionInstances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:33,Modifiability,Variab,Variables,33,// Assigns a Random Value to all Variables in IT that are still Invalid.; // Do not use any of the registers in `ForbiddenRegs`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:3,Safety,Sanity check,Sanity check,3,// Sanity check generated instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.cpp:208,Testability,test,tests,208,"// Add the PID to the shared memory name so that if we're running multiple; // processes at the same time, they won't interfere with each other.; // This comes up particularly often when running the exegesis tests with; // llvm-lit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.h:389,Performance,perform,performance,389,"// The following function sets up the auxiliary memory by opening shared; // memory objects backing memory definitions and putting file descriptors; // into appropriate places. Arguments: MemoryDefinitions - A map from memory; // values names to Memoryvalues, ParentPID - The ID of the process that; // setup the memory definitions, CounterFileDescriptor - The file descriptor; // for the performance counter that will be placed in the auxiliary memory; // section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SubprocessMemory.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:25,Performance,perform,performance,25,// An optional name of a performance counter that can be used to measure; // cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:25,Performance,perform,performance,25,// An optional name of a performance counter that can be used to measure; // uops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:36,Availability,avail,available,36,// Returns true if all features are available that are required by Opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:49,Modifiability,config,configure,49,// Generates the necessary ioctl system calls to configure the perf counters.; // The code generated by this function preserves all registers if the; // parameter SaveRegisters is set to true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:16,Integrability,depend,dependent,16,// Gets the ABI dependent registers that are used to pass arguments in a; // function call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:92,Testability,test,test,92,// Gets the registers that might potentially need to be saved by while; // the setup in the test harness executes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:114,Testability,benchmark,benchmark,114,"// Returns the register pointing to scratch memory, or 0 if this target; // does not support memory operands. The benchmark function uses the; // default calling convention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:21,Usability,usab,usable,21,// Returns a counter usable as a loop counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:139,Availability,avail,available,139,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:41,Performance,load,load,41,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:234,Performance,load,load,234,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:68,Security,access,access,68,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:49,Modifiability,variab,variable,49,// Assigns a random operand of the right type to variable Var.; // The target is responsible for handling any operand starting from; // OPERAND_FIRST_TARGET.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:103,Integrability,depend,depending,103,"// For some instructions, it is interesting to measure how it's performance; // characteristics differ depending on it's operands.; // This allows us to produce all the interesting variants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:64,Performance,perform,performance,64,"// For some instructions, it is interesting to measure how it's performance; // characteristics differ depending on it's operands.; // This allows us to produce all the interesting variants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:83,Availability,error,error,83,// Checks hardware and software support for current benchmark mode.; // Returns an error if the target host does not have support to run the; // benchmark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:52,Testability,benchmark,benchmark,52,// Checks hardware and software support for current benchmark mode.; // Returns an error if the target host does not have support to run the; // benchmark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:145,Testability,benchmark,benchmark,145,// Checks hardware and software support for current benchmark mode.; // Returns an error if the target host does not have support to run the; // benchmark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:13,Testability,benchmark,benchmark,13,// Creates a benchmark runner for the given mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:34,Safety,safe,safe,34,// Registers a target. Not thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:99,Performance,perform,performance,99,// Returns dummy Pfm counters which can be used to execute generated snippet; // without access to performance counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:89,Security,access,access,89,// Returns dummy Pfm counters which can be used to execute generated snippet; // without access to performance counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:65,Testability,benchmark,benchmark,65,"// Saves the CPU state that needs to be preserved when running a benchmark,; // and returns and RAII object that restores the state on destruction.; // By default no state is preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:54,Testability,benchmark,benchmarks,54,// Targets can implement their own snippet generators/benchmarks runners by; // implementing these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/UopsBenchmarkRunner.h:398,Testability,Benchmark,BenchmarkRunner,398,"//===-- UopsBenchmarkRunner.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A BenchmarkRunner implementation to measure uop decomposition.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/UopsBenchmarkRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/UopsBenchmarkRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/Target.cpp:28,Performance,load,load,28,// Generates instruction to load an immediate value into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/AArch64/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:14,Availability,error,error,14,// Returns an error if we cannot handle the memory references in this; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:24,Security,access,access,24,// These have no memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:9,Security,access,access,9,// These access memory and are handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:9,Security,access,access,9,// These access memory and are not handled yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:57,Performance,load,load,57,// end anonymous namespace; // Generates instructions to load an immediate value into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:51,Modifiability,extend,extending,51,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:40,Safety,avoid,avoid,40,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:301,Energy Efficiency,Power,PowerPC,301,"//===-- Target.cpp ----------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // The PowerPC ExegesisTarget.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:28,Performance,load,load,28,// Generates instruction to load an immediate value into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:64,Testability,benchmark,benchmark,64,"// R13 is reserved as Thread Pointer, we won't use threading in benchmark, so; // use it as scratch memory register",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:112,Usability,simpl,simplicity,112,"// We don't really care about the real address in snippets,; // So hardcode X1 for X-form Memory Operations for simplicity.; // TODO: materialize the offset into a reggister",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:102,Performance,load,load,102,"// X11 is optional use in function linkage, should be the least used one; // Use it as scratch reg to load immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:106,Deployability,update,update,106,"// We don't care the real value in reg, so set 64 bits or duplicate 64 bits; // for simplicity.; // TODO: update these if we need a accurate 128 values in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:84,Usability,simpl,simplicity,84,"// We don't care the real value in reg, so set 64 bits or duplicate 64 bits; // for simplicity.; // TODO: update these if we need a accurate 128 values in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:72,Performance,latency,latency-mode,72,"// If a positive value is specified, we are going to use the LBR in; // latency-mode.; //; // Note:; // - A small value is preferred, but too low a value could result in; // throttling.; // - A prime number is preferred to avoid always skipping certain blocks.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:223,Safety,avoid,avoid,223,"// If a positive value is specified, we are going to use the LBR in; // latency-mode.; //; // Note:; // - A small value is preferred, but too low a value could result in; // throttling.; // - A prime number is preferred to avoid always skipping certain blocks.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:10,Security,Validat,Validates,10,// FIXME: Validates that repetition-mode is loop if LBR is requested.; // Returns a non-null reason if we cannot handle the memory references in this; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:24,Security,access,access,24,// These have no memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:9,Security,access,access,9,// These access memory and are handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:9,Security,access,access,9,// These access memory and are not handled yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:11,Performance,latency,latency,11,"// Common (latency, uops) code for LEA templates. `GetDestReg` takes the; // addressing base and index registers and returns the LEA destination register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:224,Performance,latency,latency,224,// These are instructions like; // - `ST(0) = fsqrt(ST(0))` (OneArgFPRW); // - `ST(0) = ST(0) + ST(i)` (TwoArgFP); // They are intrinsically serial and do not modify the state of the stack.; // We generate the same code for latency and uops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:28,Performance,load,load,28,// Generates instruction to load an immediate value into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Energy Efficiency,Allocate,Allocates,3,// Allocates scratch memory on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Performance,Load,Loads,3,// Loads scratch memory into register `Reg` using opcode `RMOpcode`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Deployability,Release,Releases,3,// Releases scratch memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:115,Performance,load,load,115,"// Reserves some space on the stack, fills it with the content of the provided; // constant and provide methods to load the stack value into a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Availability,Mask,Mask,3,// Mask all FP exceptions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:50,Security,validat,validation,50,// TODO(boomanaiden154): Add in support for using validation counters when; // using LBR counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:123,Testability,benchmark,benchmarks,123,"// LBR is the only feature we conditionally support now.; // So if LBR is not requested, then we should be able to run the benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:64,Energy Efficiency,reduce,reduce,64,"// Optionally, also disable the upper (x86_64) SSE registers to reduce frontend; // decoder load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:92,Performance,load,load,92,"// Optionally, also disable the upper (x86_64) SSE registers to reduce frontend; // decoder load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:129,Performance,load,loaded,129,"// Preserve the syscall registers here as we don't; // want to make any assumptions about the ordering of what registers are; // loaded in first, and we might have already loaded in registers that we are; // going to be clobbering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:172,Performance,load,loaded,172,"// Preserve the syscall registers here as we don't; // want to make any assumptions about the ordering of what registers are; // loaded in first, and we might have already loaded in registers that we are; // going to be clobbering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:9,Availability,down,down,9,// Round down to the nearest page by getting rid of the least significant bits; // representing location in the page. Shift right to get rid of this info and; // then shift back left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:9,Performance,load,load,9,// Use a load effective address to get the current instruction pointer and put; // it into the result register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Performance,Load,Load,3,// Load in the size of the snippet to RDI from from the argument register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:114,Availability,down,down,114,// Add a one page to the start address to ensure that we're above the snippet; // since the above function rounds down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:43,Modifiability,variab,variable,43,"// __linux__; // Instruction can have some variable operands, and we may want to see how; // different operands affect performance. So for each operand position,; // precompute all the possible choices we might care about,; // and greedily generate all the possible combinations of choices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:119,Performance,perform,performance,119,"// __linux__; // Instruction can have some variable operands, and we may want to see how; // different operands affect performance. So for each operand position,; // precompute all the possible choices we might care about,; // and greedily generate all the possible combinations of choices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:44,Modifiability,variab,variable,44,// We don't wish to explicitly explore this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:41,Testability,log,logic,41,// But add invalid MCOperand to simplify logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:32,Usability,simpl,simplify,32,// But add invalid MCOperand to simplify logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:35,Modifiability,variab,variables,35,"// If we don't wish to explore any variables, defer to the baseline method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:26,Integrability,wrap,wrappers,26,// FIXME: Use appropriate wrappers for poll.h and mman.h; // to support Windows and remove this linux-only guard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:99,Energy Efficiency,allocate,allocate,99,"// First page is reserved for perf_event_mmap_page. Data buffer starts on; // the next page, so we allocate one more page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:3,Safety,timeout,timeout,3,/* timeout in ms */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:155,Testability,benchmark,benchmark,155,"// Parses the given data-buffer for stats and fill the CycleArray.; // If data has been extracted successfully, also modifies the code to jump; // out the benchmark loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h:472,Performance,throughput,throughput,472,"//===-- X86Counter.h --------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Perf counter that reads the LBRs for measuring the benchmarked block's; /// throughput.; ///; /// More info at: https://lwn.net/Articles/680985; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h:447,Testability,benchmark,benchmarked,447,"//===-- X86Counter.h --------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Perf counter that reads the LBRs for measuring the benchmarked block's; /// throughput.; ///; /// More info at: https://lwn.net/Articles/680985; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h:26,Integrability,wrap,wrappers,26,// FIXME: Use appropriate wrappers for poll.h and mman.h; // to support Windows and remove this linux-only guard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp:12,Performance,load,loading,12,"// Use lazy loading, since we only care about selected global values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp:20,Safety,avoid,avoid,20,// Use SetVector to avoid duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:146,Availability,error,errors,146,"// Make a stream refernce that will become a /dev/null log stream if; // Quiet is true, or normal output if Quiet is false. This can stop the; // errors and warnings from being displayed and producing too much output; // when they aren't desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:55,Testability,log,log,55,"// Make a stream refernce that will become a /dev/null log stream if; // Quiet is true, or normal output if Quiet is false. This can stop the; // errors and warnings from being displayed and producing too much output; // when they aren't desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:237,Performance,load,load,237,"// See if we can figure out the base address for a given object file, and if; // we can, then set the base address to use to this value. This will ease; // symbolication since clients can slide the GSYM lookup addresses by using; // the load bias of the shared library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:2,Availability,Recover,RecoverableErrorHandler,2,/*RecoverableErrorHandler=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:2,Safety,Recover,RecoverableErrorHandler,2,/*RecoverableErrorHandler=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:8,Availability,error,error,8,// Call error() if we have an error and it will exit with a status of 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:30,Availability,error,error,30,// Call error() if we have an error and it will exit with a status of 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:11,Security,access,access,11,// Dump or access data inside GSYM files,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp:7,Availability,Error,ErrorCollector,7,"//===- ErrorCollector.cpp -------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp:106,Availability,error,error,106,// TODO: Make this return something (an AggregateError?) that gives more; // individual control over each error and which might be of interest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:7,Availability,Error,ErrorCollector,7,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:405,Availability,error,errors,405,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:482,Availability,Error,Error,482,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:492,Availability,Error,ErrorCollector,492,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:538,Availability,Error,Error,538,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:553,Availability,Error,ErrorCollector,553,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:632,Availability,error,errors,632,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:671,Availability,Error,Errors,671,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:717,Availability,Error,ErrorCollector,717,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:791,Availability,error,errors,791,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:881,Availability,Error,ErrorCollector,881,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:906,Availability,Error,Errors,906,"//===- ErrorCollector.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===-----------------------------------------------------------------------===/; ///; /// This class collects errors that should be reported or ignored in aggregate.; ///; /// Like llvm::Error, an ErrorCollector cannot be copied. Unlike llvm::Error,; /// an ErrorCollector may be destroyed if it was originally constructed to treat; /// errors as non-fatal. In this case, all Errors are consumed upon destruction.; /// An ErrorCollector may be initially constructed (or escalated) such that; /// errors are treated as fatal. This causes a crash if an attempt is made to; /// delete the ErrorCollector when some Errors have not been retrieved via; /// makeError().; ///; //===-----------------------------------------------------------------------===/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:25,Availability,Error,ErrorCollector,25,"/// Upon destruction, an ErrorCollector will crash if UseFatalErrors=true and; /// there are remaining errors that haven't been fetched by makeError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:103,Availability,error,errors,103,"/// Upon destruction, an ErrorCollector will crash if UseFatalErrors=true and; /// there are remaining errors that haven't been fetched by makeError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:100,Availability,error,error,100,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:144,Availability,Error,Errors,144,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:120,Integrability,message,messages,120,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:51,Testability,test,testable,51,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:12,Availability,error,error,12,"/// Adds an error with a descriptive tag that helps with identification.; /// If the error is an Error::success(), it is checked and discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:85,Availability,error,error,85,"/// Adds an error with a descriptive tag that helps with identification.; /// If the error is an Error::success(), it is checked and discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:97,Availability,Error,Error,97,"/// Adds an error with a descriptive tag that helps with identification.; /// If the error is an Error::success(), it is checked and discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:20,Availability,Error,ErrorCollector,20,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:56,Availability,error,errors,56,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:112,Availability,error,errors,112,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:218,Availability,Error,Error,218,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:254,Availability,Error,Errors,254,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:13,Availability,error,errors,13,/// Logs all errors to a raw_ostream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:4,Testability,Log,Logs,4,/// Logs all errors to a raw_ostream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:24,Availability,error,errors,24,"/// Returns true if all errors have been retrieved through makeError(), or; /// false if errors have been added since the last makeError() call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:89,Availability,error,errors,89,"/// Returns true if all errors have been retrieved through makeError(), or; /// false if errors have been added since the last makeError() call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:37,Availability,error,error,37,"// If both readers fail, build a new error that includes all information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:39,Testability,stub,stub,39,/// writeIFS() writes a Text-Based ELF stub to a file using the latest version; /// of the YAML parser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:64,Safety,avoid,avoid,64,"// Compare IFS output with the existing IFS file. If unchanged, avoid; // changing the file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:33,Testability,stub,stubs,33,// Change SoName before emitting stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp:45,Safety,sanity check,sanity check,45,"//===-- DummyISelFuzzer.cpp - Entry point to sanity check the fuzzer ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp:426,Testability,test,test,426,"//===-- DummyISelFuzzer.cpp - Entry point to sanity check the fuzzer ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/DummyISelFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp:29,Usability,guid,guide,29,// use max bitcode size as a guide,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp:14,Deployability,pipeline,pipeline,14,// Set up the pipeline like llc does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp:65,Availability,error,errors,65,// Make sure we print the summary and the current unit when LLVM errors out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp:50,Safety,sanity check,sanity check,50,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp:426,Testability,test,test,426,"//===-- DummyDemanglerFuzzer.cpp - Entry point to sanity check the fuzzer -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-itanium-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:40,Integrability,interface,interface,40,"//===- llvm-jitlink.cpp -- Command line interface/tester for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple command line interface to the llvm jitlink; // library, which makes relocatable object files executable in memory. Its; // primary function is as a testing utility for the jitlink library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:427,Integrability,interface,interface,427,"//===- llvm-jitlink.cpp -- Command line interface/tester for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple command line interface to the llvm jitlink; // library, which makes relocatable object files executable in memory. Its; // primary function is as a testing utility for the jitlink library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:50,Testability,test,tester,50,"//===- llvm-jitlink.cpp -- Command line interface/tester for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple command line interface to the llvm jitlink; // library, which makes relocatable object files executable in memory. Its; // primary function is as a testing utility for the jitlink library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:562,Testability,test,testing,562,"//===- llvm-jitlink.cpp -- Command line interface/tester for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple command line interface to the llvm jitlink; // library, which makes relocatable object files executable in memory. Its; // primary function is as a testing utility for the jitlink library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:407,Usability,simpl,simple,407,"//===- llvm-jitlink.cpp -- Command line interface/tester for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility provides a simple command line interface to the llvm jitlink; // library, which makes relocatable object files executable in memory. Its; // primary function is as a testing utility for the jitlink library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:32,Testability,test,test,32,// If this graph is part of the test harness there's nothing to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:32,Testability,test,test,32,"// If this graph is part of the test then promote any symbols referenced by; // the harness to default scope, remove all symbols that clash with harness; // definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:68,Testability,test,testing,68,// A memory mapper with a fake offset applied only used for -noexec testing,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:20,Integrability,interface,interface,20,"// Get the standard interface for this object, but ignore the symbols field.; // We'll handle that manually to include promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:45,Integrability,depend,depends,45,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:29,Usability,Simpl,SimpleRemoteEPC,29,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:95,Availability,error,error,95,"// If we reached the end of the loop without connecting to a valid endpoint,; // dump the last error that was logged in socket() or connect().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:110,Testability,log,logged,110,"// If we reached the end of the loop without connecting to a valid endpoint,; // dump the last error that was logged in socket() or connect().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:45,Integrability,depend,depends,45,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:29,Usability,Simpl,SimpleRemoteEPC,29,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:30,Modifiability,Plugin,Plugin,30,/// Local ObjectLinkingLayer::Plugin class to forward modifyPassConfig to the; /// Session.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:107,Availability,avail,available,107,"// This symbol is used in testcases, but we're not reflecting process; // symbols so we'll need to make it available some other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:26,Testability,test,testcases,26,"// This symbol is used in testcases, but we're not reflecting process; // symbols so we'll need to make it available some other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:14,Testability,stub,stubs,14,// Let's keep stubs ordered by ascending address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:18,Testability,stub,stub,18,// Regular single-stub match,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:49,Testability,test,tests,49,// Disable debugger support by default in noexec tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:12,Energy Efficiency,allocate,allocate,12,"// If -slab-allocate is passed, check that we're not trying to use it in; // -oop-executor or -oop-executor-connect mode.; //; // FIXME: Remove once we enable remote slab allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:45,Energy Efficiency,allocate,allocate,45,"// If -slab-address is passed, require -slab-allocate and -noexec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:3,Performance,Load,Load,3,// Load each object into the corresponding JITDylib..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:40,Integrability,interface,interface,40,// We're in -harness mode. Use a custom interface for this; // test object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:63,Testability,test,test,63,// We're in -harness mode. Use a custom interface for this; // test object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:22,Performance,load,loads,22,// 2. Collect library loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:3,Performance,Queue,Queue,3,// Queue to load library as in the order as it appears in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:12,Performance,load,load,12,// Queue to load library as in the order as it appears in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:99,Availability,error,errors,99,// If there are any load-<modified> options then turn on flag overrides; // to avoid flag mismatch errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:20,Performance,load,load,20,// If there are any load-<modified> options then turn on flag overrides; // to avoid flag mismatch errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:79,Safety,avoid,avoid,79,// If there are any load-<modified> options then turn on flag overrides; // to avoid flag mismatch errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:16,Performance,load,loads,16,// Sort library loads by position in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:22,Performance,load,loads,22,// 3. Process library loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:19,Availability,error,error,19,// If there was an error loading the file then skip it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:25,Performance,load,loading,25,// If there was an error loading the file then skip it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:47,Performance,load,load,47,// We identified the magic. Assume that we can load it -- we'll reset; // in the default case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:39,Availability,avail,available,39,// Add platform and process symbols if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:31,Testability,test,test,31,// If the executing code set a test result override then use that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h:33,Testability,stub,stubs,33,"/// Record symbols, GOT entries, stubs, and sections for ELF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h:33,Testability,stub,stubs,33,"/// Record symbols, GOT entries, stubs, and sections for MachO file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h:33,Testability,stub,stubs,33,"/// Record symbols, GOT entries, stubs, and sections for COFF file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h:32,Modifiability,plugin,plugin,32,/// Adds a statistics gathering plugin if any stats options are used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:382,Usability,Simpl,Simple,382,"//===- llvm-jitlink-executor.cpp - Out-of-proc executor for llvm-jitlink -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple out-of-process executor for llvm-jitlink.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:34,Availability,error,errors,34,"// Avoid ""Address already in use"" errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:3,Safety,Avoid,Avoid,3,"// Avoid ""Address already in use"" errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:86,Integrability,Interface,Interface,86,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:25,Modifiability,plugin,plugins,25,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:460,Integrability,interface,interface,460,"//===-- llvm-jitlistener.cpp - Utility for testing MCJIT event listener ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a used by lit tests to verify the MCJIT JITEventListener; // interface. It registers a mock JIT event listener, generates a module from; // an input IR file and dumps the reported event information to stdout.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:43,Testability,test,testing,43,"//===-- llvm-jitlistener.cpp - Utility for testing MCJIT event listener ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a used by lit tests to verify the MCJIT JITEventListener; // interface. It registers a mock JIT event listener, generates a module from; // an input IR file and dumps the reported event information to stdout.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:413,Testability,test,tests,413,"//===-- llvm-jitlistener.cpp - Utility for testing MCJIT event listener ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a used by lit tests to verify the MCJIT JITEventListener; // interface. It registers a mock JIT event listener, generates a module from; // an input IR file and dumps the reported event information to stdout.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:486,Testability,mock,mock,486,"//===-- llvm-jitlistener.cpp - Utility for testing MCJIT event listener ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is a used by lit tests to verify the MCJIT JITEventListener; // interface. It registers a mock JIT event listener, generates a module from; // an input IR file and dumps the reported event information to stdout.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:7,Testability,test,testing,7,"// for testing, pretend we have an Intel Parallel Amplifier XE 2011; // instance attached",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp:79,Usability,usab,usable,79,"// If we have a native target, initialize it to ensure it is linked in and; // usable by the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlistener/llvm-jitlistener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h:8,Integrability,Depend,DependencyInfo,8,"//===-- DependencyInfo.h --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h:14,Integrability,depend,dependencies,14,// Writes the dependencies to specified path. The content is first sorted by; // OpCode and then by the filename (in alphabetical order).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h:15,Safety,avoid,avoid,15,// Subclass to avoid any overhead when not using this feature,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:3,Deployability,Update,Updated,3,// Updated by 'D' and 'U' modifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,Availability,error,error,9,// Throw error if not a valid object file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,Availability,error,error,9,// Throw error if not in Mach-O format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,Availability,error,error,9,// Throw error if not a valid IR object file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:3,Deployability,Update,Update,3,// Update vector FileBuffers with the MemoryBuffers to transfer; // ownership.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:177,Availability,error,error,177,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an; // IRObject, it is safe to throw away the error generated due to; // casting the object as a MachOObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:154,Safety,safe,safe,154,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an; // IRObject, it is safe to throw away the error generated due to; // casting the object as a MachOObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:176,Availability,error,error,176,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an Archive,; // it is safe to throw away the error generated due to casting the; // object as a MachOObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:153,Safety,safe,safe,153,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an Archive,; // it is safe to throw away the error generated due to casting the; // object as a MachOObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:3,Deployability,Update,Update,3,// Update vector FileBuffers with the MemoryBuffers to transfer; // ownership.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:45,Testability,test,testing,45,// Option to simulate function importing for testing. This enables using; // llvm-link to simulate ThinLTO backend processes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:21,Testability,test,testing,21,"// Option to support testing of function importing. The module summary; // must be specified in the case were we request imports via the -import; // option, as well as when compiling any module with functions that may be; // exported (imported by a different llvm-link -import invocation), to ensure; // consistent promotion and renaming of locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:58,Integrability,rout,routine,58,// Read the specified bitcode file in and return it. This routine searches the; // link path for the specified file to try to find it...; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:14,Performance,load,load,14,/// Helper to load on demand a Module from file and cache it for subsequent; /// queries during function importing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:52,Performance,cache,cache,52,/// Helper to load on demand a Module from file and cache it for subsequent; /// queries during function importing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:4,Performance,Cache,Cache,4,/// Cache of lazily loaded module for import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:20,Performance,load,loaded,20,/// Cache of lazily loaded module for import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:31,Performance,cache,cache,31,/// Retrieve a Module from the cache or lazily load it on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:47,Performance,load,load,47,/// Retrieve a Module from the cache or lazily load it on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:15,Performance,load,loader,15,"/// Create the loader, Module will be initialized in \p Context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:31,Performance,cache,cache,31,/// Retrieve a Module from the cache or lazily load it on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:47,Performance,load,load,47,/// Retrieve a Module from the cache or lazily load it on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:41,Performance,cache,cache,41,"// Get a Module for \p FileName from the cache, or load it lazily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:51,Performance,load,load,51,"// Get a Module for \p FileName from the cache, or load it lazily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:232,Performance,cache,cache,232,"// Owns the filename strings used to key into the ImportList. Normally this is; // constructed from the index and the strings are owned by the index, however,; // since we are synthesizing this data structure from options we need a cache; // to own those strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:3,Performance,Load,Load,3,// Load the specified source module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:58,Performance,load,load,58,// Filter out flags that don't apply to the first file we load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:96,Modifiability,variab,variables,96,"// If a module summary index is supplied, load it so linkInModule can treat; // local functions/variables as exported and promote if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:42,Performance,load,load,42,"// If a module summary index is supplied, load it so linkInModule can treat; // local functions/variables as exported and promote if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp:3,Availability,error,errors,3,"// errors if multiple actions specified other than replace; // multiple replace flags may be specified, as long as they are not mixed with; // other action flags",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp:46,Testability,test,tested,46,"// This should be always the case, as this is tested in readInputBinaries",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp:3,Deployability,Update,Updates,3,// Updates vector ExtractedObjects with the MachOObjectFiles extracted from; // Universal Binary files to transfer ownership.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp:50,Availability,error,error,50,"// populates StringMap of slices to replace with; error checks for mismatched; // replace flag args, fat files, and duplicate arch_types",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lipo/llvm-lipo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:442,Performance,perform,performs,442,"//===- llvm-lto: a simple command-line program to link modules with LTO ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them, performs link-time; // optimization, and outputs an object file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:465,Performance,optimiz,optimization,465,"//===- llvm-lto: a simple command-line program to link modules with LTO ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them, performs link-time; // optimization, and outputs an object file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:19,Usability,simpl,simple,19,"//===- llvm-lto: a simple command-line program to link modules with LTO ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them, performs link-time; // optimization, and outputs an object file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load each IR file and dump certain information based on active flags.; ///; /// The main point here is to provide lit-testable coverage for the LTOModule; /// functionality that's exposed by the C API. Moreover, this provides testing; /// coverage for modules that have been created in their own contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:184,Security,expose,exposed,184,"/// Load each IR file and dump certain information based on active flags.; ///; /// The main point here is to provide lit-testable coverage for the LTOModule; /// functionality that's exposed by the C API. Moreover, this provides testing; /// coverage for modules that have been created in their own contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:122,Testability,test,testable,122,"/// Load each IR file and dump certain information based on active flags.; ///; /// The main point here is to provide lit-testable coverage for the LTOModule; /// functionality that's exposed by the C API. Moreover, this provides testing; /// coverage for modules that have been created in their own contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:230,Testability,test,testing,230,"/// Load each IR file and dump certain information based on active flags.; ///; /// The main point here is to provide lit-testable coverage for the LTOModule; /// functionality that's exposed by the C API. Moreover, this provides testing; /// coverage for modules that have been created in their own contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:12,Integrability,depend,dependent,12,// List the dependent libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:166,Availability,avail,available,166,"/// Create a combined index file from the input IR files and write it.; ///; /// This is meant to enable testing of ThinLTO combined index generation,; /// currently available via the gold plugin via -thinlto.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:189,Modifiability,plugin,plugin,189,"/// Create a combined index file from the input IR files and write it.; ///; /// This is meant to enable testing of ThinLTO combined index generation,; /// currently available via the gold plugin via -thinlto.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:105,Testability,test,testing,105,"/// Create a combined index file from the input IR files and write it.; ///; /// This is meant to enable testing of ThinLTO combined index generation,; /// currently available via the gold plugin via -thinlto.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:87,Deployability,update,update,87,"// In order to use this index for testing, specifically import testing, we; // need to update any indirect call edges created from SamplePGO, so that they; // point to the correct GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:34,Testability,test,testing,34,"// In order to use this index for testing, specifically import testing, we; // need to update any indirect call edges created from SamplePGO, so that they; // point to the correct GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:63,Testability,test,testing,63,"// In order to use this index for testing, specifically import testing, we; // need to update any indirect call edges created from SamplePGO, so that they; // point to the correct GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:180,Usability,GUID,GUIDs,180,"// In order to use this index for testing, specifically import testing, we; // need to update any indirect call edges created from SamplePGO, so that they; // point to the correct GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the input files, create the combined index, and write it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:3,Performance,Perform,Perform,3,"// Perform ""ThinLink"": just produce the index",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the combined index from disk, then compute and generate; /// individual index files suitable for ThinLTO distributed backend builds; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:32,Usability,GUID,GUIDs,32,// Build a map of module to the GUIDs and summary objects that should; // be written to its index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the combined index from disk, compute the imports, and emit; /// the import file lists for each module to disk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, finally perform the promotion; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:44,Performance,load,load,44,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, finally perform the promotion; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:128,Performance,perform,perform,128,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, finally perform the promotion; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, then performs the promotion and; /// cross module importing on the files mentioned on the command line; /// (these must match the index content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:44,Performance,load,load,44,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, then performs the promotion and; /// cross module importing on the files mentioned on the command line; /// (these must match the index content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:125,Performance,perform,performs,125,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, then performs the promotion and; /// cross module importing on the files mentioned on the command line; /// (these must match the index content).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Performance,Load,Load,4,"/// Load the combined index from disk, then load every file referenced by",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:44,Performance,load,load,44,"/// Load the combined index from disk, then load every file referenced by",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:18,Modifiability,config,configured,18,// Initialize the configured targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:11,Integrability,message,message,11,// Print a message here so that we know addModule() did not abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:60,Safety,abort,abort,60,// Print a message here so that we know addModule() did not abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:54,Security,expose,expose,54,// Add all the dso symbols to the table of symbols to expose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:14,Integrability,message,messages,14,// Diagnostic messages should have been printed by the handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:14,Integrability,message,messages,14,// Diagnostic messages should have been printed by the handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:14,Integrability,message,messages,14,// Diagnostic messages should have been printed by the handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:61,Integrability,interface,interface,61,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:561,Integrability,interface,interface,561,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:704,Integrability,interface,interface,704,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:445,Performance,perform,performs,445,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:468,Performance,optimiz,optimization,468,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:19,Testability,test,test,19,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:24,Availability,avail,available,24,"// Default to using all available threads in the system, but using only one; // thread per core (no SMT).; // Use -thinlto-threads=all to use hardware_concurrency() instead, which means; // to use all hardware threads or cores in the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:3,Performance,Optimiz,Optimization,3,// Optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:16,Deployability,pipeline,pipeline,16,"// Run a custom pipeline, if asked for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:27,Availability,error,error,27,"// Track whether we hit an error; in particular, in the multi-threaded case,; // we can't exit() early because the rest of the threads wouldn't have had a; // change to be join-ed, and that would result in a ""terminate called without; // an active exception"". Altogether, this results in nondeterministic; // behavior. Instead, we don't exit in the multi-threaded case, but we make; // sure to report the error and then at the end (after joining cleanly); // exit(1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:405,Availability,error,error,405,"// Track whether we hit an error; in particular, in the multi-threaded case,; // we can't exit() early because the rest of the threads wouldn't have had a; // change to be join-ed, and that would result in a ""terminate called without; // an active exception"". Altogether, this results in nondeterministic; // behavior. Instead, we don't exit in the multi-threaded case, but we make; // sure to report the error and then at the end (after joining cleanly); // exit(1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:56,Performance,multi-thread,multi-threaded,56,"// Track whether we hit an error; in particular, in the multi-threaded case,; // we can't exit() early because the rest of the threads wouldn't have had a; // change to be join-ed, and that would result in a ""terminate called without; // an active exception"". Altogether, this results in nondeterministic; // behavior. Instead, we don't exit in the multi-threaded case, but we make; // sure to report the error and then at the end (after joining cleanly); // exit(1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:349,Performance,multi-thread,multi-threaded,349,"// Track whether we hit an error; in particular, in the multi-threaded case,; // we can't exit() early because the rest of the threads wouldn't have had a; // change to be join-ed, and that would result in a ""terminate called without; // an active exception"". Altogether, this results in nondeterministic; // behavior. Instead, we don't exit in the multi-threaded case, but we make; // sure to report the error and then at the end (after joining cleanly); // exit(1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:83,Security,hash,hash,83,"// If it isn't found, look for ""."", which would have been added; // (followed by a hash) when the symbol was promoted during module; // splitting if it was defined in one part and used in the other.; // Try looking up the symbol name before the suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp:17,Availability,error,error,17,"// If we have an error, print it and skip to the end of line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/Disassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:401,Usability,simpl,simple,401,"//===-- llvm-mc.cpp - Machine Code Hacking Driver ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility is a simple driver that allows command line hacking on machine; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:3,Deployability,Update,Update,3,// Update the triple name and return the found target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:68,Safety,safe,safe,68,"// Now that GetTarget() has (potentially) replaced TripleName, it's safe to; // construct the Triple object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:21,Availability,error,errors,21,// Keep output if no errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:22,Modifiability,variab,variable-length,22,// This is useful for variable-length instruction sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:1109,Safety,redund,redundancy,1109,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:403,Testability,test,test,403,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:831,Testability,test,tested,831,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:986,Testability,test,test,986,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:1034,Testability,test,test,1034,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:294,Safety,avoid,avoid,294,// Rebuild the argv without the arguments llvm-mc-fuzzer consumed so that; // the driver can parse its arguments.; //; // FuzzerArgs cannot provide the non-const pointer that OriginalArgv needs.; // Re-use the strings from OriginalArgv instead of copying FuzzerArg to a; // non-const buffer to avoid the need to clean up when the fuzzer terminates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:22,Modifiability,variab,variable-length,22,// This is useful for variable-length instruction sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:1109,Safety,redund,redundancy,1109,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:403,Testability,test,test,403,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:831,Testability,test,tested,831,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:986,Testability,test,test,986,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:1034,Testability,test,test,1034,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp:294,Safety,avoid,avoid,294,// Rebuild the argv without the arguments llvm-mc-fuzzer consumed so that; // the driver can parse its arguments.; //; // FuzzerArgs cannot provide the non-const pointer that OriginalArgv needs.; // Re-use the strings from OriginalArgv instead of copying FuzzerArg to a; // non-const buffer to avoid the need to clean up when the fuzzer terminates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-disassemble-fuzzer/llvm-mc-disassemble-fuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp:446,Integrability,interface,interface,446,"//===-------------------------- CodeRegion.cpp -----------------*- C++ -* -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements methods from the CodeRegions interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp:170,Usability,simpl,simply,170,"// Special case where there is only one user defined region,; // and this LLVM-MCA-END directive doesn't provide a region name.; // In this case, we assume that the user simply wanted to just terminate; // the only active region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.h:1986,Availability,avail,available,1986,"-------------------------------------------------------===//; /// \file; ///; /// This file implements class CodeRegion and CodeRegions, InstrumentRegion,; /// AnalysisRegions, and InstrumentRegions.; ///; /// A CodeRegion describes a region of assembly code guarded by special LLVM-MCA; /// comment directives.; ///; /// # LLVM-MCA-BEGIN foo; /// ... ## asm; /// # LLVM-MCA-END; ///; /// A comment starting with substring LLVM-MCA-BEGIN marks the beginning of a; /// new region of code.; /// A comment starting with substring LLVM-MCA-END marks the end of the; /// last-seen region of code.; ///; /// Code regions are not allowed to overlap. Each region can have a optional; /// description; internally, regions are described by a range of source; /// locations (SMLoc objects).; ///; /// An instruction (a MCInst) is added to a CodeRegion R only if its; /// location is in range [R.RangeStart, R.RangeEnd].; ///; /// A InstrumentRegion describes a region of assembly code guarded by; /// special LLVM-MCA comment directives.; ///; /// # LLVM-MCA-<INSTRUMENTATION_TYPE> <data>; /// ... ## asm; ///; /// where INSTRUMENTATION_TYPE is a type defined in llvm and expects to use; /// data.; ///; /// A comment starting with substring LLVM-MCA-<INSTRUMENTATION_TYPE>; /// brings data into scope for llvm-mca to use in its analysis for; /// all following instructions.; ///; /// If the same INSTRUMENTATION_TYPE is found later in the instruction list,; /// then the original InstrumentRegion will be automatically ended,; /// and a new InstrumentRegion will begin.; ///; /// If there are comments containing the different INSTRUMENTATION_TYPEs,; /// then both data sets remain available. In contrast with a CodeRegion,; /// an InstrumentRegion does not need a comment to end the region.; //; // An instruction (a MCInst) is added to an InstrumentRegion R only; // if its location is in range [R.RangeStart, R.RangeEnd].; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegionGenerator.cpp:6,Availability,error,error,6,// An error if not of the form LLVM-MCA-TARGET-KIND,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegionGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegionGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:434,Performance,perform,performance,434,"//===-- llvm-mca.cpp - Machine Code Analyzer -------------------*- C++ -* -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility is a simple driver that allows static performance analysis on; // machine code similarly to how IACA (Intel Architecture Code Analyzer) works.; //; // llvm-mca [options] <file-name>; // -march <type>; // -mcpu <cpu>; // -o <file>; //; // The target defaults to the host target.; // The cpu defaults to the 'native' host cpu.; // The output defaults to standard output.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:401,Usability,simpl,simple,401,"//===-- llvm-mca.cpp - Machine Code Analyzer -------------------*- C++ -* -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility is a simple driver that allows static performance analysis on; // machine code similarly to how IACA (Intel Architecture Code Analyzer) works.; //; // llvm-mca [options] <file-name>; // -march <type>; // -mcpu <cpu>; // -o <file>; //; // The target defaults to the host target.; // The cpu defaults to the 'native' host cpu.; // The output defaults to standard output.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:3,Deployability,Update,Update,3,// Update TripleName with the updated triple from the target lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:30,Deployability,update,updated,30,// Update TripleName with the updated triple from the target lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:19,Availability,error,errors,19,// Handle pipeline errors here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:10,Deployability,pipeline,pipeline,10,// Handle pipeline errors here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:22,Availability,avail,available,22,// Enable printing of available targets when flag --version is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:195,Availability,error,error,195,"// Get the target from the triple. If a triple is not specified, then select; // the default triple for the host. If the triple doesn't correspond to any; // registered target, then exit with an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:201,Integrability,message,message,201,"// Get the target from the triple. If a triple is not specified, then select; // the default triple for the host. If the triple doesn't correspond to any; // registered target, then exit with an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:70,Safety,safe,safety,70,"// GetTarget() may replaced TripleName with a default triple.; // For safety, reconstruct the Triple object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:17,Availability,error,errors,17,// Early exit if errors were found by the code region parsing logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:62,Testability,log,logic,62,// Early exit if errors were found by the code region parsing logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:17,Availability,error,errors,17,// Early exit if errors were found by the instrumentation parsing logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:66,Testability,log,logic,66,// Early exit if errors were found by the instrumentation parsing logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:216,Deployability,toggle,toggled,216,// TODO: It may be a good idea to separate CB and IPP so that they can; // be used independently of each other. What I mean by this is to add; // an extra command-line arg --disable-ipp so that CB and IPP can be; // toggled without needing to toggle both of them together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:243,Deployability,toggle,toggle,243,// TODO: It may be a good idea to separate CB and IPP so that they can; // be used independently of each other. What I mean by this is to add; // an extra command-line arg --disable-ipp so that CB and IPP can be; // toggled without needing to toggle both of them together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:48,Deployability,pipeline,pipeline,48,// Create a context to control ownership of the pipeline hardware.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:12,Deployability,pipeline,pipeline,12,"// Create a pipeline, stages, and a printer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:29,Deployability,pipeline,pipeline,29,"// Create the views for this pipeline, execute, and emit a report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:86,Integrability,depend,dependencies,86,// Create the CustomBehaviour object for enforcing Target Specific; // behaviours and dependencies that aren't expressed well enough; // in the tablegen. CB cannot depend on the list of MCInst or; // the source code (but it can depend on the list of; // mca::Instruction or any objects that can be reconstructed; // from the target information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:164,Integrability,depend,depend,164,// Create the CustomBehaviour object for enforcing Target Specific; // behaviours and dependencies that aren't expressed well enough; // in the tablegen. CB cannot depend on the list of MCInst or; // the source code (but it can depend on the list of; // mca::Instruction or any objects that can be reconstructed; // from the target information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:228,Integrability,depend,depend,228,// Create the CustomBehaviour object for enforcing Target Specific; // behaviours and dependencies that aren't expressed well enough; // in the tablegen. CB cannot depend on the list of MCInst or; // the source code (but it can depend on the list of; // mca::Instruction or any objects that can be reconstructed; // from the target information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:18,Deployability,pipeline,pipeline,18,// Create a basic pipeline simulating an out-of-order backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:396,Integrability,depend,depend,396,"// Targets can define their own custom Views that exist within their; // /lib/Target/ directory so that the View can utilize their CustomBehaviour; // or other backend symbols / functionality that are not already exposed; // through one of the MC-layer classes. These Views will be initialized; // using the CustomBehaviour::getViews() variants.; // If a target makes a custom View that does not depend on their target; // CB or their backend, they should put the View within; // /tools/llvm-mca/Views/ instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:213,Security,expose,exposed,213,"// Targets can define their own custom Views that exist within their; // /lib/Target/ directory so that the View can utilize their CustomBehaviour; // or other backend symbols / functionality that are not already exposed; // through one of the MC-layer classes. These Views will be initialized; // using the CustomBehaviour::getViews() variants.; // If a target makes a custom View that does not depend on their target; // CB or their backend, they should put the View within; // /tools/llvm-mca/Views/ instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp:27,Deployability,Pipeline,PipelinePrinter,27,"//===--------------------- PipelinePrinter.cpp ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the PipelinePrinter interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp:421,Deployability,Pipeline,PipelinePrinter,421,"//===--------------------- PipelinePrinter.cpp ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the PipelinePrinter interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp:437,Integrability,interface,interface,437,"//===--------------------- PipelinePrinter.cpp ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the PipelinePrinter interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h:27,Deployability,Pipeline,PipelinePrinter,27,"//===--------------------- PipelinePrinter.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements class PipelinePrinter.; ///; /// PipelinePrinter allows the customization of the performance report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h:423,Deployability,Pipeline,PipelinePrinter,423,"//===--------------------- PipelinePrinter.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements class PipelinePrinter.; ///; /// PipelinePrinter allows the customization of the performance report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h:450,Deployability,Pipeline,PipelinePrinter,450,"//===--------------------- PipelinePrinter.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements class PipelinePrinter.; ///; /// PipelinePrinter allows the customization of the performance report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h:498,Performance,perform,performance,498,"//===--------------------- PipelinePrinter.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements class PipelinePrinter.; ///; /// PipelinePrinter allows the customization of the performance report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:27,Performance,Bottleneck,BottleneckAnalysis,27,"//===--------------------- BottleneckAnalysis.cpp ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the functionalities used by the BottleneckAnalysis; /// to report bottleneck info.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:449,Performance,Bottleneck,BottleneckAnalysis,449,"//===--------------------- BottleneckAnalysis.cpp ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the functionalities used by the BottleneckAnalysis; /// to report bottleneck info.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:483,Performance,bottleneck,bottleneck,483,"//===--------------------- BottleneckAnalysis.cpp ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the functionalities used by the BottleneckAnalysis; /// to report bottleneck info.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:441,Integrability,depend,dependencies,441,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:587,Integrability,depend,dependencies,587,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:393,Performance,perform,performance,393,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:495,Performance,latency,latency,495,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:1141,Usability,simpl,simplicity,1141,"// A critical sequence is computed as the longest path from a node of the; // RootSet to a leaf node (i.e. a node with no successors). The RootSet is; // composed of nodes with at least one successor, and no predecessors.; //; // Each node of the graph starts with an initial default cost of zero. The; // cost of a node is a measure of criticality: the higher the cost, the bigger; // is the performance impact.; // For register and memory dependencies, the cost is a function of the write; // latency as well as the actual delay (in cycles) caused to users.; // For processor resource dependencies, the cost is a function of the resource; // pressure. Resource interferences with low frequency values are ignored.; //; // This algorithm is very similar to a (reverse) Dijkstra. Every iteration of; // the inner loop selects (i.e. visits) a node N from a set of `unvisited; // nodes`, and then propagates the cost of N to all its neighbors.; //; // The `unvisited nodes` set initially contains all the nodes from the; // RootSet. A node N is added to the `unvisited nodes` if all its; // predecessors have been visited already.; //; // For simplicity, every node tracks the number of unvisited incoming edges in; // field `NumVisitedPredecessors`. When the value of that field drops to; // zero, then the corresponding node is added to a `ToVisit` set.; //; // At the end of every iteration of the outer loop, set `ToVisit` becomes our; // new `unvisited nodes` set.; //; // The algorithm terminates when the set of unvisited nodes (i.e. our RootSet); // is empty. This algorithm works under the assumption that the graph is; // acyclic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:79,Deployability,update,update,79,"// Check if this is the most expensive incoming edge seen so far. In; // case, update the total cost of the destination node (ToIID), as well; // its field `CriticalPredecessor`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:417,Usability,simpl,simply,417,"// At this stage, nodes of the graph have been already visited, and costs have; // been propagated through the edges (see method `propagateThroughEdges()`).; // Identify the node N with the highest cost in the graph. By construction,; // that node is the last instruction of our critical sequence.; // Field N.Depth would tell us the total length of the sequence.; //; // To obtain the sequence of critical edges, we simply follow the chain of; // critical predecessors starting from node N (field; // DGNode::CriticalPredecessor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:20,Performance,bottleneck,bottlenecks,20,// Early exit if no bottlenecks were found during the simulation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1221,Deployability,pipeline,pipeline,1221,".; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1535,Deployability,pipeline,pipelines,1535,"internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track de",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:563,Integrability,depend,dependencies,563,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:875,Integrability,Depend,Dependencies,875,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:915,Integrability,Depend,Dependencies,915,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:952,Integrability,Depend,Dependencies,952,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1671,Integrability,depend,dependent,1671,"ttleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or proce",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1847,Integrability,Depend,Dependency,1847,"[ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edge",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:2140,Integrability,depend,dependency,2140," the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:2420,Integrability,depend,dependency,2420,"en the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:2465,Integrability,depend,dependencies,2465,"en the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:2617,Integrability,depend,dependencies,2617,"ck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is reported as critical; /// sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:2868,Integrability,depend,dependency,2868,"ck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is reported as critical; /// sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:27,Performance,Bottleneck,BottleneckAnalysis,27,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:421,Performance,bottleneck,bottleneck,421,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:635,Performance,bottleneck,bottleneck,635,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:759,Performance,Throughput,Throughput,759,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:770,Performance,Bottleneck,Bottlenecks,770,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1560,Performance,bottleneck,bottleneck,1560,"ttleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or proce",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:3141,Performance,latency,latency,3141,"ck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is reported as critical; /// sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1200,Security,access,accessible,1200,".; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:104,Energy Efficiency,schedul,scheduling,104,// Resource pressure distribution. There is an element for every processor; // resource declared by the scheduling model. Quantities are number of cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:81,Availability,mask,mask,81,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:170,Availability,mask,masks,170,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:254,Energy Efficiency,schedul,scheduling,254,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:90,Availability,Mask,Mask,90,// Maps processor resource state indices (returned by calls to; // `getResourceStateIndex(Mask)` to processor resource identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:77,Deployability,update,updated,77,// Identifies the last user of a processor resource unit.; // This vector is updated on every instruction issued event.; // There is one entry for every processor resource unit declared by the; // processor model. An all_ones value is treated like an invalid instruction; // identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:5,Integrability,depend,dependency,5,// A dependency edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:3,Integrability,Depend,Dependency,3,"// Dependency edge descriptor.; //; // It specifies the dependency type, as well as the edge cost in cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:56,Integrability,depend,dependency,56,"// Dependency edge descriptor.; //; // It specifies the dependency type, as well as the edge cost in cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:15,Performance,bottleneck,bottleneck,15,// Used by the bottleneck analysis to compute the interference; // probability for processor resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:987,Energy Efficiency,allocate,allocated,987,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:5,Integrability,depend,dependency,5,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:75,Integrability,depend,dependencies,75,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:289,Integrability,depend,dependencies,289,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:428,Integrability,depend,dependency,428,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:503,Integrability,Depend,DependencyEdge,503,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:519,Integrability,Depend,Dependency,519,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:646,Integrability,depend,dependency,646,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:730,Integrability,depend,dependency,730,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:840,Integrability,depend,dependencies,840,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:34,Performance,bottleneck,bottleneck,34,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:480,Performance,perform,performance,480,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:611,Performance,perform,performance,611,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:683,Performance,latency,latency,683,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:883,Performance,bottleneck,bottleneck,883,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1126,Usability,simpl,simplifies,1126,"// A dependency graph used by the bottleneck analysis to describe data; // dependencies and processor resource interferences between instructions.; //; // There is a node (an instance of struct DGNode) for every instruction in the; // input assembly sequence. Edges of the graph represent dependencies between; // instructions.; //; // Each edge of the graph is associated with a cost value which is used; // internally to rank dependency based on their impact on the runtime; // performance (see field DependencyEdge::Dependency::Cost). In general, the; // higher the cost of an edge, the higher the impact on performance.; //; // The cost of a dependency is a function of both the latency and the number of; // cycles where the dependency has been seen as critical (i.e. contributing to; // back-pressure increases).; //; // Loop carried dependencies are carefully expanded by the bottleneck analysis; // to guarantee that the graph stays acyclic. To this end, extra nodes are; // pre-allocated at construction time to describe instructions from ""past and; // future"" iterations. The graph is kept acyclic mainly because it simplifies; // the complexity of the algorithm that computes the critical sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:17,Performance,bottleneck,bottleneck,17,"// Called by the bottleneck analysis at the end of simulation to propagate; // costs through the edges of the graph, and compute a critical path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:42,Performance,perform,performance,42,/// A view that collects and prints a few performance numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:11,Performance,throughput,throughput,11,// True if throughput was affected by dispatch stalls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:50,Deployability,pipeline,pipeline,50,// Cycles where backpressure increased because of pipeline pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:55,Integrability,depend,dependencies,55,// Cycles where backpressure increased because of data dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:59,Integrability,depend,dependencies,59,// Cycles where backpressure increased because of register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:57,Integrability,depend,dependencies,57,// Cycles where backpressure increased because of memory dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:24,Integrability,depend,dependency,24,// Used to populate the dependency graph DG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:23,Integrability,message,message,23,// Prints a bottleneck message to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:12,Performance,bottleneck,bottleneck,12,// Prints a bottleneck message to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.cpp:440,Integrability,interface,interface,440,"//===--------------------- DispatchStatistics.cpp ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the DispatchStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:759,Energy Efficiency,Schedul,Scheduler,759,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:788,Performance,Load,Load,788,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:793,Performance,queue,queue,793,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:823,Performance,queue,queue,823,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:482,Testability,log,logic,482,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:919,Testability,Log,Logic,919,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp:14,Energy Efficiency,schedul,scheduling,14,// Obtain the scheduling class information from the instruction; // and instruments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp:24,Energy Efficiency,schedul,scheduling,24,// Try to solve variant scheduling classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp:13,Performance,latency,latency,13,// Add extra latency due to delays in the forwarding data paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h:508,Performance,latency,latency,508,"//===--------------------- InstructionInfoView.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the instruction info view.; ///; /// The goal fo the instruction info view is to print the latency and reciprocal; /// throughput information for every instruction in the input sequence.; /// This section also reports extra information related to the number of micro; /// opcodes, and opcode properties (i.e. 'MayLoad', 'MayStore', 'HasSideEffects); ///; /// Example:; ///; /// Instruction Info:; /// [1]: #uOps; /// [2]: Latency; /// [3]: RThroughput; /// [4]: MayLoad; /// [5]: MayStore; /// [6]: HasSideEffects; ///; /// [1] [2] [3] [4] [5] [6]	Instructions:; /// 1 2 1.00 	vmulps	%xmm0, %xmm1, %xmm2; /// 1 3 1.00 	vhaddps	%xmm2, %xmm2, %xmm3; /// 1 3 1.00 	vhaddps	%xmm3, %xmm3, %xmm4; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h:536,Performance,throughput,throughput,536,"//===--------------------- InstructionInfoView.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the instruction info view.; ///; /// The goal fo the instruction info view is to print the latency and reciprocal; /// throughput information for every instruction in the input sequence.; /// This section also reports extra information related to the number of micro; /// opcodes, and opcode properties (i.e. 'MayLoad', 'MayStore', 'HasSideEffects); ///; /// Example:; ///; /// Instruction Info:; /// [1]: #uOps; /// [2]: Latency; /// [3]: RThroughput; /// [4]: MayLoad; /// [5]: MayStore; /// [6]: HasSideEffects; ///; /// [1] [2] [3] [4] [5] [6]	Instructions:; /// 1 2 1.00 	vmulps	%xmm0, %xmm1, %xmm2; /// 1 3 1.00 	vhaddps	%xmm2, %xmm2, %xmm3; /// 1 3 1.00 	vhaddps	%xmm3, %xmm3, %xmm4; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h:839,Performance,Latency,Latency,839,"//===--------------------- InstructionInfoView.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the instruction info view.; ///; /// The goal fo the instruction info view is to print the latency and reciprocal; /// throughput information for every instruction in the input sequence.; /// This section also reports extra information related to the number of micro; /// opcodes, and opcode properties (i.e. 'MayLoad', 'MayStore', 'HasSideEffects); ///; /// Example:; ///; /// Instruction Info:; /// [1]: #uOps; /// [2]: Latency; /// [3]: RThroughput; /// [4]: MayLoad; /// [5]: MayStore; /// [6]: HasSideEffects; ///; /// [1] [2] [3] [4] [5] [6]	Instructions:; /// 1 2 1.00 	vmulps	%xmm0, %xmm1, %xmm2; /// 1 3 1.00 	vhaddps	%xmm2, %xmm2, %xmm3; /// 1 3 1.00 	vhaddps	%xmm3, %xmm3, %xmm4; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionView.h:423,Integrability,interface,interface,423,"//===----------------------- InstructionView.h ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the main interface for Views that examine and reference; /// a sequence of machine instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp:444,Integrability,interface,interface,444,"//===--------------------- RegisterFileStatistics.cpp -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the RegisterFileStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp:48,Energy Efficiency,schedul,scheduling,48,// Obtain the register file descriptor from the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h:805,Performance,optimiz,optimizable,805,"//===--------------------- RegisterFileStatistics.h -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This view collects and prints register file usage statistics.; ///; /// Example (-mcpu=btver2):; /// ========================; ///; /// Register File statistics:; /// Total number of mappings created: 6; /// Max number of mappings used: 3; ///; /// * Register File #1 -- FpuPRF:; /// Number of physical registers: 72; /// Total number of mappings created: 0; /// Max number of mappings used: 0; /// Number of optimizable moves: 200; /// Number of moves eliminated: 200 (100.0%); /// Number of zero moves: 200 (100.0%); /// Max moves eliminated per cycle: 2; ///; /// * Register File #2 -- IntegerPRF:; /// Number of physical registers: 64; /// Total number of mappings created: 6; /// Max number of mappings used: 3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.cpp:453,Integrability,interface,interface,453,"//===--------------------- ResourcePressureView.cpp -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements methods in the ResourcePressureView interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:520,Deployability,Pipeline,Pipeline,520,"//===--------------------- ResourcePressureView.h ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add fr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:1640,Deployability,pipeline,pipeline,1640,"icense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add from the example uses resource JFPU0 for an average of 1cy; /// per iteration. Consequently, the resource pressure on JFPU0 is of 2cy per; /// iteration.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:1693,Deployability,pipeline,pipeline,1693,"icense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add from the example uses resource JFPU0 for an average of 1cy; /// per iteration. Consequently, the resource pressure on JFPU0 is of 2cy per; /// iteration.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:1594,Performance,throughput,throughput,1594,"icense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add from the example uses resource JFPU0 for an average of 1cy; /// per iteration. Consequently, the resource pressure on JFPU0 is of 2cy per; /// iteration.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp:449,Integrability,interface,interface,449,"//===--------------------- RetireControlUnitStatistics.cpp ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the RetireControlUnitStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp:3,Deployability,Update,Update,3,// Update histogram,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RetireControlUnitStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:27,Energy Efficiency,Schedul,SchedulerStatistics,27,"//===--------------------- SchedulerStatistics.cpp --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the SchedulerStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:421,Energy Efficiency,Schedul,SchedulerStatistics,421,"//===--------------------- SchedulerStatistics.cpp --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the SchedulerStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:441,Integrability,interface,interface,441,"//===--------------------- SchedulerStatistics.cpp --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the SchedulerStatistics interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:143,Deployability,release,released,143,"// FIXME: This implementation works under the assumption that load/store queue; // entries are reserved at 'instruction dispatched' stage, and released at; // 'instruction executed' stage. This currently matches the behavior of LSUnit.; //; // The current design minimizes the number of events generated by the; // Dispatch/Execute stages, at the cost of doing extra bookkeeping in method; // `onEvent`. However, it introduces a subtle dependency between this view and; // how the LSUnit works.; //; // In future we should add a new ""memory queue"" event type, so that we stop; // making assumptions on how LSUnit internally works (See PR39828).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:436,Integrability,depend,dependency,436,"// FIXME: This implementation works under the assumption that load/store queue; // entries are reserved at 'instruction dispatched' stage, and released at; // 'instruction executed' stage. This currently matches the behavior of LSUnit.; //; // The current design minimizes the number of events generated by the; // Dispatch/Execute stages, at the cost of doing extra bookkeeping in method; // `onEvent`. However, it introduces a subtle dependency between this view and; // how the LSUnit works.; //; // In future we should add a new ""memory queue"" event type, so that we stop; // making assumptions on how LSUnit internally works (See PR39828).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:62,Performance,load,load,62,"// FIXME: This implementation works under the assumption that load/store queue; // entries are reserved at 'instruction dispatched' stage, and released at; // 'instruction executed' stage. This currently matches the behavior of LSUnit.; //; // The current design minimizes the number of events generated by the; // Dispatch/Execute stages, at the cost of doing extra bookkeeping in method; // `onEvent`. However, it introduces a subtle dependency between this view and; // how the LSUnit works.; //; // In future we should add a new ""memory queue"" event type, so that we stop; // making assumptions on how LSUnit internally works (See PR39828).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:73,Performance,queue,queue,73,"// FIXME: This implementation works under the assumption that load/store queue; // entries are reserved at 'instruction dispatched' stage, and released at; // 'instruction executed' stage. This currently matches the behavior of LSUnit.; //; // The current design minimizes the number of events generated by the; // Dispatch/Execute stages, at the cost of doing extra bookkeeping in method; // `onEvent`. However, it introduces a subtle dependency between this view and; // how the LSUnit works.; //; // In future we should add a new ""memory queue"" event type, so that we stop; // making assumptions on how LSUnit internally works (See PR39828).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp:541,Performance,queue,queue,541,"// FIXME: This implementation works under the assumption that load/store queue; // entries are reserved at 'instruction dispatched' stage, and released at; // 'instruction executed' stage. This currently matches the behavior of LSUnit.; //; // The current design minimizes the number of events generated by the; // Dispatch/Execute stages, at the cost of doing extra bookkeeping in method; // `onEvent`. However, it introduces a subtle dependency between this view and; // how the LSUnit works.; //; // In future we should add a new ""memory queue"" event type, so that we stop; // making assumptions on how LSUnit internally works (See PR39828).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:27,Energy Efficiency,Schedul,SchedulerStatistics,27,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:420,Energy Efficiency,Schedul,SchedulerStatistics,420,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:447,Energy Efficiency,Schedul,SchedulerStatistics,447,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:589,Energy Efficiency,schedul,schedulers,589,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:644,Energy Efficiency,Schedul,Schedulers,644,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:804,Energy Efficiency,Schedul,Scheduler,804,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:816,Performance,queue,queue,816,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:25,Energy Efficiency,schedul,scheduler,25,// Tracks the usage of a scheduler's queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:37,Performance,queue,queue,37,// Tracks the usage of a scheduler's queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:32,Energy Efficiency,schedul,scheduler,32,// Increases the number of used scheduler queue slots of every buffered; // resource in the Buffers set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:42,Performance,queue,queue,42,// Increases the number of used scheduler queue slots of every buffered; // resource in the Buffers set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:39,Energy Efficiency,schedul,scheduler,39,// Decreases by one the number of used scheduler queue slots of every; // buffered resource in the Buffers set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:49,Performance,queue,queue,49,// Decreases by one the number of used scheduler queue slots of every; // buffered resource in the Buffers set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp:105,Availability,avail,available,105,// Update the cumulative number of resource cycles based on the processor; // resource usage information available from the instruction descriptor. We; // need to compute the cumulative number of resource cycles for every; // processor resource which is consumed by an instruction of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp:3,Deployability,Update,Update,3,// Update the cumulative number of resource cycles based on the processor; // resource usage information available from the instruction descriptor. We; // need to compute the cumulative number of resource cycles for every; // processor resource which is consumed by an instruction of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:519,Performance,perform,performance,519,"//===--------------------- SummaryView.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the summary view.; ///; /// The goal of the summary view is to give a very quick overview of the; /// performance throughput. Below is an example of summary view:; ///; ///; /// Iterations: 300; /// Instructions: 900; /// Total Cycles: 610; /// Dispatch Width: 2; /// IPC: 1.48; /// Block RThroughput: 2.0; ///; /// The summary view collects a few performance numbers. The two main; /// performance indicators are 'Total Cycles' and IPC (Instructions Per Cycle).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:531,Performance,throughput,throughput,531,"//===--------------------- SummaryView.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the summary view.; ///; /// The goal of the summary view is to give a very quick overview of the; /// performance throughput. Below is an example of summary view:; ///; ///; /// Iterations: 300; /// Instructions: 900; /// Total Cycles: 610; /// Dispatch Width: 2; /// IPC: 1.48; /// Block RThroughput: 2.0; ///; /// The summary view collects a few performance numbers. The two main; /// performance indicators are 'Total Cycles' and IPC (Instructions Per Cycle).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:765,Performance,perform,performance,765,"//===--------------------- SummaryView.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the summary view.; ///; /// The goal of the summary view is to give a very quick overview of the; /// performance throughput. Below is an example of summary view:; ///; ///; /// Iterations: 300; /// Instructions: 900; /// Total Cycles: 610; /// Dispatch Width: 2; /// IPC: 1.48; /// Block RThroughput: 2.0; ///; /// The summary view collects a few performance numbers. The two main; /// performance indicators are 'Total Cycles' and IPC (Instructions Per Cycle).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:804,Performance,perform,performance,804,"//===--------------------- SummaryView.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the summary view.; ///; /// The goal of the summary view is to give a very quick overview of the; /// performance throughput. Below is an example of summary view:; ///; ///; /// Iterations: 300; /// Instructions: 900; /// Total Cycles: 610; /// Dispatch Width: 2; /// IPC: 1.48; /// Block RThroughput: 2.0; ///; /// The summary view collects a few performance numbers. The two main; /// performance indicators are 'Total Cycles' and IPC (Instructions Per Cycle).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:42,Performance,perform,performance,42,/// A view that collects and prints a few performance numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:81,Availability,mask,mask,81,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:170,Availability,mask,masks,170,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:254,Energy Efficiency,schedul,scheduling,254,// Each processor resource is associated with a so-called processor resource; // mask. This vector allows to correlate processor resource IDs with processor; // resource masks. There is exactly one element per each processor resource; // declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp:435,Integrability,interface,interface,435,"//===--------------------- TimelineView.cpp ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \brief; ///; /// This file implements the TimelineView interface.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp:3,Deployability,Update,Update,3,// Update the WaitTime entry which corresponds to this Index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp:8,Performance,latency,latency,8,"// Zero latency instructions have the same value for CycleDispatched,; // CycleIssued and CycleExecuted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp:131,Performance,latency,latency,131,"// When an instruction is retired after timeline-max-cycles,; // its CycleRetired is left at 0. However, it's possible for; // a 0 latency instruction to be retired during cycle 0 and we; // don't want to early exit in that case. The CycleExecuted; // attribute is set correctly whether or not it is greater; // than timeline-max-cycles so we can use that to ensure; // we don't early exit because of a 0 latency instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp:405,Performance,latency,latency,405,"// When an instruction is retired after timeline-max-cycles,; // its CycleRetired is left at 0. However, it's possible for; // a 0 latency instruction to be retired during cycle 0 and we; // don't want to early exit in that case. The CycleExecuted; // attribute is set correctly whether or not it is greater; // than timeline-max-cycles so we can use that to ensure; // we don't early exit because of a 0 latency instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:519,Deployability,pipeline,pipeline,519,"//===--------------------- TimelineView.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \brief; ///; /// This file implements a timeline view for the llvm-mca tool.; ///; /// Class TimelineView observes events generated by the pipeline. For every; /// instruction executed by the pipeline, it stores information related to; /// state transition. It then plots that information in the form of a table; /// as reported by the example below:; ///; /// Timeline view:; /// 	 0123456; /// Index	0123456789; ///; /// [0,0]	DeER . . ..	vmovshdup %xmm0, %xmm1; /// [0,1]	DeER . . ..	vpermilpd $1, %xmm0, %xmm2; /// [0,2]	.DeER. . ..	vpermilps $231, %xmm0, %xmm5; /// [0,3]	.DeeeER . ..	vaddss %xmm1, %xmm0, %xmm3; /// [0,4]	. D==eeeER. ..	vaddss %xmm3, %xmm2, %xmm4; /// [0,5]	. D=====eeeER ..	vaddss %xmm4, %xmm5, %xmm6; ///; /// [1,0]	. DeE------R ..	vmovshdup %xmm0, %xmm1; /// [1,1]	. DeE------R ..	vpermilpd $1, %xmm0, %xmm2; /// [1,2]	. DeE-----R ..	vpermilps $231, %xmm0, %xmm5; /// [1,3]	. D=eeeE--R ..	vaddss %xmm1, %xmm0, %xmm3; /// [1,4]	. D===eeeER ..	vaddss %xmm3, %xmm2, %xmm4; /// [1,5]	. D======eeeER	vaddss %xmm4, %xmm5, %xmm6; ///; /// There is an entry for every instruction in the input assembly sequence.; /// The first field is a pair of numbers obtained from the instruction index.; /// The first element of the pair is the iteration index, while the second; /// element of the pair is a sequence number (i.e. a position in the assembly; /// sequence).; /// The second field of the table is the actual timeline information; each; /// column is the information related to a specific cycle of execution.; /// The timeline of an instruction is described by a sequence of character; /// where each ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:572,Deployability,pipeline,pipeline,572,"//===--------------------- TimelineView.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \brief; ///; /// This file implements a timeline view for the llvm-mca tool.; ///; /// Class TimelineView observes events generated by the pipeline. For every; /// instruction executed by the pipeline, it stores information related to; /// state transition. It then plots that information in the form of a table; /// as reported by the example below:; ///; /// Timeline view:; /// 	 0123456; /// Index	0123456789; ///; /// [0,0]	DeER . . ..	vmovshdup %xmm0, %xmm1; /// [0,1]	DeER . . ..	vpermilpd $1, %xmm0, %xmm2; /// [0,2]	.DeER. . ..	vpermilps $231, %xmm0, %xmm5; /// [0,3]	.DeeeER . ..	vaddss %xmm1, %xmm0, %xmm3; /// [0,4]	. D==eeeER. ..	vaddss %xmm3, %xmm2, %xmm4; /// [0,5]	. D=====eeeER ..	vaddss %xmm4, %xmm5, %xmm6; ///; /// [1,0]	. DeE------R ..	vmovshdup %xmm0, %xmm1; /// [1,1]	. DeE------R ..	vpermilpd $1, %xmm0, %xmm2; /// [1,2]	. DeE-----R ..	vpermilps $231, %xmm0, %xmm5; /// [1,3]	. D=eeeE--R ..	vaddss %xmm1, %xmm0, %xmm3; /// [1,4]	. D===eeeER ..	vaddss %xmm3, %xmm2, %xmm4; /// [1,5]	. D======eeeER	vaddss %xmm4, %xmm5, %xmm6; ///; /// There is an entry for every instruction in the input assembly sequence.; /// The first field is a pair of numbers obtained from the instruction index.; /// The first element of the pair is the iteration index, while the second; /// element of the pair is a sequence number (i.e. a position in the assembly; /// sequence).; /// The second field of the table is the actual timeline information; each; /// column is the information related to a specific cycle of execution.; /// The timeline of an instruction is described by a sequence of character; /// where each ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4295,Deployability,pipeline,pipeline,4295,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:2280,Energy Efficiency,Schedul,Scheduler,2280,"xmm2; /// [1,2]	. DeE-----R ..	vpermilps $231, %xmm0, %xmm5; /// [1,3]	. D=eeeE--R ..	vaddss %xmm1, %xmm0, %xmm3; /// [1,4]	. D===eeeER ..	vaddss %xmm3, %xmm2, %xmm4; /// [1,5]	. D======eeeER	vaddss %xmm4, %xmm5, %xmm6; ///; /// There is an entry for every instruction in the input assembly sequence.; /// The first field is a pair of numbers obtained from the instruction index.; /// The first element of the pair is the iteration index, while the second; /// element of the pair is a sequence number (i.e. a position in the assembly; /// sequence).; /// The second field of the table is the actual timeline information; each; /// column is the information related to a specific cycle of execution.; /// The timeline of an instruction is described by a sequence of character; /// where each character represents the instruction state at a specific cycle.; ///; /// Possible instruction states are:; /// D: Instruction Dispatched; /// e: Instruction Executing; /// E: Instruction Executed (write-back stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, cla",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3188,Energy Efficiency,schedul,scheduler,3188,"stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. A",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3454,Energy Efficiency,schedul,scheduler,3454,"he assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===---------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3514,Energy Efficiency,schedul,scheduler,3514,"he assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===---------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4064,Energy Efficiency,schedul,scheduler,4064,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4191,Energy Efficiency,schedul,scheduler,4191,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4094,Integrability,depend,dependencies,4094,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:2292,Performance,queue,queue,2292,"xmm2; /// [1,2]	. DeE-----R ..	vpermilps $231, %xmm0, %xmm5; /// [1,3]	. D=eeeE--R ..	vaddss %xmm1, %xmm0, %xmm3; /// [1,4]	. D===eeeER ..	vaddss %xmm3, %xmm2, %xmm4; /// [1,5]	. D======eeeER	vaddss %xmm4, %xmm5, %xmm6; ///; /// There is an entry for every instruction in the input assembly sequence.; /// The first field is a pair of numbers obtained from the instruction index.; /// The first element of the pair is the iteration index, while the second; /// element of the pair is a sequence number (i.e. a position in the assembly; /// sequence).; /// The second field of the table is the actual timeline information; each; /// column is the information related to a specific cycle of execution.; /// The timeline of an instruction is described by a sequence of character; /// where each character represents the instruction state at a specific cycle.; ///; /// Possible instruction states are:; /// D: Instruction Dispatched; /// e: Instruction Executing; /// E: Instruction Executed (write-back stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, cla",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3030,Performance,bottleneck,bottlenecks,3030,"state at a specific cycle.; ///; /// Possible instruction states are:; /// D: Instruction Dispatched; /// e: Instruction Executing; /// E: Instruction Executed (write-back stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3200,Performance,queue,queue,3200,"stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. A",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3466,Performance,queue,queue,3466,"he assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===---------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3526,Performance,queue,queue,3526,"he assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===---------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4076,Performance,queue,queue,4076,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4203,Performance,queue,queue,4203,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:161,Deployability,Pipeline,Pipeline,161,"/// This class listens to instruction state transition events; /// in order to construct a timeline information.; ///; /// For every instruction executed by the Pipeline, this class constructs; /// a TimelineViewEntry object. TimelineViewEntry objects are then used; /// to print the timeline information, as well as the ""average wait times""; /// for every instruction in the input assembly sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:33,Energy Efficiency,schedul,scheduler,33,// Instruction is waiting in the scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp:49,Safety,sanity check,sanity check,49,"//===--- DummyDemanglerMain.cpp - Entry point to sanity check the fuzzer --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp:426,Testability,test,test,426,"//===--- DummyDemanglerMain.cpp - Entry point to sanity check the fuzzer --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of main so we can build and test without linking libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-microsoft-demangle-fuzzer/DummyDemanglerFuzzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/Disassembler.cpp:17,Availability,error,error,17,"// If we have an error, print it and skip to the end of line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ml/Disassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/Disassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp:385,Usability,simpl,simple,385,"//===-- llvm-ml.cpp - masm-compatible assembler -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A simple driver around MasmParser; based on llvm-mc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp:14,Safety,safe,safe,14,// Not thread-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp:14,Safety,safe,safe,14,// Not thread-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp:21,Availability,error,errors,21,// Keep output if no errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-modextract/llvm-modextract.cpp:403,Testability,test,testing,403,"//===-- llvm-modextract.cpp - LLVM module extractor utility ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program is for testing features that rely on multi-module bitcode files.; // It takes a multi-module bitcode file, extracts one of the modules and writes; // it to the output file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-modextract/llvm-modextract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-modextract/llvm-modextract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:19,Availability,error,error,19,"// This version of error() prints the archive name and member name, for example:; // ""libx.a(foo.o)"" after the ToolName before the error message. It sets; // HadError but returns allowing the code to move on to other archive members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:131,Availability,error,error,131,"// This version of error() prints the archive name and member name, for example:; // ""libx.a(foo.o)"" after the ToolName before the error message. It sets; // HadError but returns allowing the code to move on to other archive members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:137,Integrability,message,message,137,"// This version of error() prints the archive name and member name, for example:; // ""libx.a(foo.o)"" after the ToolName before the error message. It sets; // HadError but returns allowing the code to move on to other archive members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:22,Availability,error,error,22,"// TODO: if we have a error getting the name then it would be nice to print; // the index of which archive member this is and or its offset in the; // archive instead of ""???"" as the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:19,Availability,error,error,19,"// This version of error() prints the file name and which architecture slice it; // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:172,Availability,error,error,172,"// This version of error() prints the file name and which architecture slice it; // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:178,Integrability,message,message,178,"// This version of error() prints the file name and which architecture slice it; // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:47,Availability,error,error,47,"// If the I->getSection() call would return an error, the earlier I->getType(); // call will already have returned the same error first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:124,Availability,error,error,124,"// If the I->getSection() call would return an error, the earlier I->getType(); // call will already have returned the same error first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:128,Testability,test,test,128,// There is no symbol in the nlist symbol table for this so we set; // Sym effectivly to null and the rest of code in here must test for; // it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:138,Testability,test,test,138,// Again there is no symbol in the nlist symbol table for this so; // we set Sym effectivly to null and the rest of code in here must; // test for it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:128,Testability,test,test,128,// There is no symbol in the nlist symbol table for this so we set; // Sym effectivly to null and the rest of code in here must test for; // it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:128,Testability,test,test,128,// There is no symbol in the nlist symbol table for this so we set; // Sym effectivly to null and the rest of code in here must test for; // it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:128,Testability,test,test,128,// There is no symbol in the nlist symbol table for this so we set; // Sym effectivly to null and the rest of code in here must test for; // it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:67,Energy Efficiency,consumption,consumption,67,"// We found a function starts segment, parse the addresses for; // consumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:128,Testability,test,test,128,// There is no symbol in the nlist symbol table for this so we set; // Sym effectivly to null and the rest of code in here must test for; // it and not do things like Sym.getFlags() for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:29,Availability,error,error,29,// Returns false if there is error found or true otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:18,Availability,error,error,18,"// If there is an error in hasSymbols(), the error should be encountered in; // function getSymbolNamesFromObject first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:45,Availability,error,error,45,"// If there is an error in hasSymbols(), the error should be encountered in; // function getSymbolNamesFromObject first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:282,Availability,error,error,282,// checkMachOAndArchFlags() checks to see if the SymbolicFile is a Mach-O file; // and if it is and there is a list of architecture flags is specified then; // check to make sure this Mach-O file is one of those architectures or all; // architectures was specificed. If not then an error is generated and this; // routine returns false. Else it returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:314,Integrability,rout,routine,314,// checkMachOAndArchFlags() checks to see if the SymbolicFile is a Mach-O file; // and if it is and there is a list of architecture flags is specified then; // check to make sure this Mach-O file is one of those architectures or all; // architectures was specificed. If not then an error is generated and this; // routine returns false. Else it returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:32,Modifiability,variab,variable,32,"// Get BitMode from enviornment variable ""OBJECT_MODE"" for AIX OS, if; // specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:167,Deployability,install,install-name-tool,167,// We need to recognize the following filenames:; //; // llvm-objcopy -> objcopy; // strip-10.exe -> strip; // powerpc64-unknown-freebsd13-objcopy -> objcopy; // llvm-install-name-tool -> install-name-tool,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:188,Deployability,install,install-name-tool,188,// We need to recognize the following filenames:; //; // llvm-objcopy -> objcopy; // strip-10.exe -> strip; // powerpc64-unknown-freebsd13-objcopy -> objcopy; // llvm-install-name-tool -> install-name-tool,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:38,Modifiability,Config,Config,38,// Apply transformations described by Config and store result into; // Config.OutputFilename using specified ObjcopyFunc function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:71,Modifiability,Config,Config,71,// Apply transformations described by Config and store result into; // Config.OutputFilename using specified ObjcopyFunc function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:29,Modifiability,Config,Config,29,// Copy .dwo tables from the Config.InputFilename into Config.SplitDWO; // file using specified ObjcopyFunc function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:55,Modifiability,Config,Config,55,// Copy .dwo tables from the Config.InputFilename into Config.SplitDWO; // file using specified ObjcopyFunc function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:38,Modifiability,Config,Config,38,"// Apply transformations described by Config, remove .dwo tables and; // store result into Config.OutputFilename using specified ObjcopyFunc; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp:91,Modifiability,Config,Config,91,"// Apply transformations described by Config, remove .dwo tables and; // store result into Config.OutputFilename using specified ObjcopyFunc; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/llvm-objcopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp
